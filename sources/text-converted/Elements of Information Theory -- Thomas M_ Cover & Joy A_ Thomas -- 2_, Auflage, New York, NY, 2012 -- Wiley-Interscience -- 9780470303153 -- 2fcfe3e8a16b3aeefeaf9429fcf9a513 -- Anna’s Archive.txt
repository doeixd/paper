Cover

Contents Contents Cover Half Title page Title page Copyright page Preface to the Second Edition Preface to the First Edition Acknowledgments for the Second Edition Acknowledgments for the First Edition Chapter 1: Introduction and Preview 1.1 Preview of the Book Chapter 2: Entropy, Relative Entropy, and Mutual Information 2.1 Entropy 2.2 Joint Entropy and Conditional Entropy 2.3 Relative Entropy and Mutual Information 2.4 Relationship Between Entropy and Mutual Information 2.5 Chain Rules for Entropy, Relative Entropy, and Mutual Information 2.6 Jensen’s Inequality and Its Consequences 2.7 Log Sum Inequality and Its Applications 2.8 Data-Processing Inequality 2.9 Sufficient Statistics 2.10 Fano’s Inequality Summary Problems Historical Notes Chapter 3: Asymptotic Equipartition Property 3.1 Asymptotic Equipartition Property Theorem 3.2 Consequences of the AEP: Data Compression 3.3 High-Probability Sets and The Typical Set Summary Problems Historical Notes Chapter 4: Entropy Rates of a Stochastic Process 4.1 Markov Chains 4.2 Entropy Rate 4.3 Example: Entropy Rate of a Random Walk on a Weighted Graph 4.4 Second Law of Thermodynamics 4.5 Functions of Markov Chains Summary Problems Historical Notes Chapter 5: Data Compression 5.1 Examples of Codes 5.2 Kraft Inequality 5.3 Optimal Codes 5.4 Bounds on the Optimal Code Length 5.5 Kraft Inequality for Uniquely Decodable Codes 5.6 Huffman Codes 5.7 Some Comments on Huffman Codes 5.8 Optimality of Huffman Codes 5.9 Shannon–Fano–Elias Coding 5.10 Competitive Optimality of the Shannon Code 5.11 Generation of Discrete Distributions from Fair Coins Summary Problems Historical Notes Chapter 6: Gambling and Data Compression 6.1 The Horse Race 6.2 Gambling and Side Information 6.3 Dependent Horse Races and Entropy Rate 6.4 The Entropy of English 6.5 Data Compression and Gambling 6.6 Gambling Estimate of the Entropy of English Summary Problems Historical Notes Chapter 7: Channel Capacity 7.1 Examples of Channel Capacity 7.2 Symmetric Channels 7.3 Properties of Channel Capacity 7.4 Preview of the Channel Coding Theorem 7.5 Definitions 7.6 Jointly Typical Sequences 7.7 Channel Coding Theorem 7.8 Zero-Error Codes 7.9 Fano’s Inequality and the Converse to the Coding Theorem 7.10 Equality in the Converse to the Channel Coding Theorem 7.11 Hamming Codes 7.12 Feedback Capacity 7.13 Source–Channel Separation Theorem Summary Problems Historical Notes Chapter 8: Differential Entropy 8.1 Definitions 8.2 AEP for Continuous Random Variables 8.3 Relation of Differential Entropy to Discrete Entropy 8.4 Joint and Conditional Differential Entropy 8.5 Relative Entropy and Mutual Information 8.6 Properties of Differential Entropy, Relative Entropy, and Mutual Information Summary Problems Historical Notes Chapter 9: Gaussian Channel 9.1 Gaussian Channel: Definitions 9.2 Converse to the Coding Theorem for Gaussian Channels 9.3 Bandlimited Channels 9.4 Parallel Gaussian Channels 9.5 Channels with Colored Gaussian Noise 9.6 Gaussian Channels with Feedback Summary Problems Historical Notes Chapter 10: Rate Distortion Theory 10.1 Quantization 10.2 Definitions 10.3 Calculation of the Rate Distortion Function 10.4 Converse to the Rate Distortion Theorem 10.5 Achievability of the Rate Distortion Function 10.6 Strongly Typical Sequences and Rate Distortion 10.7 Characterization of the Rate Distortion Function 10.8 Computation of Channel Capacity and the Rate Distortion Function Summary Problems Historical Notes Chapter 11: Information Theory and Statistics 11.1 Method of Types 11.2 Law of Large Numbers 11.3 Universal Source Coding 11.4 Large Deviation Theory 11.5 Examples of Sanov’s Theorem 11.6 Conditional Limit Theorem 11.7 Hypothesis Testing 11.8 Chernoff–Stein Lemma 11.9 Chernoff Information 11.10 Fisher Information and the CraméR–RAO INEQUALITY Summary Problems Historical Notes Chapter 12: Maximum Entropy 12.1 Maximum Entropy Distributions 12.2 Examples 12.3 Anomalous Maximum Entropy Problem 12.4 Spectrum Estimation 12.5 Entropy Rates of a Gaussian Process 12.6 Burg’s Maximum Entropy Theorem Summary Problems Historical Notes Chapter 13: Universal Source Coding 13.1 Universal Codes and Channel Capacity 13.2 Universal Coding for Binary Sequences 13.3 Arithmetic Coding 13.4 Lempel–Ziv Coding 13.5 Optimality of Lempel–Ziv Algorithms Summary Problems Historical Notes Chapter 14: Kolmogorov Complexity 14.1 Models of Computation 14.2 Kolmogorov Complexity: Definitions and Examples 14.3 Kolmogorov Complexity and Entropy 14.4 Kolmogorov Complexity of Integers 14.5 Algorithmically Random and Incompressible Sequences 14.6 Universal Probability 14.7 The Halting Problem and the Noncomputability of Kolmogorov Complexity 14.8 Ω 14.9 Universal Gambling 14.10 Occam’s Razor 14.11 Kolmogorov Complexity and Universal Probability 14.12 Kolmogorov Sufficient Statistic 14.13 Minimum Description Length Principle Summary Problems Historical Notes Chapter 15: Network Information Theory 15.1 Gaussian Multiple-User Channels 15.2 Jointly Typical Sequences 15.3 Multiple-Access Channel 15.4 Encoding of Correlated Sources 15.5 Duality Between Slepian–Wolf Encoding and Multiple-Access Channels 15.6 Broadcast Channel 15.7 Relay Channel 15.8 Source Coding with Side Information 15.9 Rate Distortion with Side Information 15.10 General Multiterminal Networks Summary Problems Historical Notes Chapter 16: Information Theory and Portfolio Theory 16.1 The Stock Market: Some Definitions 16.2 Kuhn–Tucker Characterization of the Log-Optimal Portfolio 16.3 Asymptotic Optimality of the Log-Optimal Portfolio 16.4 Side Information and the Growth Rate 16.5 Investment in Stationary Markets 16.6 Competitive Optimality of the Log-Optimal Portfolio 16.7 Universal Portfolios 16.8 Shannon–McMillan-Breiman Theorem (General AEP) Summary Problems Historical Notes Chapter 17: Inequalities in Information Theory 17.1 Basic Inequalities of Information Theory 17.2 Differential Entropy 17.3 Bounds on Entropy and Relative Entropy 17.4 Inequalities for Types 17.5 Combinatorial Bounds on Entropy 17.6 Entropy rates of Subsets 17.7 Entropy and Fisher Information 17.8 Entropy Power Inequality and Brunn–Minkowski Inequality 17.9 Inequalities for Determinants 17.10 Inequalities for Ratios of Determinants Summary Problems Historical Notes Bibliography List of Symbols Index

Title Page ELEMENTS OF INFORMATION THEORY

Title Page

Copyright Copyright © 2006 by John Wiley & Sons, Inc. All rights reserved. Published by John Wiley & Sons, Inc., Hoboken, New Jersey. Published simultaneously in Canada. No part of this publication may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, electronic, mechanical, photocopying, recording, scanning, or otherwise, except as permitted under Section 107 or 108 of the 1976 United States Copyright Act, without either the prior written permission of the Publisher, or authorization through payment of the appropriate per-copy fee to the Copyright Clearance Center, Inc., 222 Rosewood Drive, Danvers, MA 01923, (978) 750-8400, fax (978) 750-4470, or on the web at www.copyright.com . Requests to the Publisher for permission should be addressed to the Permissions Department, John Wiley & Sons, Inc., 111 River Street, Hoboken, NJ 07030, (201) 748-6011, fax (201) 748-6008, or online at http://www.wiley.com/go/permission . Limit of Liability/Disclaimer of Warranty: While the publisher and author have used their best efforts in preparing this book, they make no representations or warranties with respect to the accuracy or completeness of the contents of this book and specifically disclaim any implied warranties of merchantability or fitness for a particular purpose. No warranty may be created or extended by sales representatives or written sales materials. The advice and strategies contained herein may not be suitable for your situation. You should consult with a professional where appropriate. Neither the publisher nor author shall be liable for any loss of profit or any other commercial damages, including but not limited to special, incidental, consequential, or other damages. For general information on our other products and services or for technical support, please contact our Customer Care Department within the United States at (800) 762-2974, outside the United States at (317) 572-3993 or fax (317) 572-4002. Wiley also publishes its books in a variety of electronic formats. Some content that appears in print may not be available in electronic formats. For more information about Wiley products, visit our web site at www.wiley.com . Library of Congress Cataloging-in-Publication Data: Cover, T. M., 1938– Elements of information theory/by Thomas M. Cover, Joy A. Thomas.–2nd ed. p. cm. “A Wiley-Interscience publication.” Includes bibliographical references and index. ISBN-13 978-0-471-24195-9 ISBN-10 0-471-24195-4 1. Information theory. I. Thomas, Joy A. II. Title. Q360.C68 2005 003′.54–dc22 2005047799

Preface to the Second Edition PREFACE TO THE SECOND EDITION In the years since the publication of the first edition, there were many aspects of the book that we wished to improve, to rearrange, or to expand, but the constraints of reprinting would not allow us to make those changes between printings. In the new edition, we now get a chance to make some of these changes, to add problems, and to discuss some topics that we had omitted from the first edition. The key changes include a reorganization of the chapters to make the book easier to teach, and the addition of more than two hundred new problems. We have added material on universal portfolios, universal source coding, Gaussian feedback capacity, network information theory, and developed the duality of data compression and channel capacity. A new chapter has been added and many proofs have been simplified. We have also updated the references and historical notes. The material in this book can be taught in a two-quarter sequence. The first quarter might cover Chapters 1 to 9, which includes the asymptotic equipartition property, data compression, and channel capacity, culminating in the capacity of the Gaussian channel. The second quarter could cover the remaining chapters, including rate distortion, the method of types, Kolmogorov complexity, network information theory, universal source coding, and portfolio theory. If only one semester is available, we would add rate distortion and a single lecture each on Kolmogorov complexity and network information theory to the first semester. A web site, http://www.elementsofinformationtheory.com , provides links to additional material and solutions to selected problems. In the years since the first edition of the book, information theory celebrated its 50th birthday (the 50th anniversary of Shannon’s original paper that started the field), and ideas from information theory have been applied to many problems of science and technology, including bioinformatics, web search, wireless communication, video compression, and others. The list of applications is endless, but it is the elegance of the fundamental mathematics that is still the key attraction of this area. We hope that this book will give some insight into why we believe that this is one of the most interesting areas at the intersection of mathematics, physics, statistics, and engineering. TOM COVER JOY THOMAS Palo Alto, California January 2006

Preface to the First Edition PREFACE TO THE FIRST EDITION This is intended to be a simple and accessible book on information theory. As Einstein said, “ Everything should be made as simple as possible, but no simpler .” Although we have not verified the quote (first found in a fortune cookie), this point of view drives our development throughout the book. There are a few key ideas and techniques that, when mastered, make the subject appear simple and provide great intuition on new questions. This book has arisen from over ten years of lectures in a two-quarter sequence of a senior and first-year graduate-level course in information theory, and is intended as an introduction to information theory for students of communication theory, computer science, and statistics. There are two points to be made about the simplicities inherent in information theory. First, certain quantities like entropy and mutual information arise as the answers to fundamental questions. For example, entropy is the minimum descriptive complexity of a random variable, and mutual information is the communication rate in the presence of noise. Also, as we shall point out, mutual information corresponds to the increase in the doubling rate of wealth given side information. Second, the answers to information theoretic questions have a natural algebraic structure. For example, there is a chain rule for entropies, and entropy and mutual information are related. Thus the answers to problems in data compression and communication admit extensive interpretation. We all know the feeling that follows when one investigates a problem, goes through a large amount of algebra, and finally investigates the answer to find that the entire problem is illuminated not by the analysis but by the inspection of the answer. Perhaps the outstanding examples of this in physics are Newton’s laws and Schrödinger’s wave equation. Who could have foreseen the awesome philosophical interpretations of Schrödinger’s wave equation? In the text we often investigate properties of the answer before we look at the question. For example, in Chapter 2, we define entropy, relative entropy, and mutual information and study the relationships and a few interpretations of them, showing how the answers fit together in various ways. Along the way we speculate on the meaning of the second law of thermodynamics. Does entropy always increase? The answer is yes and no. This is the sort of result that should please experts in the area but might be overlooked as standard by the novice. In fact, that brings up a point that often occurs in teaching. It is fun to find new proofs or slightly new results that no one else knows. When one presents these ideas along with the established material in class, the response is “sure, sure, sure.” But the excitement of teaching the material is greatly enhanced. Thus we have derived great pleasure from investigating a number of new ideas in this textbook. Examples of some of the new material in this text include the chapter on the relationship of information theory to gambling, the work on the universality of the second law of thermodynamics in the context of Markov chains, the joint typicality proofs of the channel capacity theorem, the competitive optimality of Huffman codes, and the proof of Burg’s theorem on maximum entropy spectral density estimation. Also, the chapter on Kolmogorov complexity has no counterpart in other information theory texts. We have also taken delight in relating Fisher information, mutual information, the central limit theorem, and the Brunn–Minkowski and entropy power inequalities. To our surprise, many of the classical results on determinant inequalities are most easily proved using information theoretic inequalities. Even though the field of information theory has grown considerably since Shannon’s original paper, we have strived to emphasize its coherence. While it is clear that Shannon was motivated by problems in communication theory when he developed information theory, we treat information theory as a field of its own with applications to communication theory and statistics. We were drawn to the field of information theory from backgrounds in communication theory, probability theory, and statistics, because of the apparent impossibility of capturing the intangible concept of information. Since most of the results in the book are given as theorems and proofs, we expect the elegance of the results to speak for themselves. In many cases we actually describe the properties of the solutions before the problems. Again, the properties are interesting in themselves and provide a natural rhythm for the proofs that follow. One innovation in the presentation is our use of long chains of inequalities with no intervening text followed immediately by the explanations. By the time the reader comes to many of these proofs, we expect that he or she will be able to follow most of these steps without any explanation and will be able to pick out the needed explanations. These chains of inequalities serve as pop quizzes in which the reader can be reassured of having the knowledge needed to prove some important theorems. The natural flow of these proofs is so compelling that it prompted us to flout one of the cardinal rules of technical writing; and the absence of verbiage makes the logical necessity of the ideas evident and the key ideas perspicuous. We hope that by the end of the book the reader will share our appreciation of the elegance, simplicity, and naturalness of information theory. Throughout the book we use the method of weakly typical sequences, which has its origins in Shannon’s original 1948 work but was formally developed in the early 1970s. The key idea here is the asymptotic equipartition property, which can be roughly paraphrased as “Almost everything is almost equally probable.” Chapter 2 includes the basic algebraic relationships of entropy, relative entropy, and mutual information. The asymptotic equipartition property (AEP) is given central prominence in Chapter 3. This leads us to discuss the entropy rates of stochastic processes and data compression in Chapters 4 and 5. A gambling sojourn is taken in Chapter 6, where the duality of data compression and the growth rate of wealth is developed. The sensational success of Kolmogorov complexity as an intellectual foundation for information theory is explored in Chapter 14. Here we replace the goal of finding a description that is good on the average with the goal of finding the universally shortest description. There is indeed a universal notion of the descriptive complexity of an object. Here also the wonderful number Ω is investigated. This number, which is the binary expansion of the probability that a Turing machine will halt, reveals many of the secrets of mathematics. Channel capacity is established in Chapter 7. The necessary material on differential entropy is developed in Chapter 8, laying the groundwork for the extension of previous capacity theorems to continuous noise channels. The capacity of the fundamental Gaussian channel is investigated in Chapter 9. The relationship between information theory and statistics, first studied by Kullback in the early 1950s and relatively neglected since, is developed in Chapter 11. Rate distortion theory requires a little more background than its noiseless data compression counterpart, which accounts for its placement as late as Chapter 10 in the text. The huge subject of network information theory, which is the study of the simultaneously achievable flows of information in the presence of noise and interference, is developed in Chapter 15. Many new ideas come into play in network information theory. The primary new ingredients are interference and feedback. Chapter 16 considers the stock market, which is the generalization of the gambling processes considered in Chapter 6, and shows again the close correspondence of information theory and gambling. Chapter 17, on inequalities in information theory, gives us a chance to recapitulate the interesting inequalities strewn throughout the book, put them in a new framework, and then add some interesting new inequalities on the entropy rates of randomly drawn subsets. The beautiful relationship of the Brunn–Minkowski inequality for volumes of set sums, the entropy power inequality for the effective variance of the sum of independent random variables, and the Fisher information inequalities are made explicit here. We have made an attempt to keep the theory at a consistent level. The mathematical level is a reasonably high one, probably the senior or first-year graduate level, with a background of at least one good semester course in probability and a solid background in mathematics. We have, however, been able to avoid the use of measure theory. Measure theory comes up only briefly in the proof of the AEP for ergodic processes in Chapter 16. This fits in with our belief that the fundamentals of information theory are orthogonal to the techniques required to bring them to their full generalization. The essential vitamins are contained in Chapters 2, 3, 4, 5, 7, 8, 9, 11, 10, and 15. This subset of chapters can be read without essential reference to the others and makes a good core of understanding. In our opinion, Chapter 14 on Kolmogorov complexity is also essential for a deep understanding of information theory. The rest, ranging from gambling to inequalities, is part of the terrain illuminated by this coherent and beautiful subject. Every course has its first lecture, in which a sneak preview and overview of ideas is presented. Chapter 1 plays this role. TOM COVER JOY THOMAS Palo Alto, California June 1990

Acknowledgments for the Second Edition ACKNOWLEDGMENTS FOR THE SECOND EDITION Since the appearance of the first edition, we have been fortunate to receive feedback, suggestions, and corrections from a large number of readers. It would be impossible to thank everyone who has helped us in our efforts, but we would like to list some of them. In particular, we would like to thank all the faculty who taught courses based on this book and the students who took those courses; it is through them that we learned to look at the same material from a different perspective. In particular, we would like to thank Andrew Barron, Alon Orlitsky, T. S. Han, Raymond Yeung, Nam Phamdo, Franz Willems, and Marty Cohn for their comments and suggestions. Over the years, students at Stanford have provided ideas and inspirations for the changes—these include George Gemelos, Navid Hassanpour, Young-Han Kim, Charles Mathis, Styrmir Sigurjonsson, Jon Yard, Michael Baer, Mung Chiang, Suhas Diggavi, Elza Erkip, Paul Fahn, Garud Iyengar, David Julian, Yiannis Kontoyiannis, Amos Lapidoth, Erik Ordentlich, Sandeep Pombra, Jim Roche, Arak Sutivong, Joshua Sweetkind-Singer, and Assaf Zeevi. Denise Murphy provided much support and help during the preparation of the second edition. Joy Thomas would like to acknowledge the support of colleagues at IBM and Stratify who provided valuable comments and suggestions. Particular thanks are due Peter Franaszek, C. S. Chang, Randy Nelson, Ramesh Gopinath, Pandurang Nayak, John Lamping, Vineet Gupta, and Ramana Venkata. In particular, many hours of dicussion with Brandon Roy helped refine some of the arguments in the book. Above all, Joy would like to acknowledge that the second edition would not have been possible without the support and encouragement of his wife, Priya, who makes all things worthwhile. Tom Cover would like to thank his students and his wife, Karen.

Acknowledgments for the First Edition ACKNOWLEDGMENTS FOR THE FIRST EDITION We wish to thank everyone who helped make this book what it is. In particular, Aaron Wyner, Toby Berger, Masoud Salehi, Alon Orlitsky, Jim Mazo and Andrew Barron have made detailed comments on various drafts of the book which guided us in our final choice of content. We would like to thank Bob Gallager for an initial reading of the manuscript and his encouragement to publish it. Aaron Wyner donated his new proof with Ziv on the convergence of the Lempel-Ziv algorithm. We would also like to thank Normam Abramson, Ed van der Meulen, Jack Salz and Raymond Yeung for their suggested revisions. Certain key visitors and research associates contributed as well, including Amir Dembo, Paul Algoet, Hirosuke Yamamoto, Ben Kawabata, M. Shimizu and Yoichiro Watanabe. We benefited from the advice of John Gill when he used this text in his class. Abbas El Gamal made invaluable contributions, and helped begin this book years ago when we planned to write a research monograph on multiple user information theory. We would also like to thank the Ph.D. students in information theory as this book was being written: Laura Ekroot, Will Equitz, Don Kimber, Mitchell Trott, Andrew Nobel, Jim Roche, Erik Ordentlich, Elza Erkip and Vittorio Castelli. Also Mitchell Oslick, Chien-Wen Tseng and Michael Morrell were among the most active students in contributing questions and suggestions to the text. Marc Goldberg and Anil Kaul helped us produce some of the figures. Finally we would like to thank Kirsten Goodell and Kathy Adams for their support and help in some of the aspects of the preparation of the manuscript. Joy Thomas would also like to thank Peter Franaszek, Steve Lavenberg, Fred Jelinek, David Nahamoo and Lalit Bahl for their encouragment and support during the final stages of production of this book.

Chapter 1: Introduction and Preview CHAPTER 1 INTRODUCTION AND PREVIEW Information theory answers two fundamental questions in communication theory: What is the ultimate data compression (answer: the entropy H ), and what is the ultimate transmission rate of communication (answer: the channel capacity C ). For this reason some consider information theory to be a subset of communication theory. We argue that it is much more. Indeed, it has fundamental contributions to make in statistical physics (thermodynamics), computer science (Kolmogorov complexity or algorithmic complexity), statistical inference (Occam’s Razor: “The simplest explanation is best”), and to probability and statistics (error exponents for optimal hypothesis testing and estimation). This “first lecture” chapter goes backward and forward through information theory and its naturally related ideas. The full definitions and study of the subject begin in Chapter 2. Figure 1.1 illustrates the relationship of information theory to other fields. As the figure suggests, information theory intersects physics (statistical mechanics), mathematics (probability theory), electrical engineering (communication theory), and computer science (algorithmic complexity). We now describe the areas of intersection in greater detail. FIGURE 1.1. Relationship of information theory to other fields. Electrical Engineering (Communication Theory). In the early 1940s it was thought to be impossible to send information at a positive rate with negligible probability of error. Shannon surprised the communication theory community by proving that the probability of error could be made nearly zero for all communication rates below channel capacity. The capacity can be computed simply from the noise characteristics of the channel. Shannon further argued that random processes such as music and speech have an irreducible complexity below which the signal cannot be compressed. This he named the entropy , in deference to the parallel use of this word in thermodynamics, and argued that if the entropy of the source is less than the capacity of the channel, asymptotically error-free communication can be achieved. Information theory today represents the extreme points of the set of all possible communication schemes, as shown in the fanciful Figure 1.2 . The data compression minimum I ( X ; ) lies at one extreme of the set of communication ideas. All data compression schemes require description rates at least equal to this minimum. At the other extreme is the data transmission maximum I ( X ; Y ), known as the channel capacity . Thus, all modulation schemes and data compression schemes lie between these limits. FIGURE 1.2. Information theory as the extreme points of communication theory. Information theory also suggests means of achieving these ultimate limits of communication. However, these theoretically optimal communication schemes, beautiful as they are, may turn out to be computationally impractical. It is only because of the computational feasibility of simple modulation and demodulation schemes that we use them rather than the random coding and nearest-neighbor decoding rule suggested by Shannon’s proof of the channel capacity theorem. Progress in integrated circuits and code design has enabled us to reap some of the gains suggested by Shannon’s theory. Computational practicality was finally achieved by the advent of turbo codes. A good example of an application of the ideas of information theory is the use of error-correcting codes on compact discs and DVDs. Recent work on the communication aspects of information theory has concentrated on network information theory: the theory of the simultaneous rates of communication from many senders to many receivers in the presence of interference and noise. Some of the trade-offs of rates between senders and receivers are unexpected, and all have a certain mathematical simplicity. A unifying theory, however, remains to be found. Computer Science (Kolmogorov Complexity). Kolmogorov, Chaitin, and Solomonoff put forth the idea that the complexity of a string of data can be defined by the length of the shortest binary computer program for computing the string. Thus, the complexity is the minimal description length. This definition of complexity turns out to be universal, that is, computer independent, and is of fundamental importance. Thus, Kolmogorov complexity lays the foundation for the theory of descriptive complexity. Gratifyingly, the Kolmogorov complexity K is approximately equal to the Shannon entropy H if the sequence is drawn at random from a distribution that has entropy H . So the tie-in between information theory and Kolmogorov complexity is perfect. Indeed, we consider Kolmogorov complexity to be more fundamental than Shannon entropy. It is the ultimate data compression and leads to a logically consistent procedure for inference. There is a pleasing complementary relationship between algorithmic complexity and computational complexity. One can think about computational complexity (time complexity) and Kolmogorov complexity (program length or descriptive complexity) as two axes corresponding to program running time and program length. Kolmogorov complexity focuses on minimizing along the second axis, and computational complexity focuses on minimizing along the first axis. Little work has been done on the simultaneous minimization of the two. Physics (Thermodynamics). Statistical mechanics is the birthplace of entropy and the second law of thermodynamics. Entropy always increases. Among other things, the second law allows one to dismiss any claims to perpetual motion machines. We discuss the second law briefly in Chapter 4. Mathematics (Probability Theory and Statistics). The fundamental quantities of information theory—entropy, relative entropy, and mutual information—are defined as functionals of probability distributions. In turn, they characterize the behavior of long sequences of random variables and allow us to estimate the probabilities of rare events (large deviation theory) and to find the best error exponent in hypothesis tests. Philosophy of Science (Occam’s Razor). William of Occam said “Causes shall not be multiplied beyond necessity,” or to paraphrase it, “The simplest explanation is best.” Solomonoff and Chaitin argued persuasively that one gets a universally good prediction procedure if one takes a weighted combination of all programs that explain the data and observes what they print next. Moreover, this inference will work in many problems not handled by statistics. For example, this procedure will eventually predict the subsequent digits of π. When this procedure is applied to coin flips that come up heads with probability 0.7, this too will be inferred. When applied to the stock market, the procedure should essentially find all the “laws” of the stock market and extrapolate them optimally. In principle, such a procedure would have found Newton’s laws of physics. Of course, such inference is highly impractical, because weeding out all computer programs that fail to generate existing data will take impossibly long. We would predict what happens tomorrow a hundred years from now. Economics (Investment). Repeated investment in a stationary stock market results in an exponential growth of wealth. The growth rate of the wealth is a dual of the entropy rate of the stock market. The parallels between the theory of optimal investment in the stock market and information theory are striking. We develop the theory of investment to explore this duality. Computation vs. Communication. As we build larger computers out of smaller components, we encounter both a computation limit and a communication limit. Computation is communication limited and communication is computation limited. These become intertwined, and thus all of the developments in communication theory via information theory should have a direct impact on the theory of computation. 1.1 PREVIEW OF THE BOOK The initial questions treated by information theory lay in the areas of data compression and transmission. The answers are quantities such as entropy and mutual information, which are functions of the probability distributions that underlie the process of communication. A few definitions will aid the initial discussion. We repeat these definitions in Chapter 2. The entropy of a random variable X with a probability mass function p ( x ) is defined by (1.1) We use logarithms to base 2. The entropy will then be measured in bits. The entropy is a measure of the average uncertainty in the random variable. It is the number of bits on average required to describe the random variable. Example 1.1.1 Consider a random variable that has a uniform distribution over 32 outcomes. To identify an outcome, we need a label that takes on 32 different values. Thus, 5-bit strings suffice as labels. The entropy of this random variable is (1.2) which agrees with the number of bits needed to describe X . In this case, all the outcomes have representations of the same length. Now consider an example with nonuniform distribution. Example 1.1.2 Suppose that we have a horse race with eight horses taking part. Assume that the probabilities of winning for the eight horses are . We can calculate the entropy of the horse race as (1.3) Suppose that we wish to send a message indicating which horse won the race. One alternative is to send the index of the winning horse. This description requires 3 bits for any of the horses. But the win probabilities are not uniform. It therefore makes sense to use shorter descriptions for the more probable horses and longer descriptions for the less probable ones, so that we achieve a lower average description length. For example, we could use the following set of bit strings to represent the eight horses: 0, 10, 110, 1110, 111100, 111101, 111110, 111111. The average description length in this case is 2 bits, as opposed to 3 bits for the uniform code. Notice that the average description length in this case is equal to the entropy. In Chapter 5 we show that the entropy of a random variable is a lower bound on the average number of bits required to represent the random variable and also on the average number of questions needed to identify the variable in a game of “20 questions.” We also show how to construct representations that have an average length within 1 bit of the entropy. The concept of entropy in information theory is related to the concept of entropy in statistical mechanics. If we draw a sequence of n independent and identically distributed (i.i.d.) random variables, we will show that the probability of a “typical” sequence is about 2 − nH ( X ) and that there are about 2 nH ( x ) such typical sequences. This property [known as the asymptotic equipartition property (AEP)] is the basis of many of the proofs in information theory. We later present other problems for which entropy arises as a natural answer (e.g., the number of fair coin flips needed to generate a random variable). The notion of descriptive complexity of a random variable can be extended to define the descriptive complexity of a single string. The Kolmogorov complexity of a binary string is defined as the length of the shortest computer program that prints out the string. It will turn out that if the string is indeed random, the Kolmogorov complexity is close to the entropy. Kolmogorov complexity is a natural framework in which to consider problems of statistical inference and modeling and leads to a clearer understanding of Occam’s Razor : “The simplest explanation is best.” We describe some simple properties of Kolmogorov complexity in Chapter 1. Entropy is the uncertainty of a single random variable. We can define conditional entropy H ( X | Y ), which is the entropy of a random variable conditional on the knowledge of another random variable. The reduction in uncertainty due to another random variable is called the mutual information . For two random variables X and Y this reduction is the mutual information (1.4) The mutual information I ( X ; Y ) is a measure of the dependence between the two random variables. It is symmetric in X and Y and always nonnegative and is equal to zero if and only if X and Y are independent. A communication channel is a system in which the output depends probabilistically on its input. It is characterized by a probability transition matrix p ( y | x ) that determines the conditional distribution of the output given the input. For a communication channel with input X and output Y , we can define the capacity C by (1.5) Later we show that the capacity is the maximum rate at which we can send information over the channel and recover the information at the output with a vanishingly low probability of error. We illustrate this with a few examples. Example 1.1.3 ( Noiseless binary channel ) For this channel, the binary input is reproduced exactly at the output. This channel is illustrated in Figure 1.3 . Here, any transmitted bit is received without error. Hence, in each transmission, we can send 1 bit reliably to the receiver, and the capacity is 1 bit. We can also calculate the information capacity C = max I ( X ; Y ) = 1 bit. FIGURE 1.3. Noiseless binary channel. C = 1 bit. Example 1.1.4 ( Noisy four-symbol channel ) Consider the channel shown in Figure 1.4 . In this channel, each input letter is received either as the same letter with probability or as the next letter with probability . If we use all four input symbols, inspection of the output would not reveal with certainty which input symbol was sent. If, on the other hand, we use only two of the inputs (1 and 3, say), we can tell immediately from the output which input symbol was sent. This channel then acts like the noiseless channel of Example 1.1.3, and we can send 1 bit per transmission over this channel with no errors. We can calculate the channel capacity C = max I ( X ; Y ) in this case, and it is equal to 1 bit per transmission, in agreement with the analysis above. FIGURE 1.4. Noisy channel. In general, communication channels do not have the simple structure of this example, so we cannot always identify a subset of the inputs to send information without error. But if we consider a sequence of transmissions, all channels look like this example and we can then identify a subset of the input sequences (the codewords) that can be used to transmit information over the channel in such a way that the sets of possible output sequences associated with each of the codewords are approximately disjoint. We can then look at the output sequence and identify the input sequence with a vanishingly low probability of error. Example 1.1.5 ( Binary symmetric channel ) This is the basic example of a noisy communication system. The channel is illustrated in Figure 1.5 . FIGURE 1.5. Binary symmetric channel. The channel has a binary input, and its output is equal to the input with probability 1 − p . With probability p , on the other hand, a 0 is received as a 1, and vice versa. In this case, the capacity of the channel can be calculated to be C = 1 + p log p + (1 − p ) log(1 − p ) bits per transmission. However, it is no longer obvious how one can achieve this capacity. If we use the channel many times, however, the channel begins to look like the noisy four-symbol channel of Example 1.1.4, and we can send information at a rate C bits per transmission with an arbitrarily low probability of error. The ultimate limit on the rate of communication of information over a channel is given by the channel capacity. The channel coding theorem shows that this limit can be achieved by using codes with a long block length. In practical communication systems, there are limitations on the complexity of the codes that we can use, and therefore we may not be able to achieve capacity. Mutual information turns out to be a special case of a more general quantity called relative entropy D ( p || q ), which is a measure of the “distance” between two probability mass functions p and q . It is defined as (1.6) Although relative entropy is not a true metric, it has some of the properties of a metric. In particular, it is always nonnegative and is zero if and only if p = q . Relative entropy arises as the exponent in the probability of error in a hypothesis test between distributions p and q . Relative entropy can be used to define a geometry for probability distributions that allows us to interpret many of the results of large deviation theory. There are a number of parallels between information theory and the theory of investment in a stock market. A stock market is defined by a random vector X whose elements are nonnegative numbers equal to the ratio of the price of a stock at the end of a day to the price at the beginning of the day. For a stock market with distribution F ( x ), we can define the doubling rate W as (1.7) The doubling rate is the maximum asymptotic exponent in the growth of wealth. The doubling rate has a number of properties that parallel the properties of entropy. We explore some of these properties in Chapter 16. The quantities H, I, C, D, K, W arise naturally in the following areas: Data compression . The entropy H of a random variable is a lower bound on the average length of the shortest description of the random variable. We can construct descriptions with average length within 1 bit of the entropy. If we relax the constraint of recovering the source perfectly, we can then ask what communication rates are required to describe the source up to distortion D ? And what channel capacities are sufficient to enable the transmission of this source over the channel and its reconstruction with distortion less than or equal to D ? This is the subject of rate distortion theory. When we try to formalize the notion of the shortest description for nonrandom objects, we are led to the definition of Kolmogorov complexity K . Later, we show that Kolmogorov complexity is universal and satisfies many of the intuitive requirements for the theory of shortest descriptions. Data transmission . We consider the problem of transmitting information so that the receiver can decode the message with a small probability of error. Essentially, we wish to find codewords (sequences of input symbols to a channel) that are mutually far apart in the sense that their noisy versions (available at the output of the channel) are distinguishable. This is equivalent to sphere packing in high-dimensional space. For any set of codewords it is possible to calculate the probability that the receiver will make an error (i.e., make an incorrect decision as to which codeword was sent). However, in most cases, this calculation is tedious. Using a randomly generated code, Shannon showed that one can send information at any rate below the capacity C of the channel with an arbitrarily low probability of error. The idea of a randomly generated code is very unusual. It provides the basis for a simple analysis of a very difficult problem. One of the key ideas in the proof is the concept of typical sequences. The capacity C is the logarithm of the number of distinguishable input signals. Network information theory . Each of the topics mentioned previously involves a single source or a single channel. What if one wishes to compress each of many sources and then put the compressed descriptions together into a joint reconstruction of the sources? This problem is solved by the Slepian–Wolf theorem. Or what if one has many senders sending information independently to a common receiver? What is the channel capacity of this channel? This is the multiple-access channel solved by Liao and Ahlswede. Or what if one has one sender and many receivers and wishes to communicate (perhaps different) information simultaneously to each of the receivers? This is the broadcast channel. Finally, what if one has an arbitrary number of senders and receivers in an environment of interference and noise. What is the capacity region of achievable rates from the various senders to the receivers? This is the general network information theory problem. All of the preceding problems fall into the general area of multiple-user or network information theory. Although hopes for a comprehensive theory for networks may be beyond current research techniques, there is still some hope that all the answers involve only elaborate forms of mutual information and relative entropy. Ergodic theory . The asymptotic equipartition theorem states that most sample n -sequences of an ergodic process have probability about 2 − nH and that there are about 2 nH such typical sequences. Hypothesis testing . The relative entropy D arises as the exponent in the probability of error in a hypothesis test between two distributions. It is a natural measure of distance between distributions. Statistical mechanics . The entropy H arises in statistical mechanics as a measure of uncertainty or disorganization in a physical system. Roughly speaking, the entropy is the logarithm of the number of ways in which the physical system can be configured. The second law of thermodynamics says that the entropy of a closed system cannot decrease. Later we provide some interpretations of the second law. Quantum mechanics . Here, von Neumann entropy S = tr( ρ ln ρ ) = ∑ i λ i log λ i plays the role of classical Shannon–Boltzmann entropy. H = ∑ i p i log p i . Quantum mechanical versions of data compression and channel capacity can then be found. Inference . We can use the notion of Kolmogorov complexity K to find the shortest description of the data and use that as a model to predict what comes next. A model that maximizes the uncertainty or entropy yields the maximum entropy approach to inference. Gambling and investment . The optimal exponent in the growth rate of wealth is given by the doubling rate W. For a horse race with uniform odds, the sum of the doubling rate W and the entropy H is constant. The increase in the doubling rate due to side information is equal to the mutual information I between a horse race and the side information. Similar results hold for investment in the stock market. Probability theory . The asymptotic equipartition property (AEP) shows that most sequences are typical in that they have a sample entropy close to H . So attention can be restricted to these approximately 2 nH typical sequences. In large deviation theory, the probability of a set is approximately 2 − nD , where D is the relative entropy distance between the closest element in the set and the true distribution. Complexity theory . The Kolmogorov complexity K is a measure of the descriptive complexity of an object. It is related to, but different from, computational complexity, which measures the time or space required for a computation. Information-theoretic quantities such as entropy and relative entropy arise again and again as the answers to the fundamental questions in communication and statistics. Before studying these questions, we shall study some of the properties of the answers. We begin in Chapter 2 with the definitions and basic properties of entropy, relative entropy, and mutual information.

Chapter 2: Entropy, Relative Entropy, and Mutual Information CHAPTER 2 ENTROPY, RELATIVE ENTROPY, AND MUTUAL INFORMATION In this chapter we introduce most of the basic definitions required for subsequent development of the theory. It is irresistible to play with their relationships and interpretations, taking faith in their later utility. After defining entropy and mutual information, we establish chain rules, the nonnegativity of mutual information, the data-processing inequality, and illustrate these definitions by examining sufficient statistics and Fano’s inequality. The concept of information is too broad to be captured completely by a single definition. However, for any probability distribution, we define a quantity called the entropy , which has many properties that agree with the intuitive notion of what a measure of information should be. This notion is extended to define mutual information , which is a measure of the amount of information one random variable contains about another. Entropy then becomes the self-information of a random variable. Mutual information is a special case of a more general quantity called relative entropy , which is a measure of the distance between two probability distributions. All these quantities are closely related and share a number of simple properties, some of which we derive in this chapter. In later chapters we show how these quantities arise as natural answers to a number of questions in communication, statistics, complexity, and gambling. That will be the ultimate test of the value of these definitions. 2.1 ENTROPY We first introduce the concept of entropy , which is a measure of the uncertainty of a random variable. Let X be a discrete random variable with alphabet X and probability mass function p ( x ) = Pr{ X = x }, x χ. We denote the probability mass function by p ( x ) rather than px ( x ), for convenience. Thus, p ( x ) and p ( y ) refer to two different random variables and are in fact different probability mass functions, px ( x ) and py ( y ), respectively. Definition The entropy H(X) of a discrete random variable X is defined by (2.1) We also write H ( p ) for the above quantity. The log is to the base 2 and entropy is expressed in bits. For example, the entropy of a fair coin toss is 1 bit. We will use the convention that 0 log 0 = 0, which is easily justified by continuity since x log x → 0 as x → 0. Adding terms of zero probability does not change the entropy. If the base of the logarithm is b , we denote the entropy as H b ( X ). If the base of the logarithm is e , the entropy is measured in vats . Unless otherwise specified, we will take all logarithms to base 2, and hence all the entropies will be measured in bits. Note that entropy is a functional of the distribution of X . It does not depend on the actual values taken by the random variable X , but only on the probabilities. We denote expectation by E . Thus, if X ~ p ( x ), the expected value of the random variable g ( X ) is written (2.2) or more simply as Eg ( X ) when the probability mass function is understood from the context. We shall take a peculiar interest in the eerily self-referential expectation of g ( X ) under p ( x ) when g ( X ) = log . Remark The entropy of X can also be interpreted as the expected value of the random variable log , where X is drawn according to probability mass function p ( x ). Thus, (2.3) This definition of entropy is related to the definition of entropy in thermodynamics; some of the connections are explored later. It is possible to derive the definition of entropy axiomatically by defining certain properties that the entropy of a random variable must satisfy. This approach is illustrated in Problem 2.46. We do not use the axiomatic approach to justify the definition of entropy; instead, we show that it arises as the answer to a number of natural questions, such as “What is the average length of the shortest description of the random variable?” First, we derive some immediate consequences of the definition. Lemma 2.1.1 H ( X ) ≥ O. Proof: 0 ≤ p ( x ) ≤ 1 implies that log ≥ 0. Lemma 2.1.2 H b ( X ) = (log b a ) H a ( X ). Proof: log b p = log b a log a p . The second property of entropy enables us to change the base of the logarithm in the definition. Entropy can be changed from one base to another by multiplying by the appropriate factor. Example 2.1.1 Let (2.4) Then (2.5) In particular, H ( X ) = 1 bit when p = . The graph of the function H (p) is shown in Figure 2.1 . The figure illustrates some of the basic properties of entropy: It is a concave function of the distribution and equals 0 when p = 0 or 1. This makes sense, because when p = 0 or 1, the variable is not random and there is no uncertainty. Similarly, the uncertainty is maximum when p = , which also corresponds to the maximum value of the entropy. FIGURE 2.1. H ( p ) vs. p . Example 2.1.2 Let (2.6) The entropy of X is (2.7) Suppose that we wish to determine the value of X with the minimum number of binary questions. An efficient first question is “Is X = a ?” This splits the probability in half. If the answer to the first question is no, the second question can be “Is X = b ?” The third question can be “Is X = c ?” The resulting expected number of binary questions required is 1.75. This turns out to be the minimum expected number of binary questions required to determine the value of X . In Chapter 5 we show that the minimum expected number of binary questions required to determine X lies between H ( X ) and H ( X ) + 1. 2.2 JOINT ENTROPY AND CONDITIONAL ENTROPY We defined the entropy of a single random variable in Section 2.1. We now extend the definition to a pair of random variables. There is nothing really new in this definition because ( X , Y ) can be considered to be a single vector-valued random variable. Definition The joint entropy H ( X , Y ) of a pair of discrete random variables ( X , Y ) with a joint distribution p ( x , y ) is defined as (2.8) which can also be expressed as (2.9) We also define the conditional entropy of a random variable given another as the expected value of the entropies of the conditional distributions, averaged over the conditioning random variable. Definition If ( X , Y ) ~ p ( x , y ), the conditional entropy H ( Y | X ) is defined as (2.10) (2.11) (2.12) (2.13) The naturalness of the definition of joint entropy and conditional entropy is exhibited by the fact that the entropy of a pair of random variables is the entropy of one plus the conditional entropy of the other. This is proved in the following theorem. Theorem 2.2.1 ( Chain rule ) (2.14) Proof (2.15) (2.16) (2.17) (2.18) (2.19) Equivalently, we can write (2.20) and take the expectation of both sides of the equation to obtain the theorem. Corollary (2.21) Proof: The proof follows along the same lines as the theorem. Example 2.2.1 Let ( X , Y ) have the following joint distribution: The marginal distribution of X is and the marginal distribution of Y is , and hence H ( X ) = bits and H ( Y ) = 2 bits. Also, (2.22) (2.23) (2.24) (2.25) Similarly, H ( Y | X ) = bits and H ( X , Y ) = bits. Remark Note that H ( Y | X ) ≠ H ( X | Y ). However, H ( X ) – H ( X | Y ) = H ( Y ) – H ( Y | X ), a property that we exploit later. 2.3 RELATIVE ENTROPY AND MUTUAL INFORMATION The entropy of a random variable is a measure of the uncertainty of the random variable; it is a measure of the amount of information required on the average to describe the random variable. In this section we introduce two related concepts: relative entropy and mutual information. The relative entropy is a measure of the distance between two distributions. In statistics, it arises as an expected logarithm of the likelihood ratio. The relative entropy D(p||q) is a measure of the inefficiency of assuming that the distribution is q when the true distribution is p . For example, if we knew the true distribution p of the random variable, we could construct a code with average description length H ( p ). If, instead, we used the code for a distribution q , we would need H ( p ) + D ( P||q ) bits on the average to describe the random variable. Definition The relative entropy or Kullback–Leibler distance between two probability mass functions p ( x ) and q ( x ) is defined as (2.26) (2.27) In the above definition, we use the convention that 0 log = 0 and the convention (based on continuity arguments) that 0 log = 0 and p log = ∞. Thus, if there is any symbol x χ such that p ( x ) > 0 and q ( x ) = 0, then D ( p || q ) = ∞. We will soon show that relative entropy is always nonnegative and is zero if and only if p = q . However, it is not a true distance between distributions since it is not symmetric and does not satisfy the triangle inequality. Nonetheless, it is often useful to think of relative entropy as a “distance” between distributions. We now introduce mutual information, which is a measure of the amount of information that one random variable contains about another random variable. It is the reduction in the uncertainty of one random variable due to the knowledge of the other. Definition Consider two random variables X and Y with a joint probability mass function p ( x , y ) and marginal probability mass functions p ( x ) and p ( y ). The mutual information I ( X ; Y ) is the relative entropy between the joint distribution and the product distribution p ( x ) p ( y ): (2.28) (2.29) (2.30) In Chapter 8 we generalize this definition to continuous random variables, and in (8.54) to general random variables that could be a mixture of discrete and continuous random variables. Example 2.3.1 Let χ = {0, 1} and consider two distributions p and q on χ Let p (0) = 1 – r , p (1) = r , and let q (0) = 1 − s, q (1) = s . Then (2.31) and (2.32) If r = s , then D ( p || q ) = D(q||p) = 0. If r = , s = , we can calculate (2.33) whereas (2.34) Note that D ( p || q ) ≠ D ( q || p ) in general. 2.4 RELATIONSHIP BETWEEN ENTROPY AND MUTUAL INFORMATION We can rewrite the definition of mutual information I (X; Y) as (2.35) (2.36) (2.37) (2.38) (2.39) Thus, the mutual information I ( X ; Y ) is the reduction in the uncertainty of X due to the knowledge of Y . By symmetry, it also follows that (2.40) Thus, X says as much about Y as Y says about X . Since H ( X , Y ) = H ( X ) + H ( Y | X ), as shown in Section 2.2, we have (2.41) Finally, we note that (2.42) Thus, the mutual information of a random variable with itself is the entropy of the random variable. This is the reason that entropy is sometimes referred to as self-information . Collecting these results, we have the following theorem. Theorem 2.4.1 ( Mutual information and entropy ) (2.43) (2.44) (2.45) (2.46) (2.47) The relationship between H ( X ), H ( Y ), H ( X , Y ), H ( X | Y ), H ( Y | X ), and I ( X ; Y ) is expressed in a Venn diagram ( Figure 2.2 ). Notice that the mutual information I ( X ; Y ) corresponds to the intersection of the information in X with the information in Y . FIGURE 2.2. Relationship between entropy and mutual information. Example 2.4.1 For the joint distribution of Example 2.2.1, it is easy to calculate the mutual information I ( X ; Y ) = H ( X ) − H ( X | Y ) = H ( Y ) − H ( Y | X ) = 0.375 bit. 2.5 CHAIN RULES FOR ENTROPY, RELATIVE ENTROPY, AND MUTUAL INFORMATION We now show that the entropy of a collection of random variables is the sum of the conditional entropies. Theorem 2.5.1 ( Chain rule for entropy ) Let X 1 , X 2 ,…, X n be drawn according to p ( x 1 , x 2 ,…, x n ). Then (2.48) Proof: By repeated application of the two-variable expansion rule for entropies, we have (2.49) (2.50) (2.51) (2.52) (2.53) Alternative Proof: We write and evaluate H ( X 1 , X 2 ,…, X n ) (2.54) (2.55) (2.56) (2.57) (2.58) (2.59) We now define the conditional mutual information as the reduction in the uncertainty of X due to knowledge of Y when Z is given. Definition The conditional mutual information of random variables X and Y given Z is defined by (2.60) (2.61) Mutual information also satisfies a chain rule. Theorem 2.5.2 ( Chain rule for information ) (2.62) Proof (2.63) (2.64) We define a conditional version of the relative entropy. Definition For joint probability mass functions p ( x , y ) and q ( x , y ), the conditional relative entropy D ( p ( y | x )|| q ( y | x )) is the average of the relative entropies between the conditional probability mass functions p ( y | x ) and q ( y | x ) averaged over the probability mass function p ( x ). More precisely, (2.65) (2.66) The notation for conditional relative entropy is not explicit since it omits mention of the distribution p ( x ) of the conditioning random variable. However, it is normally understood from the context. The relative entropy between two joint distributions on a pair of random variables can be expanded as the sum of a relative entropy and a conditional relative entropy. The chain rule for relative entropy is used in Section 4.4 to prove a version of the second law of thermodynamics. Theorem 2.5.3 ( Chain rule for relative entropy ) (2.67) Proof (2.68) (2.69) (2.70) (2.71) 2.6 JENSEN’S INEQUALITY AND ITS CONSEQUENCES In this section we prove some simple properties of the quantities defined earlier. We begin with the properties of convex functions. Definition A function f ( x ) is said to be convex over an interval ( a, b ) if for every x 1 , x 2 ∞ ( a, b ) and 0 ≤ λ ≤ 1, (2.72) A function f is said to be strictly convex if equality holds only if λ = 0 or λ = 1. Definition A function f is concave if – f is convex. A function is convex if it always lies below any chord. A function is concave if it always lies above any chord. Examples of convex functions include x 2 , | x |, e x , x log x (for x ≥ 0), and so on. Examples of concave functions include log x and for x ≥ 0. Figure 2.3 shows some examples of convex and concave functions. Note that linear functions ax + b are both convex and concave. Convexity underlies many of the basic properties of information-theoretic quantities such as entropy and mutual information. Before we prove some of these properties, we derive some simple results for convex functions. FIGURE 2.3. Examples of ( a ) convex and ( b ) concave functions. Theorem 2.6.1 If the function f has a second derivative that is nonnegative (positive) over an interval, the function is convex (strictly convex) over that interval . Proof: We use the Taylor series expansion of the function around x 0 : (2.73) where x * lies between x 0 and x . By hypothesis, f ″( x *) ≥ 0, and thus the last term is nonnegative for all x . We let x 0 = λ x 1 + (1 – λ) x 2 and take x = x 1 , to obtain (2.74) Similarly, taking x = x 2 , we obtain (2.75) Multiplying (2.74) by λ and (2.75) by 1 – λ and adding, we obtain (2.72) . The proof for strict convexity proceeds along the same lines. Theorem 2.6.1 allows us immediately to verify the strict convexity of x 2 , e x , and x log x for x ≥ 0, and the strict concavity of log x and for x ≥ 0. Let E denote expectation. Thus, in the discrete case and EX = f xf ( x ) dx in the continuous case. The next inequality is one of the most widely used in mathematics and one that underlies many of the basic results in information theory. Theorem 2.6.2 ( Jensen’s inequality ) If f is a convex function and X is a random variable , (2.76) Moreover, if f is strictly convex, the equality in (2.76) implies that X = EX with probability 1 (i.e., X is a constant ). Proof: We prove this for discrete distributions by induction on the number of mass points. The proof of conditions for equality when f is strictly convex is left to the reader. For a two-mass-point distribution, the inequality becomes (2.77) which follows directly from the definition of convex functions. Suppose that the theorem is true for distributions with k – 1 mass points. Then writing p ′ i = p i /(1 – p k ) for i = 1, 2,…, k – 1, we have (2.78) (2.79) (2.80) (2.81) where the first inequality follows from the induction hypothesis and the second follows from the definition of convexity. The proof can be extended to continuous distributions by continuity arguments. We now use these results to prove some of the properties of entropy and relative entropy. The following theorem is of fundamental importance. Theorem 2.6.3 ( Information inequality ) Let p ( x ), q ( x ), x χ, be two probability mass functions. Then (2.82) with equality if and only if p ( x ) = q ( x ) for all x . Proof: Let A = { x : p ( x ) > 0} be the support set of p ( x ). Then (2.83) (2.84) (2.85) (2.86) (2.87) (2.88) (2.89) where (2.85) follows from Jensen’s inequality. Since log t is a strictly concave function of t , we have equality in (2.85) if and only if q ( x )/ p ( x ) is constant everywhere [i.e., q ( x ) = cp ( x ) for all x ]. Thus, = . We have equality in (2.87) only if q ( x ) = 1, which implies that c = 1. Hence, we have D ( p || q ) = 0 if and only if p ( x ) = q ( x ) for all x . Corollary ( Nonnegativity of mutual information ) For any two random variables, X, Y , (2.90) with equality if and only if X and Y are independent . Proof: I ( X ; Y ) = D ( p ( x, y )|| p ( x ) p ( y )) ≥ 0, with equality if and only if p ( x , y ) = p ( x ) p ( y ) (i.e., X and Y are independent). Corollary (2.91) with equality if and only if p ( y | x ) = q ( y | x ) for all y and x such that p ( x ) > 0. Corollary (2.92) with equality if and only if X and Y are conditionally independent given Z . We now show that the uniform distribution over the range χ is the maximum entropy distribution over this range. It follows that any random variable with this range has an entropy no greater than log | χ |. Theorem 2.6.4 H ( X ) ≤ log | χ |, where | χ | denotes the number of elements in the range of X, with equality if and only X has a uniform distribution over χ Proof: Let u ( x ) = 1/| χ | be the uniform probability mass function over χ , and let p ( x ) be the probability mass function for X . Then (2.93) Hence by the nonnegativity of relative entropy, (2.94) Theorem 2.6.5 ( Conditioning reduces entropy )( Information can’t hurt ) (2.95) with equality if and only if X and Y are independent . Proof: 0 ≤ I ( X ; Y ) = H ( X ) – H ( X | Y ). Intuitively, the theorem says that knowing another random variable Y can only reduce the uncertainty in X . Note that this is true only on the average. Specifically, H ( X | Y = y ) may be greater than or less than or equal to H ( X ), but on the average H ( X | Y ) = ∑ y p ( y ) H ( X | Y = y ) ≤ H ( X ). For example, in a court case, specific new evidence might increase uncertainty, but on the average evidence decreases uncertainty. Example 2.6.1 Let ( X , Y ) have the following joint distribution: Then H ( X ) = H = 0.544 bit, H(X|Y = 1) = 0 bits, and H(X|Y = 2) = 1 bit. We calculate H ( X | Y ) = H(X|Y = 1) + H(X|Y = 2) = 0.25 bit. Thus, the uncertainty in X is increased if Y = 2 is observed and decreased if Y = 1 is observed, but uncertainty decreases on the average. Theorem 2.6.6 ( Independence bound on entropy ) Let X 1 , X 2 , X n be drawn according to p(x 1 , x 2 ,…, x n ). Then (2.96) with equality if and only if the X i are independent . Proof: By the chain rule for entropies, (2.97) (2.98) where the inequality follows directly from Theorem 2.6.5. We have equality if and only if X i is independent of X i −1 ,…, X 1 for all i (i.e., if and only if the X i ’s are independent). 2.7 LOG SUM INEQUALITY AND ITS APPLICATIONS We now prove a simple consequence of the concavity of the logarithm, which will be used to prove some concavity results for the entropy. Theorem 2.7.1 ( Log sum inequality ) For nonnegative numbers, a 1 , a 2 ,…, a n and b 1 , b 2 ,…, b n , (2.99) with equality if and only if = const . We again use the convention that 0 log 0 = 0, a log = ∞ if a > 0 and 0 log = 0. These follow easily from continuity. Proof: Assume without loss of generality that a i > 0 and b i > 0. The function f ( t ) = t log t is strictly convex, since f ″( t ) = 1/ t log e > 0 for all positive t . Hence by Jensen’s inequality, we have (2.100) for α i ≥ 0, ∑ i α i = 1. Setting and t i = we obtain (2.101) which is the log sum inequality. We now use the log sum inequality to prove various convexity results. We begin by reproving Theorem 2.6.3, which states that D ( p || q ) ≥ 0 with equality if and only if p ( x ) = q ( x ). By the log sum inequality, (2.102) (2.103) (2.104) with equality if and only if = c . Since both p and q are probability mass functions, c = 1, and hence we have D ( p || q ) = 0 if and only if p ( x ) = q ( x ) for all x . Theorem 2.7.2 ( Convexity of relative entropy ) D ( p || q ) is convex in the pair ( p , q ); that is, if ( p 1 , q 1 ) and ( p 2 , q 2 ) are two pairs of probability mass functions, then (2.105) for all 0 ≤ λ ≤ 1. Proof: We apply the log sum inequality to a term on the left-hand side of (2.105) : (2.106) Summing this over all x , we obtain the desired property. Theorem 2.7.3 ( Concavity of entropy ) H ( p ) is a concave function of p . Proof (2.107) where u is the uniform distribution on | χ | outcomes. The concavity of H then follows directly from the convexity of D . Alternative Proof: Let X 1 be a random variable with distribution p 1 , taking on values in a set A . Let X 2 be another random variable with distribution p 2 on the same set. Let (2.108) Let Z = X θ . Then the distribution of Z is λ p 1 + (1 – λ) p 2 . Now since conditioning reduces entropy, we have (2.109) or equivalently, (2.110) which proves the concavity of the entropy as a function of the distribution. One of the consequences of the concavity of entropy is that mixing two gases of equal entropy results in a gas with higher entropy. Theorem 2.7.4 Let ( X, Y ) ~ p ( x, y ) = p ( x ) p ( y | x ). The mutual information I ( X; Y ) is a concave function of p ( x ) for fixed p ( y | x ) and a convex function of p ( y | x ) for fixed p ( x ). Proof: To prove the first part, we expand the mutual information (2.111) If p ( y | x ) is fixed, then p ( y ) is a linear function of p ( x ). Hence H ( Y ), which is a concave function of p ( y ), is a concave function of p ( x ). The second term is a linear function of p ( x ). Hence, the difference is a concave function of p ( x ). To prove the second part, we fix p ( x ) and consider two different conditional distributions p 1 ( y | x ) and p 2 ( y | x ). The corresponding joint distributions are p 1 ( x , y ) = p ( x ) p 1 ( y | x ) and p 2 ( x , y ) = p ( x ) p 2 ( y | x ), and their respective marginals are p ( x ), p 1 ( y ) and p ( x ), p 2 ( y ). Consider a conditional distribution (2.112) which is a mixture of p1 ( y | x ) and p 2( y | x ) where 0 ≤ λ ≤ 1. The corresponding joint distribution is also a mixture of the corresponding joint distributions, (2.113) and the distribution of Y is also a mixture, (2.114) Hence if we let q λ( x, y ) = p ( x ) p λ ( y ) be the product of the marginal distributions, we have (2.115) Since the mutual information is the relative entropy between the joint distribution and the product of the marginals, (2.116) and relative entropy D ( p || q ) is a convex function of ( p, q ), it follows that the mutual information is a convex function of the conditional distribution. 2.8 DATA-PROCESSING INEQUALITY The data-processing inequality can be used to show that no clever manipulation of the data can improve the inferences that can be made from the data. Definition Random variables X, Y, Z are said to form a Markov chain in that order (denoted by X → Y → Z ) if the conditional distribution of Z depends only on Y and is conditionally independent of X . Specifically, X, Y , and Z form a Markov chain X → Y → Z if the joint probability mass function can be written as (2.117) Some simple consequences are as follows: X → Y → Z if and only if X and Z are conditionally independent given Y . Markovity implies conditional independence because (2.118) This is the characterization of Markov chains that can be extended to define Markov fields, which are n -dimensional random processes in which the interior and exterior are independent given the values on the boundary. X → Y → Z implies that Z → Y → X . Thus, the condition is sometimes written X Y Z . If Z = f ( Y ), then X → Y → Z . We can now prove an important and useful theorem demonstrating that no processing of Y , deterministic or random, can increase the information that Y contains about X . Theorem 2.8.1 ( Data-processing inequality ) If X → Y → Z , then I ( X ; Y ) ≥ I ( X ; Z ). Proof: By the chain rule, we can expand mutual information in two different ways: (2.119) (2.120) Since X and Z are conditionally independent given Y , we have I ( X ; Z | Y ) = 0. Since I ( X ; Y | Z ) ≥ 0, we have (2.121) We have equality if and only if I ( X ; Y | Z ) = 0 (i.e., X → Z → Y forms a Markov chain). Similarly, one can prove that I ( Y ; Z ) ≥ I ( X; Z ). Corollary In particular, if Z = g ( Y ), we have I ( X; Y ) ≥ I ( X; g ( Y )). Proof: X → Y → g ( Y ) forms a Markov chain. Thus functions of the data Y cannot increase the information about X . Corollary If X → Y → Z, then I ( X; Y | Z ) ≤ I ( X; Y ). Proof: We note in (2.119) and (2.120) that I(X; Z|Y ) = 0, by Markovity, and I ( X; Z ) ≥ 0. Thus, (2.122) Thus, the dependence of X and Y is decreased (or remains unchanged) by the observation of a “downstream” random variable Z . Note that it is also possible that I ( X; Y|Z ) > I ( X; Y ) when X, Y , and Z do not form a Markov chain. For example, let X and Y be independent fair binary random variables, and let Z = X + Y . Then I ( X; Y ) = 0, but I ( X; Y|Z ) = H ( X|Z ) − H ( X | Y, Z ) = H ( X | Z ) = P ( Z = 1) H ( X | Z = 1) = bit. 2.9 SUFFICIENT STATISTICS This section is a sidelight showing the power of the data-processing inequality in clarifying an important idea in statistics. Suppose that we have a family of probability mass functions { f θ( x )} indexed by θ, and let X be a sample from a distribution in this family. Let T ( X ) be any statistic (function of the sample) like the sample mean or sample variance. Then θ → X → T ( X ), and by the data-processing inequality, we have (2.123) for any distribution on θ. However, if equality holds, no information is lost. A statistic T ( X ) is called sufficient for θ if it contains all the information in X about θ. Definition A function T ( X ) is said to be a sufficient statistic relative to the family { f θ( x )} if X is independent of θ given T ( X ) for any distribution on θ[i.e., θ → T ( X ) → X forms a Markov chain]. This is the same as the condition for equality in the data-processing inequality, (2.124) for all distributions on θ. Hence sufficient statistics preserve mutual information and conversely. Here are some examples of sufficient statistics: 1. Let X 1 , X 2 ,…, X n , X i {0, 1}, be an independent and identically distributed (i.i.d.) sequence of coin tosses of a coin with unknown parameter θ = Pr( X i = 1). Given n , the number of 1’s is a sufficient statistic for θ. Here T (X 1 , X 2 ,…, X n ) = . In fact, we can show that given T , all sequences having that many 1’s are equally likely and independent of the parameter θ. Specifically, (2.125) Thus, θ → ∑ X i → ( X 1 , X 2 ,…, X n ) forms a Markov chain, and T is a sufficient statistic for θ. The next two examples involve probability densities instead of probability mass functions, but the theory still applies. We define entropy and mutual information for continuous random variables in Chapter 8. 2. If X is normally distributed with mean θ and variance 1; that is, if (2.126) and X 1 , X 2 ,…, X n are drawn independently according to this distribution, a sufficient statistic for θ is the sample mean . It can be verified that the conditional distribution of X 1 , X 2 ,…, X n , conditioned on and n does not depend on θ. 3. If f θ = Uniform (θ, θ + 1), a sufficient statistic for θ is (2.127) The proof of this is slightly more complicated, but again one can show that the distribution of the data is independent of the parameter given the statistic T . The minimal sufficient statistic is a sufficient statistic that is a function of all other sufficient statistics. Definition A statistic T ( X ) is a minimal sufficient statistic relative to { f θ( x )} if it is a function of every other sufficient statistic U . Interpreting this in terms of the data-processing inequality, this implies that (2.128) Hence, a minimal sufficient statistic maximally compresses the information about θ in the sample. Other sufficient statistics may contain additional irrelevant information. For example, for a normal distribution with mean θ, the pair of functions giving the mean of all odd samples and the mean of all even samples is a sufficient statistic, but not a minimal sufficient statistic. In the preceding examples, the sufficient statistics are also minimal. 2.10 FANO’S INEQUALITY Suppose that we know a random variable Y and we wish to guess the value of a correlated random variable X . Fano’s inequality relates the probability of error in guessing the random variable X to its conditional entropy H ( X | Y ). It will be crucial in proving the converse to Shannon’s channel capacity theorem in Chapter 7. From Problem 2.5 we know that the conditional entropy of a random variable X given another random variable Y is zero if and only if X is a function of Y . Hence we can estimate X from Y with zero probability of error if and only if H(X|Y ) = 0. Extending this argument, we expect to be able to estimate X with a low probability of error only if the conditional entropy H ( X|Y ) is small. Fano’s inequality quantifies this idea. Suppose that we wish to estimate a random variable X with a distribution p (x ). We observe a random variable Y that is related to X by the conditional distribution p ( y | x ). From Y , we calculate a function g(Y ) = , where is an estimate of X and takes on values in . We will not restrict the alphabet to be equal to , and we will also allow the function g(Y ) to be random. We wish to bound the probability that ≠ X . We observe that X → Y → forms a Markov chain. Define the probability of error (2.129) Theorem 2.10.1 ( Fano’s Inequality) For any estimator such that X → Y → , with P e = Pr( X ≠ ), we have (2.130) This inequality can be weakened to (2.131) or (2.132) Remark Note from (2.130) that P e = 0 implies that H ( X | Y ) = 0, as intuition suggests. Proof: We first ignore the role of Y and prove the first inequality in (2.130) . We will then use the data-processing inequality to prove the more traditional form of Fano’s inequality, given by the second inequality in (2.130) . Define an error random variable, (2.133) Then, using the chain rule for entropies to expand H(E, X| ) in two different ways, we have (2.134) (2.135) Since conditioning reduces entropy, H(E| ) ≤ H(E ) = H(P e ). Now since E is a function of X and , the conditional entropy H(E|X, ) is equal to 0. Also, since E is a binary-valued random variable, H(E) = H(P e ). The remaining term, H(X|E, ) can be bounded as follows: (2.136) since given E = 0, X = , and given E = 1, we can upper bound the conditional entropy by the log of the number of possible outcomes. Combining these results, we obtain (2.137) By the data-processing inequality, we have I (X; ) ≤ I ( X ; Y ) since X → Y → is a Markov chain, and therefore H(X|X ) ≥ H ( X | Y ). Thus, we have (2.138) Corollary For any two random variables X and Y, let p = Pr( X ≠ Y ). (2.139) Proof: Let = Y in Fano’s inequality. For, any two random variables X and Y , if the estimator g(Y ) takes values in the set χ , we can strengthen the inequality slightly by replacing log | χ | with log(| χ | – 1). Corollary Let P e = Pr( X ≠ ), and let : y → χ ; then (2.140) Proof: The proof of the theorem goes through without change, except that (2.141) (2.142) since given E = 0, X = , and given E = 1, the range of possible X outcomes is | χ | – 1, we can upper bound the conditional entropy by the log(| χ | – 1), the logarithm of the number of possible outcomes. Substituting this provides us with the stronger inequality. Remark Suppose that there is no knowledge of Y . Thus, X must be guessed without any information. Let X {1, 2,…, m } and p 1 ≥ p 2 ≥ … ≥ p m . Then the best guess of X is = 1 and the resulting probability of error is P e = 1 – p 1 . Fano’s inequality becomes (2.143) The probability mass function (2.144) achieves this bound with equality. Thus, Fano’s inequality is sharp. While we are at it, let us introduce a new inequality relating probability of error and entropy. Let X and X′ by two independent identically distributed random variables with entropy H ( X ). The probability at X = X′ is given by (2.145) We have the following inequality: Lemma 2.10.1 If X and X′ are i.i.d. with entropy H(X ), (2.146) with equality if and only if X has a uniform distribution . Proof: Suppose that X ~ p ( x ). By Jensen’s inequality, we have (2.147) which implies that (2.148) Corollary Let X, X’ be independent with X ~ p(x), X’ ~ r(x), x, x’ χ Then (2.149) (2.150) Proof: We have (2.151) (2.152) (2.153) (2.154) (2.155) where the inequality follows from Jensen’s inequality and the convexity of the function f ( y ) = 2 Y . The following telegraphic summary omits qualifying conditions. SUMMARY Definition The entropy H (X ) of a discrete random variable X is defined by (2.156) Properties of H 1. H ( X ) ≥ 0. 2. H b (X ) = (log b a ) H a (X ). 3. (Conditioning reduces entropy) For any two random variables, X and Y , we have (2.157) with equality if and only if X and Y are independent. 4. H ( X 1 , X 2 ,…, X n ) , with equality if and only if the X i , are independent. 5. H ( X ) ≤ log | χ |, with equality if and only if X is distributed uniformly over χ . 6. H (p ) is concave in p . Definition The relative entropy D(p || q ) of the probability mass function p with respect to the probability mass function q is defined by (2.158) Definition The mutual information between two random variables X and Y is defined as (2.159) Alternative expressions (2.160) (2.161) (2.162) (2.163) (2.164) Properties of D and I 1. I(X; Y) = H(X) – H(X|Y) = H(Y) – H(Y|X) = H (X) + H(Y) – H (H, Y ). 2. D (p || q ) ≥ 0 with equality if and only if p ( x ) = q ( x ), for all x χ . 3. I (X; Y) = D (p(x, y)||p(x) p (y ))) ≥ 0, with equality if and only if p ( x , y ) = p (x) p (y ) (i.e., X and Y are independent). 4. If | χ | = m , and u is the uniform distribution over χ , then D(p || u ) = log m – H ( p ). 5. D ( p || q ) is convex in the pair ( p, q ). Chain rules Entropy: H (X 1 , X 2 ,…, X n ) = H (X i |X i−1 ,…, X 1 ). Mutual information: Relative entropy: Jensen’s inequality. If f is a convex function, then Ef ( X ) ≥ f ( EX ). Log sum inequality . For n positive numbers, a 1 , a 2 ,…, a n and b 1 , b 2 ,…, b n , (2.165) with equality if and only if = constant. Data-processing inequality. If X → Y → Z forms a Markov chain, I(X; Y ) ≥ I (X; Z ). Sufficient statistic. T (X ) is sufficient relative to { f θ ( x )} if and only if I(θ; X) = I (θ T (X) ) for all distributions on θ. Fano’s inequality. Let P e = Pr{ (Y ) ≠ X }. Then (2.166) Inequality. If X and X′ are independent and identically distributed, then (2.167) PROBLEMS 2.1 Coin flips . A fair coin is flipped until the first head occurs. Let X denote the number of flips required. (a) Find the entropy H ( X ) in bits. The following expressions may be useful: (b) A random variable X is drawn according to this distribution. Find an “efficient” sequence of yes–no questions of the form, “Is X contained in the set 5?” Compare H ( X ) to the expected number of questions required to determine X . 2.2 Entropy of functions . Let X be a random variable taking on a finite number of values. What is the (general) inequality relationship of H ( X ) and H ( Y ) if (a) Y = 2 X ? (b) Y = cos X ? 2.3 Minimum entropy . What is the minimum value of H ( p 1 ,…, p n ) = H ( p ) as p ranges over the set of n -dimensional probability vectors? Find all p ’s that achieve this minimum. 2.4 Entropy of functions of a random variable . Let X be a discrete random variable. Show that the entropy of a function of X is less than or equal to the entropy of X by justifying the following steps: (2.168) (2.169) (2.170) (2.171) Thus, H ( g ( X )) ≤ H ( X ). 2.5 Zero conditional entropy . Show that if H ( Y | X ) = 0, then Y is a function of X [i.e., for all x with p ( x ) > 0, there is only one possible value of y with p ( x , y ) > 0]. 2.6 Conditional mutual information vs. unconditional mutual information . Give examples of joint random variables X , Y , and Z such that (a) I(X; Y | Z ) < I(X; Y ). (b) I(X, Y | Z ) > I ( X ; Y ). 2.7 Coin weighing . Suppose that one has n coins, among which there may or may not be one counterfeit coin. If there is a counterfeit coin, it may be either heavier or lighter than the other coins. The coins are to be weighed by a balance. (a) Find an upper bound on the number of coins n so that k weighings will find the counterfeit coin (if any) and correctly declare it to be heavier or lighter. (b) (Difficult) What is the coin-weighing strategy for k = 3 weighings and 12 coins? 2.8 Drawing with and without replacement . An urn contains r red, w white, and b black balls. Which has higher entropy, drawing k ≥ 2 balls from the urn with replacement or without replacement? Set it up and show why. (There is both a difficult way and a relatively simple way to do this.) 2.9 Metric . A function ρ (x, y ) is a metric if for all x, y , ρ ( x, y ) ≥ 0. ρ ( x, y ) = ρ ( y, x ). ρ ( x, y ) = 0 if and only if x = y . ρ ( x, Y ) + ρ ( y, z ) ≥ ρ ( x, z ). (a) Show that ρ ( X, Y ) = H (X|Y ) + H ( Y | X ) satisfies the first, second, and fourth properties above. If we say that X = Y if there is a one-to-one function mapping from X to Y , the third property is also satisfied, and ρ ( X, Y ) is a metric. (b) Verify that ρ ( X, Y ) can also be expressed as (2.172) (2.173) (2.174) 2.10 Entropy of a disjoint mixture . Let X 1 and X 2 be discrete random variables drawn according to probability mass functions p 1 (·) and p 2 (·) over the respective alphabets χ 1 = {1, 2,…, m } and χ 2 = { m + 1,…, n }. Let (a) Find H ( X ) in terms of H (X 1 ), H (X 2 ), and α. (b) Maximize over α to show that 2 H ( X ) ≤ 2 H (X 1 ) + 2 H (X 2 ) and interpret using the notion that 2 H ( X ) is the effective alphabet size. 2.11 Measure of correlation . Let X 1 and X 2 be identically distributed but not necessarily independent. Let (a) Show that . (b) Show that 0 ≤ ρ ≤ 1. (c) When is ρ = 0? (d) When is ρ = 1? 2.12 Example of joint entropy . Let p ( x , y ) be given by Find: (a) H(X), H(Y ). (b) H(X | Y), H(Y | X ). (c) H ( X , Y ). (d) H (Y) – H (Y | X ). (e) I (X; Y ). (f) Draw a Venn diagram for the quantities in parts (a) through (e). 2.13 Inequality . Show that In x ≥ 1 – for x > 0. 2.14 Entropy of a sum . Let X and Y be random variables that take on values x 1 , x 2 ,…, x r and y 1 , y 2 , …, y s , respectively. Let Z = X + Y . (a) Show that H(Z|X) = H(Y|X ). Argue that if X, Y are independent, then H(Y) ≤ H(Z ) and H (X) ≤ H(Z ). Thus, the addition of independent random variables adds uncertainty. (b) Give an example of (necessarily dependent) random variables in which H ( X ) > H(Z ) and H ( Y ) > H(Z ). (c) Under what conditions does H(Z ) = H ( X ) + H (Y)? 2.15 Data processing . Let X 1 → X 2 → X 3 → ···→ X n form a Markov chain in this order; that is, let Reduce I (X 1 ; X 2 ,…, X n ) to its simplest form. 2.16 Bottleneck . Suppose that a (nonstationary) Markov chain starts in one of n states, necks down to k < n states, and then fans back to m > k states. Thus, X 1 → X 2 → X 3 , that is, P(x 1 , x 2 , x 3 ) = P(x 1 )p(x 2 |x 1 )p(x 3 |x 2 ), for all x 1 {1, 2, ···, n }, x 2 {1, 2,…, k }, x 3 {1, 2,···, m }. (a) Show that the dependence of X 1 and X 3 is limited by the bottleneck by proving that I (X 1 ; X 3 ) ≤ log k . (b) Evaluate I (X 1 ; X 3 ) for k = 1, and conclude that no dependence can survive such a bottleneck. 2.17 Pure randomness and bent coins . Let X 1 , X 2 ,…, X n denote the outcomes of independent flips of a bent coin. Thus, Pr { X i = 1} = p , Pr {X i = 0} = 1 − p , where p is unknown. We wish to obtain a sequence Z 1 , Z 2 ,…, Z K of fair coin flips from X 1 , X 2 ,…, X n . Toward this end, let f : χ n → {0, 1}* (where {0, 1}* = {Λ, 0, 1, 00, 01, …} is the set of all finite-length binary sequences) be a mapping f ( X 1 , X 2 , … X n ) = ( Z 1 , Z 2 ,…, Z K ), where Z i ~ Bernoulli ( ), and K may depend on ( X 1 ,…, X n ). In order that the sequence Z 1 , Z 2 , … appear to be fair coin flips, the map f from bent coin flips to fair flips must have the property that all 2 k sequences ( Z 1 , Z 2 ,…, Z k ) of a given length k have equal probability (possibly 0), for k = 1, 2, …. For example, for n = 2, the map f (01) = 0, f (10) = 1, f (00) = f (11) = Λ (the null string) has the property that Pr{ Z 1 = 1| K = 1} = Pr{ Z 1 = 0| K = 1} = . Give reasons for the following inequalities: Thus, no more than nH(p ) fair coin tosses can be derived from ( X 1 ,…, X n ), on the average. Exhibit a good map f on sequences of length 4. 2.18 World Series . The World Series is a seven-game series that terminates as soon as either team wins four games. Let X be the random variable that represents the outcome of a World Series between teams A and B; possible values of X are AAAA, BABABAB, and BBBAAAA. Let Y be the number of games played, which ranges from 4 to 7. Assuming that A and B are equally matched and that the games are independent, calculate H ( X ), H ( Y ), H ( Y | X ), and H ( X | Y ). 2.19 Infinite entropy . This problem shows that the entropy of a discrete random variable can be infinite. Let A = . [It is easy to show that A is finite by bounding the infinite sum by the integral of ( x log 2 x ) −1 .] Show that the integer-valued random variable X defined by Pr( X = n ) = ( An log 2 n ) −1 for n = 2, 3,…, has H ( X ) = +∞. 2.20 Run-length coding . Let X 1 , X 2 ,…, X n be (possibly dependent) binary random variables. Suppose that one calculates the run lengths R = ( R 1 , R 2 , …) of this sequence (in order as they occur). For example, the sequence X = 0001100100 yields run lengths R = (3, 2, 2, 1, 2). Compare H (X 1 , X 2 …, X n ), H ( R ), and H ( X n , R ). Show all equalities and inequalities, and bound all the differences. 2.21 Markov’s inequality for probabilities . Let p ( x ) be a probability mass function. Prove, for all d ≥ 0, that (2.175) 2.22 Logical order of ideas . Ideas have been developed in order of need and then generalized if necessary. Reorder the following ideas, strongest first, implications following: (a) Chain rule for I (X 1 ,…, X n ; Y ), chain rule for D(p(x i ,…, x n )|| q(x 1 , x 2 ,…, x n )), and chain rule for H(X 1 , X 2 ,…, X n ). (b) D (f ||g ) ≥ 0, Jensen’s inequality, I (X; Y ) ≥ 0. 2.23 Conditional mutual information . Consider a sequence of n binary random variables X 1 , X 2 ,…, X n . Each sequence with an even number of 1’s has probability 2 −( n −1) , and each sequence with an odd number of 1’s has probability 0. Find the mutual informations 2.24 Average entropy . Let H ( p ) = – p log 2 p – (1 – p ) log 2 (1 – p ) be the binary entropy function. (a) Evaluate H ( ) using the fact that log 2 3 ≈ 1.584. ( Hint: You may wish to consider an experiment with four equally likely outcomes, one of which is more interesting than the others.) (b) Calculate the average entropy H ( p ) when the probability p is chosen uniformly in the range 0 ≤ p ≤ 1. (c) ( Optional ) Calculate the average entropy H(p 1 , p 2 , p 3 ), where ( p 1 , p 2 , p 3 ) is a uniformly distributed probability vector. Generalize to dimension n . 2.25 Venn diagrams . There isn’t really a notion of mutual information common to three random variables. Here is one attempt at a definition: Using Venn diagrams, we can see that the mutual information common to three random variables X, Y , and Z can be defined by This quantity is symmetric in X , Y , and Z , despite the preceding asymmetric definition. Unfortunately, I (X; Y; Z ) is not necessarily nonnegative. Find X, Y , and Z such that I (X; Y; Z ) < 0, and prove the following two identities: (a) I (X; Y; Z) = H (X, Y, Z) – H (X) – H(Y) – H(Z) + I (X; Y) + I (Y; Z) + I (Z; X ). (b) I (X; Y; Z) = H (X, Y, Z) – H (X, Y) – H (Y, Z) – H (Z, X) + H (X) + H (Y) + H (Z ). The first identity can be understood using the Venn diagram analogy for entropy and mutual information. The second identity follows easily from the first. 2.26 Another proof of nonnegativity of relative entropy . In view of the fundamental nature of the result D(p||q ) ≥ 0, we will give another proof. (a) Show that In x ≤ x – 1 for 0 < x < ∞. (b) Justify the following steps: (2.176) (2.177) (2.178) (c) What are the conditions for equality? 2.27 Grouping rule for entropy . Let p = ( p 1 , p 2 , …., p m ) be a probability distribution on m elements (i.e., p i ≥ 0 and p i = 1). Define a new distribution q on m – 1 elements as q 1 = p 1 , q 2 = p 2 ,…, qm −2 = Pm −2, and q m−1 = p m−1 + p m [i.e., the distribution q is the same as p on {1, 2,…, m − 2}, and the probability of the last element in q is the sum of the last two probabilities of p ]. Show that (2.179) 2.28 Mixing increases entropy . Show that the entropy of the probability distribution, ( p 1 ,…, p i ,…, p j ,…, p m ), is less than the entropy of the distribution . Show that in general any transfer of probability that makes the distribution more uniform increases the entropy. 2.29 Inequalities . Let X , Y , and Z be joint random variables. Prove the following inequalities and find conditions for equality. (a) H (X, Y|Z ) ≥ H(X|Z ). (b) I (X, Y; Z ) ≥ I (X; Z ). (c) H (X, Y, Z) – H (X, Y) ≤ H (X, Z) – H(X ). (d) I (X; Z|Y) ≥ I (Z; Y|X) – I(Z; Y) + I (X; Z ). 2.30 Maximum entropy . Find the probability mass function p ( x ) that maximizes the entropy H ( X ) of a nonnegative integer-valued random variable X subject to the constraint for a fixed value A > 0. Evaluate this maximum H ( X ). 2.31 Conditional entropy . Under what conditions does H(X|g(Y)) = H(X|Y )? 2.32 Fano . We are given the following joint distribution on ( X, Y ): Let (Y ) be an estimator for X (based on Y ) and let P e = Pr{ (Y ) ≠ X }. (a) Find the minimum probability of error estimator (Y ) and the associated P e . (b) Evaluate Fano’s inequality for this problem and compare. 2.33 Fano’s inequality . Let Pr( X = i ) = p i , i = 1, 2,…, m , and let p 1 ≥ p 2 ≥ p 3 ≥ … p m . The minimal probability of error predictor of X is = 1, with resulting probability of error P e = 1 – p 1 . Maximize H(p) subject to the constraint 1 – p 1 = P e to find a bound on P e in terms of H . This is Fano’s inequality in the absence of conditioning. 2.34 Entropy of initial conditions . Prove that H (X 0 |X n ) is nondecreasing with n for any Markov chain. 2.35 Relative entropy is not symmetric . Let the random variable X have three possible outcomes { a, b, c }. Consider two distributions on this random variable: Calculate H (p), H (q), D(p||q ), and D(q||p ). Verify that in this case, D(p||q ) ≠ D(q||p ). 2.36 Symmetric relative entropy . Although, as Problem 2.35 shows, D(p||q) ≠ (q||p ) in general, there could be distributions for which equality holds. Give an example of two distributions p and q on a binary alphabet such that D(p||q) = D(q||p ) (other than the trivial case p = q ). 2.37 Relative entropy . Let X, Y, Z be three random variables with a joint probability mass function p(x, y, z ). The relative entropy between the joint distribution and the product of the marginals is (2.180) Expand this in terms of entropies. When is this quantity zero? 2.38 The value of a question . Let X ~ p ( x ), x = 1, 2,…, m . We are given a set S {1, 2,…, m }. We ask whether X S and receive the answer Suppose that Pr{ X S } = α. Find the decrease in uncertainty H(X) – H(X|Y ). Apparently, any set S with a given α is as good as any other. 2.39 Entropy and pairwise independence . Let X, Y, Z be three binary Bernoulli(1/2) random variables that are pairwise independent; that is, I(X; Y ) = I(X; Z ) = I(Y; Z ) = 0. (a) Under this constraint, what is the minimum value for H(X, Y, Z )? (b) Give an example achieving this minimum. 2.40 Discrete entropies . Let X and Y be two independent integer-valued random variables. Let X be uniformly distributed over {1, 2,…, 8}, and let Pr{ Y = k } = 2 -k , k = 1, 2, 3, …. (a) Find H ( X ). (b) Find H ( Y ). (c) Find H(X + Y, X − Y ). 2.41 Random questions . One wishes to identify a random object X ~ p ( x ). A question Q ~ r(q ) is asked at random according to r(q ). This results in a deterministic answer A = A ( x, q ) { a 1 , a 2 , …}. Suppose that X and Q are independent. Then I ( X; Q, A ) is the uncertainty in X removed by the question-answer ( Q, A ). (a) Show that I ( X; Q, A ) = H ( A | Q ). Interpret. (b) Now suppose that two i.i.d. questions Q 1 , Q 2 , ~ r(q ) are asked, eliciting answers A 1 and A 2 . Show that two questions are less valuable than twice a single question in the sense that I(X; Q 1 , A 1 , Q 2 , A 2 ) ≤ 2I(X; Q 1 , A 1 ). 2.42 Inequalities . Which of the following inequalities are generally ≥, =, ≤? Label each with ≥, =, or ≤. (a) H(5 X ) vs. H ( X ) (b) I (g(X); Y ) vs. I ( X ; Y ) (c) ( X 0 |X −1 ) vs. H(X 0 |X −1 , X 1 ) (d) H(X, Y)/(H(X ) + H(Y) ) vs. 1 2.43 Mutual information of heads and tails (a) Consider a fair coin flip. What is the mutual information between the top and bottom sides of the coin? (b) A six-sided fair die is rolled. What is the mutual information between the top side and the front face (the side most facing you)? 2.44 Pure randomness , We wish to use a three-sided coin to generate a fair coin toss. Let the coin X have probability mass function where p A , p B , p C are unknown. (a) How would you use two independent flips X 1 , X 2 to generate (if possible) a Bernoulli( ) random variable Z ? (b) What is the resulting maximum expected number of fair bits generated? 2.45 Finite entropy . Show that for a discrete random variable X {1, 2, …}, if E log X < ∞, then H ( X ) < ∞. 2.46 Axiomatic definition of entropy (Difficult ). If we assume certain axioms for our measure of information, we will be forced to use a logarithmic measure such as entropy. Shannon used this to justify his initial definition of entropy. In this book we rely more on the other properties of entropy rather than its axiomatic derivation to justify its use. The following problem is considerably more difficult than the other problems in this section. If a sequence of symmetric functions H m (p 1 , p 2 , …, p m ) satisfies the following properties: Normalization: , Continuity: H 2 ( p , 1 – p ) is a continuous function of p , Grouping: H m (p 1 , p 2 , …, p m ) = H m −1 ( p 1 + p 2 , p 3 , …, p m ) + ( p 1 + p 2 ) H 2 , prove that H m , must be of the form (2.181) There are various other axiomatic formulations which result in the same definition of entropy. See, for example, the book by Csiszár and Körner [149]. 2.47 Entropy of a missorted file . A deck of n cards in order 1, 2,…, n is provided. One card is removed at random, then replaced at random. What is the entropy of the resulting deck? 2.48 Sequence length . How much information does the length of a sequence give about the content of a sequence? Suppose that we consider a Bernoulli ( ) process { X i }. Stop the process when the first 1 appears. Let N designate this stopping time. Thus, X n is an element of the set of all finite-length binary sequences {0, 1}* = {0, 1, 00, 01, 10, 11, 000, … }. (a) Find I (N; X N ). (b) Find H(X N |N ). (c) Find H(X N ). Let’s now consider a different stopping time. For this part, again assume that X i ~ Bernoulli( ) but stop at time N = 6, with probability and stop at time N = 12 with probability . Let this stopping time be independent of the sequence X 1 X 2 … X 12 . (d) Find I (N; X N ). (e) Find H(X N |N ). (f) Find H(X N ). HISTORICAL NOTES The concept of entropy was introduced in thermodynamics, where it was used to provide a statement of the second law of thermodynamics. Later, statistical mechanics provided a connection between thermodynamic entropy and the logarithm of the number of microstates in a macrostate of the system. This work was the crowning achievement of Boltzmann, who had the equation S = k In W inscribed as the epitaph on his gravestone [361]. In the 1930s, Hartley introduced a logarithmic measure of information for communication. His measure was essentially the logarithm of the alphabet size. Shannon [472] was the first to define entropy and mutual information as defined in this chapter. Relative entropy was first defined by Kullback and Leibler [339]. It is known under a variety of names, including the Kullback–Leibler distance, cross entropy, information divergence, and information for discrimination, and has been studied in detail by Csiszár [138] and Amari [22]. Many of the simple properties of these quantities were developed by Shannon. Fano’s inequality was proved in Fano [201]. The notion of sufficient statistic was defined by Fisher [209], and the notion of the minimal sufficient statistic was introduced by Lehmann and Scheffe [350]. The relationship of mutual information and sufficiency is due to Kuliback [335]. The relationship between information theory and thermodynamics has been discussed extensively by Brillouin [77] and Jaynes [294]. The physics of information is a vast new subject of inquiry spawned from statistical mechanics, quantum mechanics, and information theory. The key question is how information is represented physically. Quantum channel capacity (the logarithm of the number of distinguishable preparations of a physical system) and quantum data compression [299] are well-defined problems with nice answers involving the von Neumann entropy. A new element of quantum information arises from the existence of quantum entanglement and the consequences (exhibited in Bell’s inequality) that the observed marginal distribution of physical events are not consistent with any joint distribution (no local realism). The fundamental text by Nielsen and Chuang [395] develops the theory of quantum information and the quantum counterparts to many of the results in this book. There have also been attempts to determine whether there are any fundamental physical limits to computation, including work by Bennett [47] and Bennett and Landauer [48].

Chapter 3: Asymptotic Equipartition Property CHAPTER 3 ASYMPTOTIC EQUIPARTITION PROPERTY In information theory, the analog of the law of large numbers is the asymptotic equipartition property (AEP). It is a direct consequence of the weak law of large numbers. The law of large numbers states that for independent, identically distributed (i.i.d.) random variables, is close to its expected value EX for large values of n . The AEP states that is close to the entropy H , where X 1 , X 2 ,…, X n are i.i.d. random variables and p ( X 1 , X 2 ,…, X n ) is the probability of observing the sequence X 1 , X 2 ,…, X n . Thus, the probability p ( X 1 , X 2 ,…, X n ) assigned to an observed sequence will be close to 2 − nH . This enables us to divide the set of all sequences into two sets, the typical set , where the sample entropy is close to the true entropy, and the nontypical set, which contains the other sequences. Most of our attention will be on the typical sequences. Any property that is proved for the typical sequences will then be true with high probability and will determine the average behavior of a large sample. First, an example. Let the random variable X {0, 1} have a probability mass function defined by p (1) = p and p (0) = q . If X 1 , X 2 ,…, X n are i.i.d. according to p(x) , the probability of a sequence x 1 , x 2 ,…, x n is . For example, the probability of the sequence (1, 0, 1, 1, 0, 1) is = p 4 q 2 . Clearly, it is not true that all 2 n sequences of length n have the same probability. However, we might be able to predict the probability of the sequence that we actually observe. We ask for the probability p ( X 1 , X 2 ,… X n ) of the outcomes X 1 , X 2 ,… X n , where X 1 , X 2 ,… are i.i.d. ~ p(x) . This is insidiously self-referential, but well defined nonetheless. Apparently, we are asking for the probability of an event drawn according to the same probability distribution. Here it turns out that p ( X 1 , X 2 ,…, X n ) is close to 2 − n H with high probability. We summarize this by saying, “Almost all events are almost equally surprising.” This is a way of saying that (3.1) if X 1 , X 2 ,…, X n are i.i.d. ~ p(x) . In the example just given, where , we are simply saying that the number of l’s in the sequence is close to np (with high probability), and all such sequences have (roughly) the same probability 2 − nH ( P ) . We use the idea of convergence in probability, defined as follows: Definition ( Convergence of random variables ). Given a sequence of random variables, X 1 , X 2 ,…, we say that the sequence X 1 , X 2 ,… converges to a random variable X : 1. In probability if for every > 0, Pr{| X n − X | > } → 0 2. In mean square if E ( X n − X ) 2 → 0 3. With probability 1 (also called almost surely) if Pr{lim n →∞ X n = X } = 1 3.1 ASYMPTOTIC EQUIPARTITION PROPERTY THEOREM The asymptotic equipartition property is formalized in the following theorem. Theorem 3.1.1 (AEP) If X 1 , X 2 ,… are i.i.d. ~ p(x), then (3.2) Proof: Functions of independent random variables are also independent random variables. Thus, since the X 1 are i.i.d., so are log p ( X 1 ). Hence, by the weak law of large numbers, (3.3) (3.4) (3.5) which proves the theorem. Definition The typical set A ( n ) with respect to p(x) is the set of sequences ( x 1 ,…, x n ) χ n with the property (3.6) As a consequence of the AEP, we can show that the set has the following properties: Theorem 3.1.2 1 . If ( x 1 , x 2 ,…, x n ) , then H(X) − ≤ − log p(x 1 , x 2 ,…, x n ) ≤ H (X) + . 2 . Pr { A (n) } > 1 − for n sufficiently large . 3 . , where |A| denotes the number of elements in the set A . 4 . for n sufficiently large . Thus, the typical set has probability nearly 1, all elements of the typical set are nearly equiprobable, and the number of elements in the typical set is nearly 2 nH . Proof: The proof of property (1) is immediate from the definition of . The second property follows directly from Theorem 3.1.1, since the probability of the event ( X 1 , X 2 ,…, X n ) tends to 1 as n → ∞. Thus, for any δ > 0, there exists an no such that for all n ≥ n 0 , we have (3.7) Setting δ = , we obtain the second part of the theorem. The identification of δ = will conveniently simplify notation later. To prove property (3), we write (3.8) (3.9) (3.10) (3.11) where the second inequality follows from (3.6) . Hence (3.12) Finally, for sufficiently large n , , so that (3.13) (3.14) (3.15) where the second inequality follows from (3.6) . Hence, (3.16) which completes the proof of the properties of 3.2 CONSEQUENCES OF THE AEP: DATA COMPRESSION Let X 1 , X 2 ,…, X n be independent, identically distributed random variables drawn from the probability mass function p(x) . We wish to find short descriptions for such sequences of random variables. We divide all sequences in χ n into two sets: the typical set and its complement, as shown in Figure 3.1 . FIGURE 3.1. Typical sets and source coding. We order all elements in each set according to some order (e.g., lexicographic order). Then we can represent each sequence of by giving the index of the sequence in the set. Since there are ≤ 2 n(H+ ) sequences in A (n) , the indexing requires no more than n (H + ) + 1 bits. [The extra bit may be necessary because n(H + ) may not be an integer.] We prefix all these sequences by a 0, giving a total length of ≤ n (H + ) + 2 bits to represent each sequence in (see Figure 3.2 ). Similarly, we can index each sequence not in by using not more than n log |χ| + 1 bits. Prefixing these indices by 1, we have a code for all the sequences in χ n . FIGURE 3.2. Source code using the typical set. Note the following features of the above coding scheme: The code is one-to-one and easily decodable. The initial bit acts as a flag bit to indicate the length of the codeword that follows. We have used a brute-force enumeration of the atypical set without taking into account the fact that the number of elements in is less than the number of elements in χ n . Surprisingly, this is good enough to yield an efficient description. The typical sequences have short descriptions of length ≈ nH . We use the notation x n to denote a sequence x 1 , x 2 ,…, x n . Let l ( x n ) be the length of the codeword corresponding to x n . If n is sufficiently large so that , the expected length of the codeword is (3.17) (3.18) (3.19) (3.20) (3.21) (3.22) where can be made arbitrarily small by an appropriate choice of followed by an appropriate choice of n . Hence we have proved the following theorem. Theorem 3.2.1 Let X n be i.i.d. ~ p(x). Let > 0. Then there exists a code that maps sequences x n of length n into binary strings such that the mapping is one-to-one (and therefore invertible) and (3.23) for n sufficiently large . Thus, we can represent sequences X n using n H (X) bits on the average. 3.3 HIGH-PROBABILITY SETS AND THE TYPICAL SET From the definition of , it is clear that is a fairly small set that contains most of the probability. But from the definition, it is not clear whether it is the smallest such set. We will prove that the typical set has essentially the same number of elements as the smallest set, to first order in the exponent. Definition For each n = 1, 2,…, let be the smallest set with (3.24) We argue that must have significant intersection with and therefore must have about as many elements. In Problem 3.3.11, we outline the proof of the following theorem. Theorem 3.3.1 Let X 1 , X 2 ,…, X n be i.i.d. ~ p(x). For δ < and any δ′ > 0, if , then (3.25) Thus, must have at least 2 nH elements, to first order in the exponent. But has elements. Therefore is about the same size as the smallest high-probability set. We will now define some new notation to express equality to first order in the exponent. Definition The notation a n = b n means (3.26) Thus, a n = b n implies that a n and b n are equal to the first order in the exponent. We can now restate the above results: If δ n → 0 and n → 0, then (3.27) To illustrate the difference between and , let us consider a Bernoulli sequence X 1 , X 2 ,…, X n with parameter p = 0.9. [A Bernoulli( θ ) random variable is a binary random variable that takes on the value 1 with probability θ .] The typical sequences in this case are the sequences in which the proportion of 1’s is close to 0.9. However, this does not include the most likely single sequence, which is the sequence of all 1’s. The set includes all the most probable sequences and therefore includes the sequence of all 1’s. Theorem 3.3.1 implies that and must both contain the sequences that have about 90% 1’s, and the two sets are almost equal in size. SUMMARY AEP. “Almost all events are almost equally surprising.” Specifically, if X 1 , X 2 ,… are i.i.d. ~ p(x) , then (3.28) Definition. The typical set is the set of sequences x 1 , x 2 ,… x n satisfying (3.29) Properties of the typical set 1. If ( x 1 , x 2 ,…, x n ) , then . 2. for n sufficiently large. 3. , where | A | denotes the number of elements in set A . Definition . a n = b n means that 1/ n log . Smallest probable set. Let X 1 , X 2 ,…, X n be i.i.d. ~ p(x) , and for δ < , let ⊂ χ n be the smallest set such that . Then (3.30) PROBLEMS 3.1 Markov’s inequality and Chebyshev’s inequality (a) (Markov’s inequality) For any nonnegative random variable X and any t > 0, show that (3.31) Exhibit a random variable that achieves this inequality with equality. (b) (Chebyshev’s inequality) Let Y be a random variable with mean μ and variance σ 2 . By letting X = ( Y − μ ) 2 , show that for any > 0, (3.32) (c) (Weak law of large numbers) Let Z 1 , Z 2 ,…, Z n be a sequence of i.i.d. random variables with mean μ and variance σ 2 . Let be the sample mean. Show that (3.33) Thus, . This is known as the weak law of large numbers . 3.2 AEP and mutual information . Let ( X i , Y i ) be i.i.d. ~ p(x, y) . We form the log likelihood ratio of the hypothesis that X and Y are independent vs. the hypothesis that X and Y are dependent. What is the limit of 3.3 Piece of cake . A cake is sliced roughly in half, the largest piece being chosen each time, the other pieces discarded. We will assume that a random cut creates pieces of proportions Thus, for example, the first cut (and choice of largest piece) may result in a piece of size . Cutting and choosing from this piece might reduce it to size ( ) ( ) at time 2, and so on. How large, to first order in the exponent, is the piece of cake after n cuts? 3.4 AEP . Let X i be iid ~ p(x) , x {1, 2,…, m }. Let μ = EX and H = − ∑ p(x) log p(x) . Let A n = { x n χ n : | − log p(x n ) − H | ≤ }. Let B n = { x n χ n : . (a) Does Pr{ X n A n } → 1? (b) Does Pr{ X n A n ∩ B n } → 1? (c) Show that | A n ∩ B n | ≤ 2 n(H+ ) for all n . (d) Show that | A n ∩ B n | ≥ ( ) 2 n(H− ) for n sufficiently large. 3.5 Sets defined by probabilities . Let X 1 , X 2 ,… be an i.i.d. sequence of discrete random variables with entropy H (X) . Let denote the subset of n -sequences with probabilities ≥ 2 − nt . (a) Show that | C n (t)| ≤ 2 nt . (b) For what values of t does P ({ X n C n ( t )}) → 1? 3.6 AEP-like limit . Let X 1 , X 2 ,… be i.i.d. drawn according to probability mass function p(x) . Find 3.7 AEP and source coding . A discrete memoryless source emits a sequence of statistically independent binary digits with probabilities p (1) = 0.005 and p (0) = 0.995. The digits are taken 100 at a time and a binary codeword is provided for every sequence of 100 digits containing three or fewer 1’s. (a) Assuming that all codewords are the same length, find the minimum length required to provide codewords for all sequences with three or fewer 1’s. (b) Calculate the probability of observing a source sequence for which no codeword has been assigned. (c) Use Chebyshev’s inequality to bound the probability of observing a source sequence for which no codeword has been assigned. Compare this bound with the actual probability computed in part (b). 3.8 Products . Let Let X 1 , X 2 ,… be drawn i.i.d. according to this distribution. Find the limiting behavior of the product 3.9 AEP . Let X 1 , X 2 ,… be independent, identically distributed random variables drawn according to the probability mass function p(x), x {1, 2,…, m }. Thus, p(x 1 , x 2 ,…, x n ) = . We know that log p ( X 1 , X 2 ,…, X n ) → H(X) in probability. Let q (x 1 , x 2 ,…, x n ) = , where q is another probability mass function on [1, 2,…, m }. (a) Evaluate lim log q ( X 1 , X 2 ,…, X n ), where X 1 , X 2 ,… are i.i.d. ~ p(x) . (b) Now evaluate the limit of the log likelihood ratio when X 1 , X 2 ,… are i.i.d. ~ p(x) . Thus, the odds favoring q are exponentially small when p is true. 3.10 Random box size . An n -dimensional rectangular box with sides X 1 , X 2 , X 3 ,…, X n , is to be constructed. The volume is V n , = . The edge length l of a n -cube with the same volume as the random box is . Let X 1 , X 2 ,… be i.i.d. uniform random variables over the unit interval [0, 1]. Find and compare to ( EV n ) . Clearly, the expected edge length does not capture the idea of the volume of the box. The geometric mean, rather than the arithmetic mean, characterizes the behavior of products. 3.11 Proof of Theorem 3.3.1 . This problem shows that the size of the smallest “probable” set is about 2 nH . Let X 1 , X 2 ,…, X n be i.i.d. ~ p(x) . Let such that . Fix . (a) Given any two sets A, B such that Pr( A ) > 1 − 1 and Pr( B ) > 1 − 2 , show that Pr( A ∩ B ) > 1 − 1 − 2 . Hence, . (b) Justify the steps in the chain of inequalities (3.34) (3.35) (3.36) (3.37) (3.38) (c) Complete the proof of the theorem. 3.12 Monotonic convergence of the empirical distribution . Let denote the empirical probability mass function corresponding to X 1 , X 2 ,…, X n i.i.d. ~ p(x) , x χ . Specifically, is the proportion of times that X i = x in the first n samples, where I is the indicator function. (a) Show for χ binary that Thus, the expected relative entropy “distance” from the empirical distribution to the true distribution decreases with sample size. (Hint: Write and use the convexity of D .) (b) Show for an arbitrary discrete χ that (Hint: Write as the average of n empirical mass functions with each of the n samples deleted in turn.) 3.13 Calculation of typical set . To clarify the notion of a typical set and the smallest set of high probability , we will calculate the set for a simple example. Consider a sequence of i.i.d. binary random variables, X 1 , X 2 , X n , where the probability that X i = 1 is 0.6 (and therefore the probability that X 1 = 0 is 0.4). (a) Calculate H (X) . (b) With n = 25 and = 0.1, which sequences fall in the typical set ? What is the probability of the typical set? How many elements are there in the typical set? (This involves computation of a table of probabilities for sequences with k 1’s, 0 ≤ k ≤ 25, and finding those sequences that are in the typical set.) (c) How many elements are there in the smallest set that has probability 0.9? (d) How many elements are there in the intersection of the sets in parts (b) and (c)? What is the probability of this intersection? HISTORICAL NOTES The asymptotic equipartition property (AEP) was first stated by Shannon in his original 1948 paper [472], where he proved the result for i.i.d. processes and stated the result for stationary ergodic processes. McMillan [384] and Breiman [74] proved the AEP for ergodic finite alphabet sources. The result is now referred to as the AEP or the Shannon–McMillan–Breiman theorem. Chung [101] extended the theorem to the case of countable alphabets and Moy [392], Perez [417], and Kieffer [312] proved the L 1 convergence when { X i } is continuous valued and ergodic. Barron [34] and Orey [402] proved almost sure convergence for real-valued ergodic processes; a simple sandwich argument (Algoet and Cover [20]) will be used in Section 16.8 to prove the general AEP.

Chapter 4: Entropy Rates of a Stochastic Process CHAPTER 4 ENTROPY RATES OF A STOCHASTIC PROCESS The asymptotic equipartition property in Chapter 3 establishes that nH (X) bits suffice on the average to describe n independent and identically distributed random variables. But what if the random variables are dependent? In particular, what if the random variables form a stationary process? We will show, just as in the i.i.d. case, that the entropy H ( X 1 , X 2 , X n ) grows (asymptotically) linearly with n at a rate H(χ) , which we will call the entropy rate of the process. The interpretation of H(χ) as the best achievable data compression will await the analysis in Chapter 5. 4.1 MARKOV CHAINS A stochastic process { X i } is an indexed sequence of random variables. In general, there can be an arbitrary dependence among the random variables. The process is characterized by the joint probability mass functions Pr{( X 1 , X 2 ,…, X n ) = ( x 1 , x 2 ,…, x n )} = p ( x 1 , x 2 ,…, x n ), ( x 1 , x 2 ,…, x n ) χ n for n = 1, 2, …. Definition A stochastic process is said to be stationary if the joint distribution of any subset of the sequence of random variables is invariant with respect to shifts in the time index; that is, (4.1) for every n and every shift l and for all x 1 , x 2 ,…, x n χ. A simple example of a stochastic process with dependence is one in which each random variable depends only on the one preceding it and is conditionally independent of all the other preceding random variables. Such a process is said to be Markov. Definition A discrete stochastic process X 1 , X 2 ,… is said to be a Markov chain or a Markov process if for n = 1, 2,…, (4.2) for all x 1 , x 2 ,…, x n , x n +1 χ. In this case, the joint probability mass function of the random variables can be written as (4.3) Definition The Markov chain is said to be time invariant if the conditional probability p ( x n+1 | x n ) does not depend on n ; that is, for n = 1, 2,…, (4.4) We will assume that the Markov chain is time invariant unless otherwise stated. If { X i } is a Markov chain, X n , is called the state at time n . A time-invariant Markov chain is characterized by its initial state and a probability transition matrix P = [ P ij ], i, j {1, 2,…, m }, where P ij = Pr{ X n+1 = j | X n = i }. If it is possible to go with positive probability from any state of the Markov chain to any other state in a finite number of steps, the Markov chain is said to be irreducible . If the largest common factor of the lengths of different paths from a state to itself is 1, the Markov chain is said to aperiodic . If the probability mass function of the random variable at time n is P(x n ) , the probability mass function at time n + 1 is (4.5) A distribution on the states such that the distribution at time n + 1 is the same as the distribution at time n is called a stationary distribution . The stationary distribution is so called because if the initial state of a Markov chain is drawn according to a stationary distribution, the Markov chain forms a stationary process. If the finite-state Markov chain is irreducible and aperiodic, the stationary distribution is unique, and from any starting distribution, the distribution of X n tends to the stationary distribution as n → ∞. Example 4.1.1 Consider a two-state Markov chain with a probability transition matrix (4.6) as shown in Figure 4.1 . FIGURE 4.1. Two-state Markov chain. Let the stationary distribution be represented by a vector μ whose components are the stationary probabilities of states 1 and 2, respectively. Then the stationary probability can be found by solving the equation μP = μ or, more simply, by balancing probabilities. For the stationary distribution, the net probability flow across any cut set in the state transition graph is zero. Applying this to Figure 4.1 , we obtain (4.7) Since μ 1 , + μ 2 = 1, the stationary distribution is (4.8) If the Markov chain has an initial state drawn according to the stationary distribution, the resulting process will be stationary. The entropy of the state X n at time n is (4.9) However, this is not the rate at which entropy grows for H ( X 1 , X 2 ,…, X n ). The dependence among the X i ’s will take a steady toll. 4.2 ENTROPY RATE If we have a sequence of n random variables, a natural question to ask is: How does the entropy of the sequence grow with n ? We define the entropy rate as this rate of growth as follows. Definition The entropy rate of a stochastic process { X i } is defined by (4.10) when the limit exists. We now consider some simple examples of stochastic processes and their corresponding entropy rates. 1. Typewriter . Consider the case of a typewriter that has m equally likely output letters. The typewriter can produce m n sequences of length n , all of them equally likely. Hence H ( X 1 , X 2 ,…, X n ) = log m n and the entropy rate is H ( χ ) = log m bits per symbol. 2. X 1 , X 2 ,… are i.i.d. random variables . Then (4.11) which is what one would expect for the entropy rate per symbol. 3. Sequence of independent but not identically distributed random variables . In this case, (4.12) but the H ( X 1 )’s are all not equal. We can choose a sequence of distributions on X 1 , X 2 ,… such that the limit of ∑ H ( X 1 ) does not exist. An example of such a sequence is a random binary sequence where p i = P ( X 1 = 1) is not constant but a function of i , chosen carefully so that the limit in (4.10) does not exist. For example, let (4.13) for k = 0, 1, 2, …. Then there are arbitrarily long stretches where H ( X 1 ) = 1, followed by exponentially longer segments where H ( X i ) = 0. Hence, the running average of the H ( X i ) will oscillate between 0 and 1 and will not have a limit. Thus, H ( χ ) is not defined for this process. We can also define a related quantity for entropy rate: (4.14) when the limit exists. The two quantities H ( χ ) and H’ ( χ ) correspond to two different notions of entropy rate. The first is the per symbol entropy of the n random variables, and the second is the conditional entropy of the last random variable given the past. We now prove the important result that for stationary processes both limits exist and are equal. Theorem 4.2.1 For a stationary stochastic process, the limits in (4.10) and (4.14) exist and are equal: (4.15) We first prove that lim H ( X n | X n −1 ,…, X 1 ) exists. Theorem 4.2.2 For a stationary stochastic process, H ( X n | X n −1 ,…, X 1 ) is nonincreasing in n and has a limit H′ (χ) . Proof (4.16) (4.17) where the inequality follows from the fact that conditioning reduces entropy and the equality follows from the stationarity of the process. Since H ( X n | X n −1 ,…, X 1 ) is a decreasing sequence of nonnegative numbers, it has a limit, H′ ( χ ). We now use the following simple result from analysis. Theorem 4.2.3 (Cesáro mean) If a n → a and b n = . Proof: (Informal outline) . Since most of the terms in the sequence { a k } are eventually close to a , then b n , which is the average of the first n terms, is also eventually close to a . Formal Proof: Let > 0. Since a n → a , there exists a number N ( ) such that | a n − a | ≤ for all n ≥ N ( ). Hence, (4.18) (4.19) (4.20) (4.21) for all n ≥ N ( ). Since the first term goes to 0 as n → ∞, we can make | b n − a | ≤ 2 by taking n large enough. Hence, b n → a as n → ∞. Proof of Theorem 4.2.1: By the chain rule, (4.22) that is, the entropy rate is the time average of the conditional entropies. But we know that the conditional entropies tend to a limit H′ . Hence, by Theorem 4.2.3, their running average has a limit, which is equal to the limit H′ of the terms. Thus, by Theorem 4.2.2, (4.23) The significance of the entropy rate of a stochastic process arises from the AEP for a stationary ergodic process. We prove the general AEP in Section 16.8, where we show that for any stationary ergodic process, (4.24) with probability 1. Using this, the theorems of Chapter 3 can easily be extended to a general stationary ergodic process. We can define a typical set in the same way as we did for the case in Chapter 3. By the same arguments, we can show that the typical set has a probability close to 1 and that there are about 2 nH(χ) typical sequences of length n , each with probability about 2 −nH(χ) . We can therefore represent the typical sequences of length n using approximately nH(χ) bits. This shows the significance of the entropy rate as the average description length for a stationary ergodic process. The entropy rate is well defined for all stationary processes. The entropy rate is particularly easy to calculate for Markov chains. Markov Chains. For a stationary Markov chain, the entropy rate is given by (4.25) where the conditional entropy is calculated using the given stationary distribution. Recall that the stationary distribution μ is the solution of the equations (4.26) We express the conditional entropy explicitly in the following theorem. Theorem 4.2.4 Let (X i } be a stationary Markov chain with stationary distribution it and transition matrix P. Let X 1 ~ μ. Then the entropy rate is (4.27) Proof: Example 4.2.1 (Two-state Markov chain) The entropy rate of the two-state Markov chain in Figure 4.1 is (4.28) Remark If the Markov chain is irreducible and aperiodic, it has a unique stationary distribution on the states, and any initial distribution tends to the stationary distribution as n → ∞. In this case, even though the initial distribution is not the stationary distribution, the entropy rate, which is defined in terms of long-term behavior, is H (χ) , as defined in (4.25) and (4.27) . 4.3 EXAMPLE: ENTROPY RATE OF A RANDOM WALK ON A WEIGHTED GRAPH As an example of a stochastic process, let us consider a random walk on a connected graph ( Figure 4.2 ). Consider a graph with m nodes labeled {1, 2,…, m }, with weight W ij ≥ 0 on the edge joining node i to node j . (The graph is assumed to be undirected, so that W ij = W ji . We set W ij = 0 if there is no edge joining nodes i and j .) FIGURE 4.2. Random walk on a graph. A particle walks randomly from node to node in this graph. The random walk { X n }, X n {1, 2,…, m }, is a sequence of vertices of the graph. Given X n = i , the next vertex j is chosen from among the nodes connected to node i with a probability proportional to the weight of the edge connecting i to j . Thus, P ij = W ij /∑ k W ik . In this case, the stationary distribution has a surprisingly simple form, which we will guess and verify. The stationary distribution for this Markov chain assigns probability to node i proportional to the total weight of the edges emanating from node i . Let (4.29) be the total weight of edges emanating from node i , and let (4.30) be the sum of the weights of all the edges. Then ∑ i W i = 2 W . We now guess that the stationary distribution is (4.31) We verify that this is the stationary distribution by checking that μP = μ . Here (4.32) (4.33) (4.34) (4.35) Thus, the stationary probability of state i is proportional to the weight of edges emanating from node i . This stationary distribution has an interesting property of locality: It depends only on the total weight and the weight of edges connected to the node and hence does not change if the weights in some other part of the graph are changed while keeping the total weight constant. We can now calculate the entropy rate as (4.36) (4.37) (4.38) (4.39) (4.40) (4.41) If all the edges have equal weight, the stationary distribution puts weight E i /2 E on node i , where E i is the number of edges emanating from node i and E is the total number of edges in the graph. In this case, the entropy rate of the random walk is (4.42) This answer for the entropy rate is so simple that it is almost misleading. Apparently, the entropy rate, which is the average transition entropy, depends only on the entropy of the stationary distribution and the total number of edges. Example 4.3.1 (Random walk on a chessboard) Let a king move at random on an 8 × 8 chessboard. The king has eight moves in the interior, five moves at the edges, and three moves at the corners. Using this and the preceding results, the stationary probabilities are, respectively, , , and and the entropy rate is 0.92 log 8. The factor of 0.92 is due to edge effects; we would have an entropy rate of log 8 on an infinite chessboard. Similarly, we can find the entropy rate of rooks (log 14 bits, since the rook always has 14 possible moves), bishops, and queens. The queen combines the moves of a rook and a bishop. Does the queen have more or less freedom than the pair? Remark It is easy to see that a stationary random walk on a graph is time-reversible; that is, the probability of any sequence of states is the same forward or backward: (4.43) Rather surprisingly, the converse is also true; that is, any time-reversible Markov chain can be represented as a random walk on an undirected weighted graph. 4.4 SECOND LAW OF THERMODYNAMICS One of the basic laws of physics, the second law of thermodynamics, states that the entropy of an isolated system is nondecreasing. We now explore the relationship between the second law and the entropy function that we defined earlier in this chapter. In statistical thermodynamics, entropy is often defined as the log of the number of microstates in the system. This corresponds exactly to our notion of entropy if all the states are equally likely. But why does entropy increase? We model the isolated system as a Markov chain with transitions obeying the physical laws governing the system. Implicit in this assumption is the notion of an overall state of the system and the fact that knowing the present state, the future of the system is independent of the past. In such a system we can find four different interpretations of the second law. It may come as a shock to find that the entropy does not always increase. However, relative entropy always decreases. 1. Relative entropy D (μ n ||μ′ n ) decreases with n . Let μ n and μ′ n be two probability distributions on the state space of a Markov chain at time n , and let μ n+1 and μ′ n+1 be the corresponding distributions at time n + 1. Let the corresponding joint mass functions be denoted by p and q . Thus, P ( x n , x n+1 ) = P ( x n ) r ( x n +1 | x n ) and q ( x n , x n +1 ) = q ( x n ) r ( x n+1 | x n ), where r (·|·) is the probability transition function for the Markov chain. Then by the chain rule for relative entropy, we have two expansions: Since both p and q are derived from the Markov chain, the conditional probability mass functions p ( x n +1 | x n ) and q ( x n +1 | x n ) are both equal to r ( x n +1 | x n ), and hence D ( p ( x n +1 | x n )|| q ( x n +1 | x n )) = 0. Now using the nonnegativity of D ( p ( x n | x n +1 )|| q ( x n | x n +1 )) (Corollary to Theorem 2.6.3), we have (4.44) or (4.45) Consequently, the distance between the probability mass functions is decreasing with time n for any Markov chain. An example of one interpretation of the preceding inequality is to suppose that the tax system for the redistribution of wealth is the same in Canada and in England. Then if μ n and μ′ n represent the distributions of wealth among people in the two countries, this inequality shows that the relative entropy distance between the two distributions decreases with time. The wealth distributions in Canada and England become more similar. 2. Relative entropy D (μ n ||μ) between a distribution μ n , on the states at time n and a stationary distribution μ decreases with n . In (4.45) , μ′ n is any distribution on the states at time n . If we let μ′ n be any stationary distribution μ, the distribution μ′ n +1 at the next time is also equal to μ. Hence, (4.46) which implies that any state distribution gets closer and closer to each stationary distribution as time passes. The sequence D (μ n ||μ) is a monotonically nonincreasing nonnegative sequence and must therefore have a limit. The limit is zero if the stationary distribution is unique, but this is more difficult to prove. 3. Entropy increases if the stationary distribution is uniform . In general, the fact that the relative entropy decreases does not imply that the entropy increases. A simple counterexample is provided by any Markov chain with a nonuniform stationary distribution. If we start this Markov chain from the uniform distribution, which already is the maximum entropy distribution, the distribution will tend to the stationary distribution, which has a lower entropy than the uniform. Here, the entropy decreases with time. If, however, the stationary distribution is the uniform distribution, we can express the relative entropy as (4.47) In this case the monotonic decrease in relative entropy implies a monotonic increase in entropy. This is the explanation that ties in most closely with statistical thermodynamics, where all the microstates are equally likely. We now characterize processes having a uniform stationary distribution. Definition A probability transition matrix [ P ij ], P ij = Pr{ X n +1 = j | X n = i }, is called doubly stochastic if (4.48) and (4.49) Remark The uniform distribution is a stationary distribution of P if and only if the probability transition matrix is doubly stochastic (see Problem 4.1). 4. The conditional entropy H ( X n | X 1 ) increases with n for a stationary Markov process . If the Markov process is stationary, H ( X n ) is constant. So the entropy is nonincreasing. However, we will prove that H ( X n | X 1 ) increases with n . Thus, the conditional uncertainty of the future increases. We give two alternative proofs of this result. First, we use the properties of entropy, (4.50) (4.51) (4.52) Alternatively, by an application of the data-processing inequality to the Markov chain X 1 → X n −1 → X n , we have (4.53) Expanding the mutual informations in terms of entropies, we have (4.54) By stationarity, H ( X n −1 ) = H ( X n ), and hence we have (4.55) [These techniques can also be used to show that H ( X 0 | X n ) is increasing in n for any Markov chain.] 5. Shuffles increase entropy . If T is a shuffle (permutation) of a deck of cards and X is the initial (random) position of the cards in the deck, and if the choice of the shuffle T is independent of X , then (4.56) where T X is the permutation of the deck induced by the shuffle T on the initial permutation X . Problem 4.3 outlines a proof. 4.5 FUNCTIONS OF MARKOV CHAINS Here is an example that can be very difficult if done the wrong way. It illustrates the power of the techniques developed so far. Let X 1 , X 2 ,…, X n ,… be a stationary Markov chain, and let Y i ϕ( X i ) be a process each term of which is a function of the corresponding state in the Markov chain. What is the entropy rate H ( )? Such functions of Markov chains occur often in practice. In many situations, one has only partial information about the state of the system. It would simplify matters greatly if Y 1 , Y 2 ,…, Y n also formed a Markov chain, but in many cases, this is not true. Since the Markov chain is stationary, so is Y 1 , Y 2 ,…, Y n , and the entropy rate is well defined. However, if we wish to compute H ( ), we might compute H ( Y n | Y n −1 ,…, Y 1 ) for each n and find the limit. Since the convergence can be arbitrarily slow, we will never know how close we are to the limit. (We can’t look at the change between the values at n and n + 1, since this difference may be small even when we are far away from the limit—consider, for example, ∑ .) It would be useful computationally to have upper and lower bounds converging to the limit from above and below. We can halt the computation when the difference between upper and lower bounds is small, and we will then have a good estimate of the limit. We already know that H ( Y n | Y n −1 ,…, Y 1 ) converges monotonically to H ( ) from above. For a lower bound, we will use H ( Y n | Y n −1 ,…, Y 1 , X 1 ). This is a neat trick based on the idea that X 1 contains as much information about Y n as Y 1 , Y 0 , Y −1 ,…. Lemma 4.5.1 (4.57) Proof: We have for k = 1, 2,…, (4.58) (4.59) (4.60) (4.61) (4.62) where (a) follows from that fact that Y1 is a function of X 1 , and (b) follows from the Markovity of X , (c) follows from the fact that Vi is a function of X i , (d) follows from the fact that conditioning reduces entropy, and (e) follows by stationarity. Since the inequality is true for all k , it is true in the limit. Thus, (4.63) (4.64) The next lemma shows that the interval between the upper and the lower bounds decreases in length. Lemma 4.5.2 (4.65) Proof: The interval length can be rewritten as (4.66) By the properties of mutual information, (4.67) and I ( X 1 ; Y 1 , Y 2 ,…, Y n ) increases with n . Thus, lim I ( X 1 ; Y 1 , Y 2 ,…, Y n ) exists and (4.68) By the chain rule, (4.69) (4.70) (4.71) Since this infinite sum is finite and the terms are nonnegative, the terms must tend to 0; that is, (4.72) which proves the lemma. Combining Lemmas 4.5.1 and 4.5.2, we have the following theorem. Theorem 4.5.1 If X 1 , X 2 ,…, X n form a stationary Markov chain, and Y i = ϕ ( X i ), then (4.73) and (4.74) In general, we could also consider the case where Y i is a stochastic function (as opposed to a deterministic function) of X i Consider a Markov process X 1 , X 2 ,…, X n , and define a new process Y 1 , Y 2 ,…, Y n , where each Y i is drawn according to p ( y i | x i ), conditionally independent of all the other X j , j ≠ i ; that is, (4.75) Such a process, called a hidden Markov model (HMM), is used extensively in speech recognition, handwriting recognition, and so on. The same argument as that used above for functions of a Markov chain carry over to hidden Markov models, and we can lower bound the entropy rate of a hidden Markov model by conditioning it on the underlying Markov state. The details of the argument are left to the reader. SUMMARY Entropy rate. Two definitions of entropy rate for a stochastic process are (4.76) (4.77) For a stationary stochastic process, (4.78) Entropy rate of a stationary Markov chain (4.79) Second law of thermodynamics. For a Markov chain: 1. Relative entropy D (μ n ||μ′ n ) decreases with time 2. Relative entropy D (μ n ||μ) between a distribution and the stationary distribution decreases with time. 3. Entropy H ( X n ) increases if the stationary distribution is uniform. 4. The conditional entropy H ( X n | X 1 ) increases with time for a stationary Markov chain. 5. The conditional entropy H ( X 0 | X n ) of the initial condition X 0 increases for any Markov chain. Functions of a Markov chain. If X 1 , X 2 ,…, X n form a stationary Markov chain and Y i = ϕ ( X i ), then (4.80) and (4.81) PROBLEMS 4.1 Doubly stochastic matrices . An n × n matrix P = [ P ij ] is said to be doubly stochastic if P ij ≥ 0 and ∑ j P ij = 1 for all i and ∑ i p ij = 1 for all j . An n × n matrix P is said to be a permutation matrix if it is doubly stochastic and there is precisely one P ij = 1 in each row and each column. It can be shown that every doubly stochastic matrix can be written as the convex combination of permutation matrices. (a) Let a t = ( a 1 , a 2 ,…, a n ), a i ≥ 0, ∑ a i = 1, be a probability vector. Let b = a P , where P is doubly stochastic. Show that b is a probability vector and that H ( b 1 , b 2 ,…, b n ) ≥ H ( a 1 , a 2 ,…, a n ). Thus, stochastic mixing increases entropy. (b) Show that a stationary distribution μ for a doubly stochastic matrix P is the uniform distribution. (c) Conversely, prove that if the uniform distribution is a stationary distribution for a Markov transition matrix P , then P is doubly stochastic. 4.2 Time’s arrow . Let be a stationary stochastic process. Prove that In other words, the present has a conditional entropy given the past equal to the conditional entropy given the future. This is true even though it is quite easy to concoct stationary random processes for which the flow into the future looks quite different from the flow into the past. That is, one can determine the direction of time by looking at a sample function of the process. Nonetheless, given the present state, the conditional uncertainty of the next symbol in the future is equal to the conditional uncertainty of the previous symbol in the past. 4.3 Shuffles increase entropy . Argue that for any distribution on shuffles T and any distribution on card positions X that (4.82) (4.83) (4.84) (4.85) if X and T are independent. 4.4 Second law of thermodynamics . Let X 1 , X 2 , X 3 ,… be a stationary first-order Markov chain. In Section 4.4 it was shown that H ( X n | X 1 ) ≥ H ( X n −1 | X 1 ) for n = 2, 3, …. Thus, conditional uncertainty about the future grows with time. This is true although the unconditional uncertainty H ( X n ) remains constant. However, show by example that H ( X n | X 1 = x 1 ) does not necessarily grow with n for every x 1 . 4.5 Entropy of a random tree . Consider the following method of generating a random tree with n nodes. First expand the root node: Then expand one of the two terminal nodes at random: At time k , choose one of the k − 1 terminal nodes according to a uniform distribution and expand it. Continue until n terminal nodes have been generated. Thus, a sequence leading to a five-node tree might look like this: Surprisingly, the following method of generating random trees yields the same probability distribution on trees with n terminal nodes. First choose an integer N 1 uniformly distributed on {1, 2,…, n − 1}. We then have the picture Then choose an integer N2 uniformly distributed over {1, 2,…, N 1 − 1), and independently choose another integer N 3 uniformly over {1, 2,…, ( n − N 1 ) − 1). The picture is now Continue the process until no further subdivision can be made. (The equivalence of these two tree generation schemes follows, for example, from Polya’s urn model.) Now let T n , denote a random n-node tree generated as described. The probability distribution on such trees seems difficult to describe, but we can find the entropy of this distribution in recursive form. First some examples. For n = 2, we have only one tree. Thus, H ( T 2 ) = 0. For n = 3, we have two equally probable trees: Thus, H ( T 3 ) = log 2. For n = 4, we have five possible trees, with probabilities . Now for the recurrence relation. Let N 1 ( T n ) denote the number of terminal nodes of T n in the right half of the tree. Justify each of the steps in the following: (4.86) (4.87) (4.88) (4.89) (4.90) (4.91) (f) Use this to show that (4.92) or (4.93) for appropriately defined c n . Since ∑ c n = c < ∞, you have proved that H ( T n ) converges to a constant. Thus, the expected number of bits necessary to describe the random tree T n grows linearly with n . 4.6 Monotonicity of entropy per element . For a stationary stochastic process X 1 , X 2 ,…, X n , show that (a) (4.94) (b) (4.95) 4.7 Entropy rates of Markov chains (a) Find the entropy rate of the two-state Markov chain with transition matrix (b) What values of p 01 , p 10 maximize the entropy rate? (c) Find the entropy rate of the two-state Markov chain with transition matrix (d) Find the maximum value of the entropy rate of the Markov chain of part (c). We expect that the maximizing value of p should be less than , since the 0 state permits more information to be generated than the 1 state. (e) Let N ( t ) be the number of allowable state sequences of length t for the Markov chain of part (c). Find N ( t ) and calculate [ Hint: Find a linear recurrence that expresses N ( t ) in terms of N ( t − 1) and N ( t − 2). Why is H 0 an upper bound on the entropy rate of the Markov chain? Compare H 0 with the maximum entropy found in part (d).] 4.8 Maximum entropy process . A discrete memoryless source has the alphabet {1, 2}, where the symbol 1 has duration 1 and the symbol 2 has duration 2. The probabilities of 1 and 2 are p 1 and p 2 , respectively. Find the value of p 1 that maximizes the source entropy per unit time H (χ) = . What is the maximum value H (χ)? 4.9 Initial conditions . Show, for a Markov chain, that Thus, initial conditions X 0 become more difficult to recover as the future X n , unfolds. 4.10 Pairwise independence . Let X 1 , X 2 ,…, X n −1 be i.i.d. random variables taking values in {0, 1}, with Pr{ X i = 1} = . Let X n , = 1 if X i is odd and X n , = 0 otherwise. Let n ≥ 3. (a) Show that X i and X j are independent for i ≠ j , i , j ≠ {1, 2,…, n }. (b) Find H ( X i , X j ) for i ≠ j . (c) Find H ( X 1 , X 2x ,…, X n ). Is this equal to nH ( X 1 )? 4.11 Stationary processes . Let …, X −1 , X 0 , X 1 ,… be a stationary (not necessarily Markov) stochastic process. Which of the following statements are true? Prove or provide a counterexample. (a) H ( X n | X 0 ) = H ( X - n | X 0 ). (b) H ( X n | X 0 ) ≤ H ( X n −1 | X 0 ). (c) H ( X n | X 1 , X 2 ,…, X n −1 , X n +1 ) is nonincreasing in n . (d) H ( X n | X 1 ,…, X n −1 , X n +1 ,…, X 2 n ) is nonincreasing in n . 4.12 Entropy rate of a dog looking for a bone . A dog walks on the integers, possibly reversing direction at each step with probability p = 0.1. Let X 0 = 0. The first step is equally likely to be positive or negative. A typical walk might look like this: (a) Find H ( X 1 , X 2 ,…, X n ). (b) Find the entropy rate of the dog. (c) What is the expected number of steps that the dog takes before reversing direction? 4.13 The past has little to say about the future . For a stationary stochastic process X 1 , X 2 ,…, X n ,…, show that (4.96) Thus, the dependence between adjacent n -blocks of a stationary process does not grow linearly with n . 4.14 Functions of a stochastic process (a) Consider a stationary stochastic process X 1 , X 2 ,…, X n , and let Y 1 , Y 2 ,…, Y n be defined by (4.97) for some function 0. Prove that (4.98) (b) What is the relationship between the entropy rates H ( Z ) and H (χ) if (4.99) for some function ψ? 4.15 Entropy rate . Let { X i } be a discrete stationary stochastic process with entropy rate H (χ). Show that (4.100) for, k = 1, 2, …. 4.16 Entropy rate of constrained sequences . In magnetic recording, the mechanism of recording and reading the bits imposes constraints on the sequences of bits that can be recorded. For example, to ensure proper synchronization, it is often necessary to limit the length of runs of 0’s between two 1’s. Also, to reduce intersymbol interference, it may be necessary to require at least one 0 between any two 1’s. We consider a simple example of such a constraint. Suppose that we are required to have at least one 0 and at most two 0’s between any pair of 1’s in a sequences. Thus, sequences like 101001 and 0101001 are valid sequences, but 0110010 and 0000101 are not. We wish to calculate the number of valid sequences of length n . (a) Show that the set of constrained sequences is the same as the set of allowed paths on the following state diagram: (b) Let X i ( n ) be the number of valid paths of length n ending at state i . Argue that X ( n ) = [ X 1 ( n ) X 2 ( n ) X 3 ( n )] t satisfies the following recursion: (4.101) with initial conditions X (1) = [1 1 0] t . (c) Let (4.102) Then we have by induction (4.103) Using the eigenvalue decomposition of A for the case of distinct eigenvalues, we can write A = U −1 Λ U , where Λ is the diagonal matrix of eigenvalues. Then A n−1 = U −1 Λ n−1 U . Show that we can write (4.104) where Y 1 , Y 2 , Y 3 do not depend on n . For large n , this sum is dominated by the largest term. Therefore, argue that for i = 1, 2, 3, we have (4.105) where λ is the largest (positive) eigenvalue. Thus, the number of sequences of length n grows as λ n for large n . Calculate for λ the matrix A above. (The case when the eigenvalues are not distinct can be handled in a similar manner.) (d) We now take a different approach. Consider a Markov chain whose state diagram is the one given in part (a), but with arbitrary transition probabilities. Therefore, the probability transition matrix of this Markov chain is (4.106) Show that the stationary distribution of this Markov chain is (4.107) (e) Maximize the entropy rate of the Markov chain over choices of a. What is the maximum entropy rate of the chain? (f) Compare the maximum entropy rate in part (e) with log λ in part (c). Why are the two answers the same? 4.17 Recurrence times are insensitive to distributions . Let X 0 , X 1 , X 2 , … be drawn i.i.d. ~ p ( x ), x χ = {1, 2,…, m }, and let N be the waiting time to the next occurrence of X 0 . Thus N = min n { X n = X 0 ). (a) Show that E N = m . (b) Show that E log N ≤ H ( X ). (c) ( Optional ) Prove part (a) for { X i ) stationary and ergodic. 4.18 Stationary but not ergodic process . A bin has two biased coins, one with probability of heads p and the other with probability of heads 1 − p . One of these coins is chosen at random (i.e., with probability ) and is then tossed n times. Let X denote the identity of the coin that is picked, and let Y 1 and Y 2 denote the results of the first two tosses. (a) Calculate I ( Y 1 ; Y 2 | X ). (b) Calculate I ( X ; Y 1 , Y 2 ). (c) Let be the entropy rate of the Y process (the sequence of coin tosses). Calculate . [ Hint: Relate this to lim H ( X , Y 1 , Y 2 ,…, Y n ).] You can check the answer by considering the behavior as p → . 4.19 Random walk on graph . Consider a random walk on the following graph: (a) Calculate the stationary distribution. (b) What is the entropy rate? (c) Find the mutual information I ( X n +1 ; X n ) assuming that the process is stationary. 4.20 Random walk on chessboard . Find the entropy rate of the Markov chain associated with a random walk of a king on the 3 × 3 chessboard What about the entropy rate of rooks, bishops, and queens? There are two types of bishops. 4.21 Maximal entropy graphs . Consider a random walk on a connected graph with four edges. (a) Which graph has the highest entropy rate? (b) Which graph has the lowest? 4.22 Three-dimensional maze . A bird is lost in a 3 × 3 × 3 cubical maze. The bird flies from room to room going to adjoining rooms with equal probability through each of the walls. For example, the corner rooms have three exits. (a) What is the stationary distribution? (b) What is the entropy rate of this random walk? 4.23 Entropy rate . Let { X i } be a stationary stochastic process with entropy rate H (χ). (a) Argue that H (χ) ≤ H ( X 1 ). (b) What are the conditions for equality? 4.24 Entropy rates . Let { X i } be a stationary process. Let Y i =: ( X i , X i +1 ). Let Z i = ( X 2 i , X 2 i +1 ). Let V i = X 2 i . Consider the entropy rates H ( ), H ( ), H ( ), and H ( V ) of the processes { X i }, { Y i }, { Z i }, and { V i }. What is the inequality relationship ≤, =, or ≥ between each of the pairs listed below? (a) (b) (c) (d) 4.25 Monotonicity (a) Show that I ( X ; Y 1 , Y 2 ,…, Y n ) is nondecreasing in n . (b) Under what conditions is the mutual information constant for all n ? 4.26 Transitions in Markov chains . Suppose that { X i } forms an irreducible Markov chain with transition matrix P and stationary distribution μ. Form the associated “edge process” { Y i } by keeping track only of the transitions. Thus, the new process { Y i } takes values in χ × χ, and Y i = ( X i −1 , X i ). For example, becomes Find the entropy rate of the edge process { Y i }. 4.27 Entropy rate . Let { X i } be a stationary {0, 1}-valued stochastic process obeying where { Z i } is Bernoulli( p )and ⊕ denotes mod 2 addition. What is the entropy rate H (χ)? 4.28 Mixture of processes . Suppose that we observe one of two stochastic processes but don’t know which. What is the entropy rate? Specifically, let X 11 , X 12 , X 13 ,… be a Bernoulli process with parameter p 1 , and let X 21 , X 22 , X 23 , … be Bernoulli( p 2 ). Let and let Y i = X θ i , i = 1, 2,…, be the stochastic process observed. Thus, Y observes the process { X 1 i } or { X 2 i }. Eventually, Y will know which. (a) Is { Y i } stationary? (b) Is { Y i } an i.i.d. process? (c) What is the entropy rate H of { Y i }? (d) Does (e) Is there a code that achieves an expected per-symbol description length E L n → H ? Now let θ i be Bern( ). Observe that Thus, θ is not fixed for all time, as it was in the first part, but is chosen i.i.d. each time. Answer parts (a), (b), (c), (d), (e) for the process { Z i }, labeling the answers (a′), (b′), (c′), (d′), (e′). 4.29 Waiting times . Let X be the waiting time for the first heads to appear in successive flips of a fair coin. For example, Pr{ X = 3} = ( ) 3 . Let S n be the waiting time for the nth head to appear. Thus, where X 1 , X 2 , X 3 , … are Lid according to the distribution above. (a) Is the process { S n } stationary? (b) Calculate H ( S 1 , S 2 ,…, S n ). (c) Does the process { S n have an entropy rate? If so, what is it? If not, why not? (d) What is the expected number of fair coin flips required to generate a random variable having the same distribution as S n ? 4.30 Markov chain transitions Let X 1 be distributed uniformly over the states {0, 1, 2}. Let be a Markov chain with transition matrix P ; thus, P ( X n +1 = j | X n = i ) = P ij , i , j {0, 1, 2}. (a) Is { X n } stationary? (b) Find hint n →∞ H ( X 1 ,…, X n ). Now consider the derived process Z 1 , Z 2 ,…, Z n , where Thus, Z n encodes the transitions, not the states. (c) Find H ( Z 1 , Z 2 ,…, Z n ). (d) Find H ( Z n ) and H ( X n ) for n ≥ 2. (e) Find H ( Z n | Z n −1 ) for n ≥ 2. (f) Are Z n −1 and Z n independent for n ≥ 2? 4.31 Markov . Let { X i } ~ Bernoulli( p ). Consider the associated Markov chain , where Y i = (the number of l’s in the current run of 1’s). For example, if X n = 101110…, we have Y n = 101230…. (a) Find the entropy rate of X n . (b) Find the entropy rate of Y n 4.32 Time symmetry . Let { X n } be a stationary Markov process. We condition on ( X 0 , X 1 ) and look into the past and future. For what index k is Give the argument. 4.33 Chain inequality . Let X 1 → X 2 → X 3 → X 4 form a Markov chain. Show that (4.108) 4.34 Broadcast channel . Let X → Y → ( Z , W ) form a Markov chain [i.e., p ( x , y , z , w ) = p ( x ) p ( y | x ) p ( z , w | y ) for all x , y , z , w ]. Show that (4.109) 4.35 Concavity of second law . Let be a stationary Markov process. Show that H ( X n | X 0 ) is concave in n . Specifically, show that (4.110) Thus, the second difference is negative, establishing that H ( X n | X 0 ) is a concave function of n . HISTORICAL NOTES The entropy rate of a stochastic process was introduced by Shannon [4721, who also explored some of the connections between the entropy rate of the process and the number of possible sequences generated by the process. Since Shannon, there have been a number of results extending the basic theorems of information theory to general stochastic processes. The AEP for a general stationary stochastic process is proved in Chapter 16. Hidden Markov models are used for a number of applications, such as speech recognition [432]. The calculation of the entropy rate for constrained sequences was introduced by Shannon [472]. These sequences are used for coding for magnetic and optical channels [288].

Chapter 5: Data Compression CHAPTER 5 DATA COMPRESSION We now put content in the definition of entropy by establishing the fundamental limit for the compression of information. Data compression can be achieved by assigning short descriptions to the most frequent outcomes of the data source, and necessarily longer descriptions to the less frequent outcomes. For example, in Morse code, the most frequent symbol is represented by a single dot. In this chapter we find the shortest average description length of a random variable. We first define the notion of an instantaneous code and then prove the important Kraft inequality, which asserts that the exponentiated codeword length assignments must look like a probability mass function. Elementary calculus then shows that the expected description length must be greater than or equal to the entropy, the first main result. Then Shannon’s simple construction shows that the expected description length can achieve this bound asymptotically for repeated descriptions. This establishes the entropy as a natural measure of efficient description length. The famous Huffman coding procedure for finding minimum expected description length assignments is provided. Finally, we show that Huffman codes are competitively optimal and that it requires roughly H fair coin flips to generate a sample of a random variable having entropy H . Thus, the entropy is the data compression limit as well as the number of bits needed in random number generation, and codes achieving H turn out to be optimal from many points of view. 5.1 EXAMPLES OF CODES Definition A source code C for a random variable X is a mapping from χ , the range of X , to D *, the set of finite-length strings of symbols from a D -ary alphabet. Let C ( x ) denote the codeword corresponding to x and let l ( x ) denote the length of C ( x ). For example, C (red) = 00, C (blue) = 11 is a source code for χ = {red, blue} with alphabet D = {0, 1}. Definition The expected length L ( C ) of a source code C ( x ) for a random variable X with probability mass function p ( x ) is given by (5.1) where l ( x ) is the length of the codeword associated with x . Without loss of generality, we can assume that the D -ary alphabet is D = {0, 1,…, D − 1}. Some examples of codes follow. Example 5.1.1 Let X be a random variable with the following distribution and codeword assignment: (5.2) The entropy H ( X ) of X is 1.75 bits, and the expected length L ( C ) = El ( X ) of this code is also 1.75 bits. Here we have a code that has the same average length as the entropy. We note that any sequence of bits can be uniquely decoded into a sequence of symbols of X . For example, the bit string 0110111100110 is decoded as 134213. Example 5.1.2 Consider another simple example of a code for a random variable: (5.3) Just as in Example 5.1.1, the code is uniquely decodable. However, in this case the entropy is log 3 = 1.58 bits and the average length of the encoding is 1.66 bits. Here El ( X ) > H ( X ). Example 5.1.3 ( Morse code ) The Morse code is a reasonably efficient code for the English alphabet using an alphabet of four symbols: a dot, a dash, a letter space, and a word space. Short sequences represent frequent letters (e.g., a single dot represents E) and long sequences represent infrequent letters (e.g., Q is represented by “dash,dash,dot,dash”). This is not the optimal representation for the alphabet in four symbols—in fact, many possible codewords are not utilized because the codewords for letters do not contain spaces except for a letter space at the end of every codeword, and no space can follow another space. It is an interesting problem to calculate the number of sequences that can be constructed under these constraints. The problem was solved by Shannon in his original 1948 paper. The problem is also related to coding for magnetic recording, where long strings of 0’s are prohibited [5], [370]. We now define increasingly more stringent conditions on codes. Let x n denote ( x 1 , x 2 ,…, x n ). Definition A code is said to be nonsingular if every element of the range of X maps into a different string in D *; that is, (5.4) Nonsingularity suffices for an unambiguous description of a single value of X . But we usually wish to send a sequence of values of X . In such cases we can ensure decodability by adding a special symbol (a “comma”) between any two codewords. But this is an inefficient use of the special symbol; we can do better by developing the idea of self-punctuating or instantaneous codes. Motivated by the necessity to send sequences of symbols X , we define the extension of a code as follows: Definition The extension C * of a code C is the mapping from finite-length strings of X to finite-length strings of D , defined by (5.5) where C ( x 1 ) C ( x 2 )… C ( x n ) indicates concatenation of the corresponding codewords. Example 5.1.4 If C ( x 1 ) = 00 and C ( x 2 ) = 11, then C ( x 1 x 2 ) = 0011. Definition A code is called uniquely decodable if its extension is nonsingular. In other words, any encoded string in a uniquely decodable code has only one possible source string producing it. However, one may have to look at the entire string to determine even the first symbol in the corresponding source string. Definition A code is called a prefix code or an instantaneous code if no codeword is a prefix of any other codeword. An instantaneous code can be decoded without reference to future codewords since the end of a codeword is immediately recognizable. Hence, for an instantaneous code, the symbol x i can be decoded as soon as we come to the end of the codeword corresponding to it. We need not wait to see the codewords that come later. An instantaneous code is a self-punctuating code ; we can look down the sequence of code symbols and add the commas to separate the codewords without looking at later symbols. For example, the binary string 01011111010 produced by the code of Example 5.1.1 is parsed as 0,10,111,110,10. The nesting of these definitions is shown in Figure 5.1 . To illustrate the differences between the various kinds of codes, consider the examples of codeword assignments C ( x ) to x χ in Table 5.1 . For the nonsingular code, the code string 010 has three possible source sequences: 2 or 14 or 31, and hence the code is not uniquely decodable. The uniquely decodable code is not prefix-free and hence is not instantaneous. To see that it is uniquely decodable, take any code string and start from the beginning. If the first two bits are 00 or 10, they can be decoded immediately. If the first two bits are 11, we must look at the following bits. If the next bit is a 1, the first source symbol is a 3. If the length of the string of 0’s immediately following the 11 is odd, the first codeword must be 110 and the first source symbol must be 4; if the length of the string of 0’s is even, the first source symbol is a 3. By repeating this argument, we can see that this code is uniquely decodable. Sardinas and Patterson [455] have devised a finite test for unique decodability, which involves forming sets of possible suffixes to the codewords and eliminating them systematically. The test is described more fully in Problem 5.5.27. The fact that the last code in Table 5.1 is instantaneous is obvious since no codeword is a prefix of any other. FIGURE 5.1. Classes of codes. TABLE 5.1. Classes of Codes 5.2 KRAFT INEQUALITY We wish to construct instantaneous codes of minimum expected length to describe a given source. It is clear that we cannot assign short codewords to all source symbols and still be prefix-free. The set of codeword lengths possible for instantaneous codes is limited by the following inequality. Theorem 5.2.1 ( Kraft inequality ) For any instantaneous code ( prefix code ) over an alphabet of size D, the codeword lengths l 1 , l 2 ,…, l m must satisfy the inequality (5.6) Conversely, given a set of codeword lengths that satisfy this inequality, there exists an instantaneous code with these word lengths . Proof: Consider a D -ary tree in which each node has D children. Let the branches of the tree represent the symbols of the codeword. For example, the D branches arising from the root node represent the D possible values of the first symbol of the codeword. Then each codeword is represented by a leaf on the tree. The path from the root traces out the symbols of the codeword. A binary example of such a tree is shown in Figure 5.2 . The prefix condition on the codewords implies that no codeword is an ancestor of any other codeword on the tree. Hence, each codeword eliminates its descendants as possible codewords. FIGURE 5.2. Code tree for the Kraft inequality. Let l max be the length of the longest codeword of the set of codewords. Consider all nodes of the tree at level l max . Some of them are codewords, some are descendants of codewords, and some are neither. A codeword at level l i has D l max − l i descendants at level l max . Each of these descendant sets must be disjoint. Also, the total number of nodes in these sets must be less than or equal to D l max . Hence, summing over all the codewords, we have (5.7) or (5.8) which is the Kraft inequality. Conversely, given any set of codeword lengths l 1 , l 2 ,…, l m that satisfy the Kraft inequality, we can always construct a tree like the one in Figure 5.2 . Label the first node (lexicographically) of depth l 1 as codeword 1, and remove its descendants from the tree. Then label the first remaining node of depth l 2 as codeword 2, and so on. Proceeding this way, we construct a prefix code with the specified l 1 , l 2 ,…, l m . We now show that an infinite prefix code also satisfies the Kraft inequality. Theorem 5.2.2 ( Extended Kraft Inequality ) For any countably infinite set of codewords that form a prefix code, the codeword lengths satisfy the extended Kraft inequality , (5.9) Conversely, given any l 1 , l 2 ,… satisfying the extended Kraft inequality, we can construct a prefix code with these codeword lengths . Proof: Let the D -ary alphabet be {0, 1,…, D − 1}. Consider the i th codeword y 1 y 2 … y l i . Let 0. y 1 y 2 … y l i be the real number given by the D -ary expansion (5.10) This codeword corresponds to the interval (5.11) the set of all real numbers whose D -ary expansion begins with 0. y 1 y 2 … y l i . This is a subinterval of the unit interval [0, 1]. By the prefix condition, these intervals are disjoint. Hence, the sum of their lengths has to be less than or equal to 1. This proves that (5.12) Just as in the finite case, we can reverse the proof to construct the code for a given l 1 , l 2 ,… that satisfies the Kraft inequality. First, reorder the indexing so that l 1 ≤ l 2 ≤ …. Then simply assign the intervals in order from the low end of the unit interval. For example, if we wish to construct a binary code with l 1 = 1, l 2 = 2,…, we assign the intervals ,… to the symbols, with corresponding codewords 0, 10,…. In Section 5.5 we show that the lengths of codewords for a uniquely decodable code also satisfy the Kraft inequality. Before we do that, we consider the problem of finding the shortest instantaneous code. 5.3 OPTIMAL CODES In Section 5.2 we proved that any codeword set that satisfies the prefix condition has to satisfy the Kraft inequality and that the Kraft inequality is a sufficient condition for the existence of a codeword set with the specified set of codeword lengths. We now consider the problem of finding the prefix code with the minimum expected length. From the results of Section 5.2, this is equivalent to finding the set of lengths l 1 , l 2 ,…, l m satisfying the Kraft inequality and whose expected length L = ∑ p i l i is less than the expected length of any other prefix code. This is a standard optimization problem: Minimize (5.13) over all integers l 1 , l 2 ,…, l m satisfying (5.14) A simple analysis by calculus suggests the form of the minimizing l * i . We neglect the integer constraint on l i and assume equality in the constraint. Hence, we can write the constrained minimization using Lagrange multipliers as the minimization of (5.15) Differentiating with respect to l i , we obtain (5.16) Setting the derivative to 0, we obtain (5.17) Substituting this in the constraint to find λ, we find λ, = 1/log e D , and hence (5.18) yielding optimal code lengths, (5.19) This noninteger choice of codeword lengths yields expected codeword length (5.20) But since the l i , must be integers, we will not always be able to set the codeword lengths as in (5.19) . Instead, we should choose a set of codeword lengths l i “close” to the optimal set. Rather than demonstrate by calculus that l i * = − log D p i is a global minimum, we verify optimality directly in the proof of the following theorem. Theorem 5.3.1 The expected length L of any instantaneous D-ary code for a random variable X is greater than or equal to the entropy H D ( X ); that is , (5.21) with equality if and only if D −l i = pi . Proof: We can write the difference between the expected length and the entropy as (5.22) (5.23) (5.24) (5.25) (5.26) by the nonnegativity of relative entropy and the fact (Kraft inequality) that c ≥ 1. Hence, L ≤ H with equality if and only if p i = D − l i (i.e., if and only if − log D p i is an integer for all i ). Definition A probability distribution is called D-adic if each of the probabilities is equal to D − n for some n . Thus, we have equality in the theorem if and only if the distribution of X is D -adic. The preceding proof also indicates a procedure for finding an optimal code: Find the D -adic distribution that is closest (in the relative entropy sense) to the distribution of X . This distribution provides the set of codeword lengths. Construct the code by choosing the first available node as in the proof of the Kraft inequality. We then have an optimal code for X . However, this procedure is not easy, since the search for the closest D -adic distribution is not obvious. In the next section we give a good suboptimal procedure (Shannon–Fano coding). In Section 5.6 we describe a simple procedure (Huffman coding) for actually finding the optimal code. 5.4 BOUNDS ON THE OPTIMAL CODE LENGTH We now demonstrate a code that achieves an expected description length L within 1 bit of the lower bound; that is, (5.27) Recall the setup of Section 5.3: We wish to minimize L = ∑ p i l i subject to the constraint that l 1 , l 2 ,…, l m are integers and ∑ D −l i ≥ 1. We proved that the optimal codeword lengths can be found by finding the D -adic probability distribution closest to the distribution of X in relative entropy, that is, by finding the D -adic r ( r i = D −l i / ∑ j D −l j ) minimizing (5.28) The choice of word lengths yields L = H . Since log D 1/ p i may not equal an integer, we round it up to give integer word-length assignments, (5.29) where [ x ] is the smallest integer ≥ x . These lengths satisfy the Kraft inequality since (5.30) This choice of codeword lengths satisfies (5.31) Multiplying by p i and summing over i , we obtain (5.32) Since an optimal code can only be better than this code, we have the following theorem. Theorem 5.4.1 Let l* 1 , l* 2 ,…, l* m be optimal codeword lengths for a source distribution p and a D-ary alphabet, and let L* be the associated expected length of an optimal code . Then (5.33) Proof: Let l i = [log D ]. Then l i satisfies the Kraft inequality and from (5.32) we have (5.34) But since L *, the expected length of the optimal code, is less than L = ∑ p i l i , and since L * ≥ H D from Theorem 5.3.1, we have the theorem. In Theorem 5.4.1 there is an overhead that is at most 1 bit, due to the fact that log1/ is not always an integer. We can reduce the overhead per symbol by spreading it out over many symbols. With this in mind, let us consider a system in which we send a sequence of n symbols from X . The symbols are assumed to be drawn i.i.d. according to p ( x ). We can consider these n symbols to be a supersymbol from the alphabet X n . Define L n to be the expected codeword length per input symbol, that is, if l ( x 1 , x 2 ,…, x n ) is the length of the binary codeword associated with ( x 1 , x 2 ,…, x n ) (for the rest of this section, we assume that D = 2, for simplicity), then (5.35) We can now apply the bounds derived above to the code: (5.36) Since X 1 , X 2 ,…, X n are i.i.d., H ( X 1 , X 2 ,…, X n ) = ∑ H ( X i ) = nH ( X ). Dividing (5.36) by n , we obtain (5.37) Hence, by using large block lengths we can achieve an expected codelength per symbol arbitrarily close to the entropy. We can use the same argument for a sequence of symbols from a stochastic process that is not necessarily i.i.d. In this case, we still have the bound (5.38) Dividing by n again and defining L n to be the expected description length per symbol, we obtain (5.39) If the stochastic process is stationary, then H(X 1 , X 2 ,…, X n )/n → H ( χ ), and the expected description length tends to the entropy rate as n → ∞. Thus, we have the following theorem: Theorem 5.4.2 The minimum expected codeword length per symbol satisfies (5.40) Moreover, if X 1 , X 2 ,…, X n is a stationary stochastic process, (5.41) where H ( χ ) is the entropy rate of the process. This theorem provides another justification for the definition of entropy rate—it is the expected number of bits per symbol required to describe the process. Finally, we ask what happens to the expected description length if the code is designed for the wrong distribution. For example, the wrong distribution may be the best estimate that we can make of the unknown true distribution. We consider the Shannon code assignment l ( x ) = [log1/ q ( x )] designed for the probability mass function q ( x ). Suppose that the true probability mass function is p ( x ). Thus, we will not achieve expected length L ≈ H ( p ) = − ∑ p(x) log p(x) . We now show that the increase in expected description length due to the incorrect distribution is the relative entropy D ( p || q ). Thus, D ( p || q ) has a concrete interpretation as the increase in descriptive complexity due to incorrect information. Theorem 5.4.3 (Wrong code) The expected length under p(x) of the code assignment satisfies (5.42) Proof: The expected codelength is (5.43) (5.44) (5.45) (5.46) (5.47) The lower bound can be derived similarly. Thus, believing that the distribution is q ( x ) when the true distribution is p ( x ) incurs a penalty of D ( p || q ) in the average description length. 5.5 KRAFT INEQUALITY FOR UNIQUELY DECODABLE CODES We have proved that any instantaneous code must satisfy the Kraft inequality. The class of uniquely decodable codes is larger than the class of instantaneous codes, so one expects to achieve a lower expected codeword length if L is minimized over all uniquely decodable codes. In this section we prove that the class of uniquely decodable codes does not offer any further possibilities for the set of codeword lengths than do instantaneous codes. We now give Karush’s elegant proof of the following theorem. Theorem 5.5.1 (McMillan) The codeword lengths of any uniquely decodable D-ary code must satisfy the Kraft inequality (5.48) Conversely, given a set of codeword lengths that satisfy this inequality, it is possible to construct a uniquely decodable code with these codeword lengths . Proof: Consider C k , the k th extension of the code (i.e., the code formed by the concatenation of k repetitions of the given uniquely decodable code C ). By the definition of unique decodability, the k th extension of the code is nonsingular. Since there are only D n different D -ary strings of length n , unique decodability implies that the number of code sequences of length n in the k th extension of the code must be no greater than D n . We now use this observation to prove the Kraft inequality. Let the codeword lengths of the symbols x X be denoted by l ( x ). For the extension code, the length of the code sequence is (5.49) The inequality that we wish to prove is (5.50) The trick is to consider the k th power of this quantity. Thus, (5.51) (5.52) (5.53) by (5.49) . We now gather the terms by word lengths to obtain (5.54) where l max is the maximum codeword length and a ( m ) is the number of source sequences x k mapping into codewords of length m . But the code is uniquely decodable, so there is at most one sequence mapping into each code m -sequence and there are at most D m code m -sequences. Thus, a(m) ≥ D m , and we have (5.55) (5.56) (5.57) and hence (5.58) Since this inequality is true for all k , it is true in the limit as k → ∞. Since ( kl max ) 1/k → 1, we have (5.59) which is the Kraft inequality. Conversely, given any set of l 1 , l 2 ,…, l m satisfying the Kraft inequality, we can construct an instantaneous code as proved in Section 5.2. Since every instantaneous code is uniquely decodable, we have also constructed a uniquely decodable code. Corollary A uniquely decodable code for an infinite source alphabet χ also satisfies the Kraft inequality . Proof: The point at which the preceding proof breaks down for infinite [ X ] is at (5.58) , since for an infinite code l max is infinite. But there is a simple fix to the proof. Any subset of a uniquely decodable code is also uniquely decodable; thus, any finite subset of the infinite set of codewords satisfies the Kraft inequality. Hence, (5.60) Given a set of word lengths l 1 , l 2 ,… that satisfy the Kraft inequality, we can construct an instantaneous code as in Section 5.4. Since instantaneous codes are uniquely decodable, we have constructed a uniquely decodable code with an infinite number of codewords. So the McMillan theorem also applies to infinite alphabets. The theorem implies a rather surprising result–that the class of uniquely decodable codes does not offer any further choices for the set of codeword lengths than the class of prefix codes. The set of achievable codeword lengths is the same for uniquely decodable and instantaneous codes. Hence, the bounds derived on the optimal codeword lengths continue to hold even when we expand the class of allowed codes to the class of all uniquely decodable codes. 5.6 HUFFMAN CODES An optimal (shortest expected length) prefix code for a given distribution can be constructed by a simple algorithm discovered by Huffman [283]. We will prove that any other code for the same alphabet cannot have a lower expected length than the code constructed by the algorithm. Before we give any formal proofs, let us introduce Huffman codes with some examples. Example 5.6.1 Consider a random variable X taking values in the set X = {1, 2, 3, 4, 5} with probabilities 0.25, 0.25, 0.2, 0.15, 0.15, respectively. We expect the optimal binary code for X to have the longest codewords assigned to the symbols 4 and 5. These two lengths must be equal, since otherwise we can delete a bit from the longer codeword and still have a prefix code, but with a shorter expected length. In general, we can construct a code in which the two longest codewords differ only in the last bit. For this code, we can combine the symbols 4 and 5 into a single source symbol, with a probability assignment 0.30. Proceeding this way, combining the two least likely symbols into one symbol until we are finally left with only one symbol, and then assigning codewords to the symbols, we obtain the following table: This code has average length 2.3 bits. Example 5.6.2 Consider a ternary code for the same random variable. Now we combine the three least likely symbols into one supersymbol and obtain the following table: This code has an average length of 1.5 ternary digits. Example 5.6.3 If D ≥ 3, we may not have a sufficient number of symbols so that we can combine them D at a time. In such a case, we add dummy symbols to the end of the set of symbols. The dummy symbols have probability 0 and are inserted to fill the tree. Since at each stage of the reduction, the number of symbols is reduced by D − 1, we want the total number of symbols to be 1 + k ( D − 1), where k is the number of merges. Hence, we add enough dummy symbols so that the total number of symbols is of this form. For example: This code has an average length of 1.7 ternary digits. A proof of the optimality of Huffman coding is given in Section 5.8. 5.7 SOME COMMENTS ON HUFFMAN CODES 1. Equivalence of source coding and 20 questions . We now digress to show the equivalence of coding and the game “20 questions”. Suppose that we wish to find the most efficient series of yes–no questions to determine an object from a class of objects. Assuming that we know the probability distribution on the objects, can we find the most efficient sequence of questions? (To determine an object, we need to ensure that the responses to the sequence of questions uniquely identifies the object from the set of possible objects; it is not necessary that the last question have a “yes” answer.) We first show that a sequence of questions is equivalent to a code for the object. Any question depends only on the answers to the questions before it. Since the sequence of answers uniquely determines the object, each object has a different sequence of answers, and if we represent the yes–no answers by 0’s and 1’s, we have a binary code for the set of objects. The average length of this code is the average number of questions for the questioning scheme. Also, from a binary code for the set of objects, we can find a sequence of questions that correspond to the code, with the average number of questions equal to the expected codeword length of the code. The first question in this scheme becomes: Is the first bit equal to 1 in the object’s codeword? Since the Huffman code is the best source code for a random variable, the optimal series of questions is that determined by the Huffman code. In Example 5.6.1 the optimal first question is: Is X equal to 2 or 3? The answer to this determines the first bit of the Huffman code. Assuming that the answer to the first question is “yes,” the next question should be “Is X equal to 3”, which determines the second bit. However, we need not wait for the answer to the first question to ask the second. We can ask as our second question “Is X equal to 1 or 3?”, determining the second bit of the Huffman code independent of the first. The expected number of questions E Q in this optimal scheme satisfies (5.61) 2. Huffman coding for weighted codewords . Huffman’s algorithm for minimizing ∑ p i l i can be applied to any set of numbers p i ≥ 0, regardless of ∑ p i . In this case, the Huffman code minimizes the sum of weighted code lengths ∑ w i i i rather than the average code length. Example 5.7.1 We perform the weighted minimization using the same algorithm. In this case the code minimizes the weighted sum of the codeword lengths, and the minimum weighted sum is 36. 3. Huffman coding and “slice” questions ( Alphabetic codes ). We have described the equivalence of source coding with the game of 20 questions. The optimal sequence of questions corresponds to an optimal source code for the random variable. However, Huffman codes ask arbitrary questions of the form “Is X A ?” for any set A ⊆ {1, 2,…, m }. Now we consider the game “20 questions” with a restricted set of questions. Specifically, we assume that the elements of χ = {1, 2,…, m } are ordered so that p 1 ≥ p 2 ≥ … ≥ p m and that the only questions allowed are of the form “Is X > a?” for some a . The Huffman code constructed by the Huffman algorithm may not correspond to slices (sets of the form { x : x < a }). If we take the codeword lengths ( l 1 ≤ l 2 ≤ … ≤ l m , by Lemma 5.8.1) derived from the Huffman code and use them to assign the symbols to the code tree by taking the first available node at the corresponding level, we will construct another optimal code. However, unlike the Huffman code itself, this code is a slice code , since each question (each bit of the code) splits the tree into sets of the form { x : x > a } and { x : x < a }. We illustrate this with an example. Example 5.7.2 Consider the first example of Section 5.6. The code that was constructed by the Huffman coding procedure is not a slice code. But using the codeword lengths from the Huffman procedure, namely, {2, 2, 2, 3, 3}, and assigning the symbols to the first available node on the tree, we obtain the following code for this random variable: It can be verified that this code is a slice code, also known as an alphabetic code because the codewords are ordered alphabetically. 4. Huffman codes and Shannon codes . Using codeword lengths of Flog (which is called Shannon coding ) may be much worse than the optimal code for some particular symbol. For example, consider two symbols, one of which occurs with probability 0.9999 and the other with probability 0.0001. Then using codeword lengths of Flog gives codeword lengths of 1 bit and 14 bits, respectively. The optimal codeword length is obviously 1 bit for both symbols. Hence, the codeword for the infrequent symbol is much longer in the Shannon code than in the optimal code. Is it true that the codeword lengths for an optimal code are always less than ? The following example illustrates that this is not always true. Example 5.7.3 Consider a random variable X with a distribution . The Huffman coding procedure results in codeword lengths of (2, 2, 2, 2) or (1, 2, 3, 3) [depending on where one puts the merged probabilities, as the reader can verify (Problem 5.5.12)]. Both these codes achieve the same expected codeword length. In the second code, the third symbol has length 3, which is greater than [log 1/ p 3 ]. Thus, the codeword length for a Shannon code could be less than the codeword length of the corresponding symbol of an optimal (Huffman) code. This example also illustrates the fact that the set of codeword lengths for an optimal code is not unique (there may be more than one set of lengths with the same expected value). Although either the Shannon code or the Huffman code can be shorter for individual symbols, the Huffman code is shorter on average. Also, the Shannon code and the Huffman code differ by less than 1 bit in expected codelength (since both lie between H and H + 1. ) 5. Fano codes . Fano proposed a suboptimal procedure for constructing a source code, which is similar to the idea of slice codes. In his method we first order the probabilities in decreasing order. Then we choose k such that is minimized. This point divides the source symbols into two sets of almost equal probability. Assign 0 for the first bit of the upper set and 1 for the lower set. Repeat this process for each subset. By this recursive procedure, we obtain a code for each source symbol. This scheme, although not optimal in general, achieves L ( C ) ≤ H ( X ) + 2. (See [282].) 5.8 OPTIMALITY OF HUFFMAN CODES We prove by induction that the binary Huffman code is optimal. It is important to remember that there are many optimal codes: inverting all the bits or exchanging two codewords of the same length will give another optimal code. The Huffman procedure constructs one such optimal code. To prove the optimality of Huffman codes, we first prove some properties of a particular optimal code. Without loss of generality, we will assume that the probability masses are ordered, so that p 1 ≥ p 2 ≥ … ≥ p m . Recall that a code is optimal if ∑ p i l i is minimal. Lemma 5.8.1 For any distribution, there exists an optimal instantaneous code (with minimum expected length) that satisfies the following properties: 1. The lengths are ordered inversely with the probabilities (i.e., if p j > p k , then l j ≤ l k ) . 2. The two longest codewords have the same length . 3. Two of the longest codewords differ only in the last bit and correspond to the two least likely symbols . Proof: The proof amounts to swapping, trimming, and rearranging, as shown in Figure 5.3 . Consider an optimal code C m : FIGURE 5.3. Properties of optimal codes. We assume that p 1 ≥ p 2 ≥ … ≥ p m . A possible instantaneous code is given in ( a ). By trimming branches without siblings, we improve the code to ( b ). We now rearrange the tree as shown in ( c ), so that the word lengths are ordered by increasing length from top to bottom. Finally, we swap probability assignments to improve the expected depth of the tree, as shown in ( d ). Every optimal code can be rearranged and swapped into canonical form as in ( d ), where l1 ≤ l2 ≤ … ≤ l m and l m − 1 = l m , and the last two codewords differ only in the last bit. If p j > p k , then l j < l k . Here we swap codewords. Consider C′ m , with the codewords j and k of C m interchanged. Then (5.62) (5.63) (5.64) But p j − p k > 0, and since C m is optimal, L ( C′ m ) − L ( C m ) ≥ 0. Hence, we must have l k ≥ l j . Thus, C m itself satisfies property 1. The two longest codewords are of the same length . Here we trim the codewords. If the two longest codewords are not of the same length, one can delete the last bit of the longer one, preserving the prefix property and achieving lower expected codeword length. Hence, the two longest codewords must have the same length. By property 1, the longest codewords must belong to the least probable source symbols. The two longest codewords differ only in the last bit and correspond to the two least likely symbols . Not all optimal codes satisfy this property, but by rearranging, we can find an optimal code that does. If there is a maximal-length codeword without a sibling, we can delete the last bit of the codeword and still satisfy the prefix property. This reduces the average codeword length and contradicts the optimality of the code. Hence, every maximal-length codeword in any optimal code has a sibling. Now we can exchange the longest codewords so that the two lowest-probability source symbols are associated with two siblings on the tree. This does not change the expected length, ∑ p i l i . Thus, the codewords for the two lowest-probability source symbols have maximal length and agree in all but the last bit. Summarizing, we have shown that if p 1 ≥ p 2 ≥ … ≥ p m , there exists an optimal code with l 1 ≤ l 2 ≤ … ≤ l m −1 = l m , and codewords C ( x m −1 ) and C ( x m ) that differ only in the last bit. Thus, we have shown that there exists an optimal code satisfying the properties of the lemma. We call such codes canonical codes. For any probability mass function for an alphabet of size m , p = (p1, p2,…, p m ) with p 1 ≥ p 2 ≥ …≥ p m , we define the Huffman reduction p ′ = ( p 1 , p 2 ,…, p m −2 , p m −1 + p m ) over an alphabet of size m − 1 ( Figure 5.4 ). Let C * m −1 ( p ′) be an optimal code for p ′, and let C* m ( p ) be the canonical optimal code for p . FIGURE 5.4. Induction step for Huffman coding. Let p 1 ≥ p 2 ≥ …≥ p 5 . A canonical optimal code is illustrated in ( a ). Combining the two lowest probabilities, we obtain the code in ( b ). Rearranging the probabilities in decreasing order, we obtain the canonical code in ( c ) for m − 1 symbols. The proof of optimality will follow from two constructions: First, we expand an optimal code for p ′ to construct a code for p , and then we condense an optimal canonical code for p to construct a code for the Huffman reduction p′ . Comparing the average codeword lengths for the two -codes establishes that the optimal code for p can be obtained by extending the optimal code for p′ . From the optimal code for p′ , we construct an extension code for m elements as follows: Take the codeword in C m − 1 * corresponding to weight p m − 1 + p m and extend it by adding a 0 to form a codeword for symbol m − 1 and by adding 1 to form a codeword for symbol m . The code construction is illustrated as follows: (5.65) Calculation of the average length ∑ i p′ i l′ i shows that (5.66) Similarly, from the canonical code for p , we construct a code for p′ by merging the codewords for the two lowest-probability symbols m − 1 and m with probabilities p m −1 and p m , which are siblings by the properties of the canonical code. The new code for p′ has average length (5.67) (5.68) (5.69) Adding (5.66) and (5.69) together, we obtain (5.70) or (5.71) Now examine the two terms in (5.71) . By assumption, since L *( p ′) is the optimal length for p ′, we have L ( p ′) − L *( p ′) ≥ 0. Similarly, the length of the extension of the optimal code for p ′ has to have an average length at least as large as the optimal code for p [i.e., L ( p ) − L *( p ) 0]. But the sum of two nonnegative terms can only be 0 if both of them are 0, which implies that L ( p ) = L * ( p ) (i.e., the extension of the optimal code for p ′ is optimal for p ). Consequently, if we start with an optimal code for p ′ with m − 1 symbols and construct a code for m symbols by extending the codeword corresponding to p m −1 + p m , the new code is also optimal. Starting with a code for two elements, in which case the optimal code is obvious, we can by induction extend this result to prove the following theorem. Theorem 5.8.1 Huffman coding is optimal; that is, if C* is a Huffman code and C′ is any other uniquely decodable code, L(C*) ≤ L(C′ ). Although we have proved the theorem for a binary alphabet, the proof can be extended to establishing optimality of the Huffman coding algorithm for a D -ary alphabet as well. Incidentally, we should remark that Huffman coding is a “greedy” algorithm in that it coalesces the two least likely symbols at each stage. The proof above shows that this local optimality ensures global optimality of the final code. 5.9 SHANNON–FANO–ELIAS CODING In Section 5.4 we showed that the codeword lengths satisfy the Kraft inequality and can therefore be used to construct a uniquely decodable code for the source. In this section we describe a simple constructive procedure that uses the cumulative distribution function to allot codewords. Without loss of generality, we can take χ = {1, 2,…, m }. Assume that p ( x ) > 0 for all x . The cumulative distribution function F(x ) is defined as (5.72) This function is illustrated in Figure 5.5 . Consider the modified cumulative distribution function FIGURE 5.5. Cumulative distribution function and Shannon–Fano–Elias coding. (5.73) where (x ) denotes the sum of the probabilities of all symbols less than x plus half the probability of the symbol x . Since the random variable is discrete, the cumulative distribution function consists of steps of size p ( x ). The value of the function (x ) is the midpoint of the step corresponding to x . Since all the probabilities are positive, ( a ) ≠ ( b ) if a ≠ b, and hence we can determine x if we know ( x ). Merely look at the graph of the cumulative distribution function and find the corresponding x . Thus, the value of ( x ) can be used as a code for x . But, in general, ( x ) is a real number expressible only by an infinite number of bits. So it is not efficient to use the exact value of ( x ) as a code for x . If we use an approximate value, what is the required accuracy? Assume that we truncate ( x ) to l (x) bits (denoted by . Thus, we use the first l ( x ) bits of ( x ) as a code for x . By definition of rounding off, we have (5.74) If , then (5.75) and therefore lies within the step corresponding to x . Thus, l ( x ) bits suffice to describe x . In addition to requiring that the codeword identify the corresponding symbol, we also require the set of codewords to be prefix-free. To check whether the code is prefix-free, we consider each codeword z 1 z 2 … z i to represent not a point but the interval . The code is prefix-free if and only if the intervals corresponding to codewords are disjoint. We now verify that the code above is prefix-free. The interval corresponding to any codeword has length 2 −l(x) , which is less than half the height of the step corresponding to x by (5.75) . The lower end of the interval is in the lower half of the step. Thus, the upper end of the interval lies below the top of the step, and the interval corresponding to any codeword lies entirely within the step corresponding to that symbol in the cumulative distribution function. Therefore, the intervals corresponding to different codewords are disjoint and the code is prefix-free. Note that this procedure does not require the symbols to be ordered in terms of probability. Another procedure that uses the ordered probabilities is described in Problem 5.5.28. Since we use bits to represent x , the expected length of this code is (5.76) Thus, this coding scheme achieves an average codeword length that is within 2 bits of the entropy. Example 5.9.1 We first consider an example where all the probabilities are dyadic. We construct the code in the following table: In this case, the average codeword length is 2.75 bits and the entropy is 1.75 bits. The Huffman code for this case achieves the entropy bound. Looking at the codewords, it is obvious that there is some inefficiency—for example, the last bit of the last two codewords can be omitted. But if we remove the last bit from all the codewords, the code is no longer prefix-free. Example 5.9.2 We now give another example for construction of the Shannon–Fano–Elias code. In this case, since the distribution is not dyadic, the representation of F ( x ) in binary may have an infinite number of bits. We denote 0.01010101 … by . We construct the code in the following table: The above code is 1.2 bits longer on the average than the Huffman code for this source (Example 5.6.1). The Shannon–Fano–Elias coding procedure can also be applied to sequences of random variables. The key idea is to use the cumulative distribution function of the sequence, expressed to the appropriate accuracy, as a code for the sequence. Direct application of the method to blocks of length n would require calculation of the probabilities and cumulative distribution function for all sequences of length n , a calculation that would grow exponentially with the block length. But a simple trick ensures that we can calculate both the probability and the cumulative density function sequentially as we see each symbol in the block, ensuring that the calculation grows only linearly with the block length. Direct application of Shannon–Fano–Elias coding would also need arithmetic whose precision grows with the block size, which is not practical when we deal with long blocks. In Chapter 13 we describe arithmetic coding, which is an extension of the Shannon–Fano–Elias method to sequences of random variables that encodes using fixed-precision arithmetic with a complexity that is linear in the length of the sequence. This method is the basis of many practical compression schemes such as those used in the JPEG and FAX compression standards. 5.10 COMPETITIVE OPTIMALITY OF THE SHANNON CODE We have shown that Huffman coding is optimal in that it has minimum expected length. But what does that say about its performance on any particular sequence? For example, is it always better than any other code for all sequences? Obviously not, since there are codes that assign short codewords to infrequent source symbols. Such codes will be better than the Huffman code on those source symbols. To formalize the question of competitive optimality, consider the following two-person zero-sum game: Two people are given a probability distribution and are asked to design an instantaneous code for the distribution. Then a source symbol is drawn from this distribution, and the payoff to player A is 1 or −1, depending on whether the codeword of player A is shorter or longer than the codeword of player B. The payoff is 0 for ties. Dealing with Huffman code lengths is difficult, since there is no explicit expression for the codeword lengths. Instead, we consider the Shannon code with codeword lengths . In this case, we have the following theorem. Theorem 5.10.1 Let l ( x ) be the codeword lengths associated with the Shannon code, and let l′ ( x ) be the codeword lengths associated with any other uniquely decodable code. Then (5.77) For example, the probability that l′ ( x ) is 5 or more bits shorter than l ( x ) is less than . Proof (5.78) (5.79) (5.80) (5.81) (5.82) (5.83) (5.84) since 1 by the Kraft inequality. Hence, no other code can do much better than the Shannon code most of the time. We now strengthen this result. In a game-theoretic setting, one would like to ensure that 1 ( x ) < l′ ( x ) more often than 1 ( x ) > l′ ( x ). The fact that 1 ( x ) < l′ ( x ) + 1 with probability ≥ 1/2 does not ensure this. We now show that even under this stricter criterion, Shannon coding is optimal. Recall that the probability mass function p ( x ) is dyadic if log is an integer for all x . Theorem 5.10.2 For a dyadic probability mass function p ( x ), let be the word lengths of the binary Shannon code for the source, and let l′ ( x ) be the lengths of any other uniquely decodable binary code for the source. Then (5.85) with equality if and only if l′(x) = l(x) for all x. Thus, the code length assignment is uniquely competitively optimal . Proof: Define the function sgn( t ) as follows: (5.86) Then it is easy to see from Figure 5.6 that FIGURE 5.6. Sgn function and a bound. (5.87) Note that though this inequality is not satisfied for all t , it is satisfied at all integer values of t . We can now write (5.88) (5.89) (5.90) (5.91) (5.92) (5.93) (5.94) (5.95) (5.96) where (a) follows from the bound on sgn( x ) and (b) follows from the fact that l′ ( x ) satisfies the Kraft inequality. We have equality in the above chain only if we have equality in (a) and (b). We have equality in the bound for sgn(t) only if t is 0 or 1 [i.e., l ( x ) = l′ ( x ) or l ( x ) = l′ ( x ) + 1]. Equality in (b) implies that l′ ( x ) satisfies the Kraft inequality with equality. Combining these two facts implies that l ( x ) = l ( x ) for all x . Corollary For nondyadic probability mass functions , (5.97) where and l′ ( x ) is any other code for the source . Proof: Along the same lines as the preceding proof. Hence we have shown that Shannon coding is optimal under a variety of criteria; it is robust with respect to the payoff function. In particular, for dyadic p, E(l − l′ ) ≤ 0, E sgn( l − l ′) ≤ 0, and by use of inequality (5.87) , Ef ( l − l ′) ≤ 0 for any function f satisfying f (t ) ≤ 2 t − 1, t = 0, ±1, ±2, …. 5.11 GENERATION OF DISCRETE DISTRIBUTIONS FROM FAIR COINS In the early sections of this chapter we considered the problem of representing a random variable by a sequence of bits such that the expected length of the representation was minimized. It can be argued (Problem 5.5.29) that the encoded sequence is essentially incompressible and therefore has an entropy rate close to 1 bit per symbol. Therefore, the bits of the encoded sequence are essentially fair coin flips. In this section we take a slight detour from our discussion of source coding and consider the dual question. How many fair coin flips does it take to generate a random variable X drawn according to a specified probability mass function p? We first consider a simple example. Example 5.11.1 Given a sequence of fair coin tosses (fair bits), suppose that we wish to generate a random variable X with distribution (5.98) It is easy to guess the answer. If the first bit is 0, we let X = a . If the first two bits are 10, we let X = b . If we see 11, we let X = c . It is clear that X has the desired distribution. We calculate the average number of fair bits required for generating the random variable, in this case as bits. This is also the entropy of the distribution. Is this unusual? No, as the results of this section indicate. The general problem can now be formulated as follows. We are given a sequence of fair coin tosses Z 1 , Z 2 ,…, and we wish to generate a discrete random variable X χ = {1, 2, … m } with probability mass function p = ( p 1 , p 2 ,…, p m ). Let the random variable T denote the number of coin flips used in the algorithm. We can describe the algorithm mapping strings of bits Z 1 , Z 2 ,…, to possible outcomes X by a binary tree. The leaves of the tree are marked by output symbols X , and the path to the leaves is given by the sequence of bits produced by the fair coin. For example, the tree for the distribution is shown in Figure 5.7 . FIGURE 5.7. Tree for generation of the distribution . The tree representing the algorithm must satisfy certain properties: 1. The tree should be complete (i.e., every node is either a leaf or has two descendants in the tree). The tree may be infinite, as we will see in some examples. 2. The probability of a leaf at depth k is 2 − k . Many leaves may be labeled with the same output symbol—the total probability of all these leaves should equal the desired probability of the output symbol. 3. The expected number of fair bits ET required to generate X is equal to the expected depth of this tree. There are many possible algorithms that generate the same output distribution. For example, the mapping 00 → a , 01 → b , 10 → c, 11 → a also yields the distribution . However, this algorithm uses two fair bits to generate each sample and is therefore not as efficient as the mapping given earlier, which used only 1.5 bits per sample. This brings up the question: What is the most efficient algorithm to generate a given distribution, and how is this related to the entropy of the distribution? We expect that we need at least as much randomness in the fair bits as we produce in the output samples. Since entropy is a measure of randomness, and each fair bit has an entropy of 1 bit, we expect that the number of fair bits used will be at least equal to the entropy of the output. This is proved in the following theorem. We will need a simple lemma about trees in the proof of the theorem. Let y denote the set of leaves of a complete tree. Consider a distribution on the leaves such that the probability of a leaf at depth k on the tree is 2 − k . Let Y be a random variable with this distribution. Then we have the following lemma. Lemma 5.11.1 For any complete tree, consider a probability distribution on the leaves such that the probability of a leaf at depth k is 2 − k . Then the expected depth of the tree is equal to the entropy of this distribution . Proof: The expected depth of the tree (5.99) and the entropy of the distribution of Y is (5.100) (5.101) where k(y ) denotes the depth of leaf y . Thus, (5.102) Theorem 5.11.1 For any algorithm generating X, the expected number of fair bits used is greater than the entropy H (X), that is , (5.103) Proof: Any algorithm generating X from fair bits can be represented by a complete binary tree. Label all the leaves of this tree by distinct symbols y y = (1, 2, …}. If the tree is infinite, the alphabet is also infinite. Now consider the random variable Y defined on the leaves of the tree, such that for any leaf y at depth k , the probability that Y = y is 2 − k . By Lemma 5.11.1, the expected depth of this tree is equal to the entropy of Y : (5.104) Now the random variable X is a function of Y (one or more leaves map onto an output symbol), and hence by the result of Problem 2.4, we have (5.105) Thus, for any algorithm generating the random variable X , we have (5.106) The same argument answers the question of optimality for a dyadic distribution. Theorem 5.11.2 Let the random variable χ have a dyadic distribution. The optimal algorithm to generate χ from fair coin flips requires an expected number of coin tosses precisely equal to the entropy: (5.107) Proof: Theorem 5.11.1 shows that we need at least H ( x ) bits to generate X . For the constructive part, we use the Huffman code tree for X as the tree to generate the random variable. For a dyadic distribution, the Huffman code is the same as the Shannon code and achieves the entropy bound. For any x X , the depth of the leaf in the code tree corresponding to x is the length of the corresponding codeword, which is log . Hence, when this code tree is used to generate X , the leaf will have a probability . The expected number of coin flips is the expected depth of the tree, which is equal to the entropy (because the distribution is dyadic). Hence, for a dyadic distribution, the optimal generating algorithm achieves (5.108) What if the distribution is not dyadic? In this case we cannot use the same idea, since the code tree for the Huffman code will generate a dyadic distribution on the leaves, not the distribution with which we started. Since all the leaves of the tree have probabilities of the form 2 − k , it follows that we should split any probability p i that is not of this form into atoms of this form. We can then allot these atoms to leaves on the tree. For example, if one of the outcomes x has probability p ( x ) = , we need only one atom (leaf of the tree at level 2), but if , we need three atoms, one each at levels 1, 2, and 3 of the tree. To minimize the expected depth of the tree, we should use atoms with as large a probability as possible. So given a probability p i , we find the largest atom of the form 2 − k that is less than p i , and allot this atom to the tree. Then we calculate the remainder and find that largest atom that will fit in the remainder. Continuing this process, we can split all the probabilities into dyadic atoms. This process is equivalent to finding the binary expansions of the probabilities. Let the binary expansion of the probability p i be (5.109) where or 0. Then the atoms of the expansion are the {pi (i) : i = 1, 2, … m, j ≥ 1]. Since ∑ i pi = 1, the sum of the probabilities of these atoms is 1. We will allot an atom of probability 2 − j to a leaf at depth j on the tree. The depths of the atoms satisfy the Kraft inequality, and hence by Theorem 5.2.1, we can always construct such a tree with all the atoms at the right depths. We illustrate this procedure with an example. Example 5.11.2 Let X have the distribution (5.110) We find the binary expansions of these probabilities: (5.111) (5.112) Hence, the atoms for the expansion are (5.113) (5.114) These can be allotted to a tree as shown in Figure 5.8 . FIGURE 5.8. Tree to generate a distribution. This procedure yields a tree that generates the random variable X . We have argued that this procedure is optimal (gives a tree of minimum expected depth), but we will not give a formal proof. Instead, we bound the expected depth of the tree generated by this procedure. Theorem 5.11.3 The expected number of fair bits required by the optimal algorithm to generate a random variable X lies between H(X) and H(X) + 2: (5.115) Proof: The lower bound on the expected number of coin tosses is proved in Theorem 5.11.1. For the upper bound, we write down an explicit expression for the expected number of coin tosses required for the procedure described above. We split all the probabilities ( p 1 , p 2 ,…, p m ) into dyadic atoms, for example, (5.116) and so on. Using these atoms (which form a dyadic distribution), we construct a tree with leaves corresponding to each of these atoms. The number of coin tosses required to generate each atom is its depth in the tree, and therefore the expected number of coin tosses is the expected depth of the tree, which is equal to the entropy of the dyadic distribution of the atoms. Hence, (5.117) where Y has the distribution, Now since X is a function of Y , we have (5.118) and our objective is to show that H(Y|X ) < 2. We now give an algebraic proof of this result. Expanding the entropy of Y , we have (5.119) (5.120) since each of the atoms is either 0 or 2 − k for some k . Now consider the term in the expansion corresponding to each i , which we shall call Ti : (5.121) We can find an n such that 2 −(n−1) > p i ≥ 2 −n , or (5.122) Then it follows that only if j ≥ n , so that we can rewrite (5.121) as (5.123) We use the definition of the atom to write p i as (5.124) To prove the upper bound, we first show that Ti < − p i log p i + 2 p i . Consider the difference (5.125) (5.126) (5.127) (5.128) (5.129) (5.130) (5.131) (5.132) (5.133) where (a) follows from (5.122) , (b) follows from a change of variables for the summation, and (c) follows from increasing the range of the summation. Hence, we have shown that (5.134) Since ET = ∑ i Ti , it follows immediately that (5.135) completing the proof of the theorem. Thus, an average of H ( X ) + 2 coin flips suffice to simulate a random variable X . SUMMARY Kraft inequality. Instantaneous codes . McMillan inequality. Uniquely decodable codes . Entropy bound on data compression (5.136) Shannon code (5.137) (5.138) Huffman code (5.139) (5.140) Wrong code. : (5.141) Stochastic processes (5.142) Stationary processes (5.143) Competitive optimality. Shannon code versus any other code l ′ ( x ): (5.144) PROBLEMS 5.1 Uniquely decodable and instantaneous codes . Let be the expected value of the 100th power of the word lengths associated with an encoding of the random variable X . Let L 1 = min L over all instantaneous codes; and let L 2 = min L over all uniquely decodable codes. What inequality relationship exists between L 1 and L 2 ? 5.2 How many fingers has a Martian ? Let The S i ’s are encoded into strings from a D -symbol output alphabet in a uniquely decodable manner. If m = 6 and the codeword lengths are (l 1 , l 2 ,…, l 6 ) = (1, 1, 2, 3, 2, 3), find a good lower bound on D . You may wish to explain the title of the problem. 5.3 Slackness in the Kraft inequality . An instantaneous code has word lengths l 1 , l 2 , which satisfy the strict inequality The code alphabet is D = {0, 1, 2,…, D − 1}. Show that there exist arbitrarily long sequences of code symbols in D * which cannot be decoded into sequences of codewords. 5.4 Huffman coding . Consider the random variable (a) Find a binary Huffman code for X . (b) Find the expected code length for this encoding. (c) Find a ternary Huffman code for X . 5.5 More Huffman codes . Find the binary Huffman code for the source with probabilities . Argue that this code is also optimal for the source with probabilities . 5.6 Bad codes . Which of these codes cannot be Huffman codes for any probability assignment? (a) {0, 10, 11} (b) {00, 01, 10, 110} (c) {01, 10} 5.7 Huffman 20 questions . Consider a set of n objects. Let X i = 1 or 0 accordingly as the i th object is good or defective. Let X i , X 2 ,…, X n be independent with Pr{ X i = 1} = p i and p 1 > p 2 > … > p n > 1/2. We are asked to determine the set of all defective objects. Any yes–no question you can think of is admissible. (a) Give a good lower bound on the minimum average number of questions required. (b) If the longest sequence of questions is required by nature’s answers to our questions, what (in words) is the last question we should ask? What two sets are we distinguishing with this question? Assume a compact (minimum average length) sequence of questions. (c) Give an upper bound (within one question) on the minimum average number of questions required. 5.8 Simple optimum compression of a Markov source . Consider the three-state Markov process U 1 , U 2 , … having transition matrix Thus, the probability that S 1 follows S 3 is equal to zero. Design three codes C 1 , C 2 , C 3 (one for each state 1, 2 and 3, each code mapping elements of the set of S i ’s into sequences of 0’s and 1’s, such that this Markov process can be sent with maximal compression by the following scheme: (a) Note the present symbol X n = i . (b) Select code C i . (c) Note the next symbol X n +1 = j and send the codeword in C i corresponding to j . (d) Repeat for the next symbol. What is the average message length of the next symbol conditioned on the previous state X n = i using this coding scheme? What is the unconditional average number of bits per source symbol? Relate this to the entropy rate H ( u ) of the Markov chain. 5.9 Optimal code lengths that require one bit above entropy . The source coding theorem shows that the optimal code for a random variable X has an expected length less than H ( X ) + 1. Give an example of a random variable for which the expected length of the optimal code is close to H ( X ) + 1 [i.e., for any ε > 0, construct a distribution for which the optimal code has L > H ( X ) + 1 − ]. 5.10 Ternary codes that achieve the entropy bound . A random variable X takes on m values and has entropy H ( X ). An instantaneous ternary code is found for this source, with average length (5.145) (a) Show that each symbol of X has a probability of the form 3 −i for some i . (b) Show that m is odd. 5.11 Suffix condition . Consider codes that satisfy the suffix condition, which says that no codeword is a suffix of any other codeword. Show that a suffix condition code is uniquely decodable, and show that the minimum average length over all codes satisfying the suffix condition is the same as the average length of the Huffman code for that random variable. 5.12 Shannon codes and Huffman codes . Consider a random variable X that takes on four values with probabilities , (a) Construct a Huffman code for this random variable. (b) Show that there exist two different sets of optimal lengths for the codewords; namely, show that codeword length assignments (1, 2, 3, 3) and (2, 2, 2, 2) are both optimal. (c) Conclude that there are optimal codes with codeword lengths for some symbols that exceed the Shannon code length . 5.13 Twenty questions . Player A chooses some object in the universe, and player B attempts to identify the object with a series of yes–no questions. Suppose that player B is clever enough to use the code achieving the minimal expected length with respect to player A’s distribution. We observe that player B requires an average of 38.5 questions to determine the object. Find a rough lower bound to the number of objects in the universe. 5.14 Huffman code . Find the (a) binary and (b) ternary Huffman codes for the random variable X with probabilities (c) Calculate L = ∑ p i l i in each case. 5.15 Huffman codes (a) Construct a binary Huffman code for the following distribution on five symbols: p = (0.3, 0.3, 0.2, 0.1, 0.1). What is the average length of this code? (b) Construct a probability distribution p ′ on five symbols for which the code that you constructed in part (a) has an average length (under p ′) equal to its entropy H ( p ′). 5.16 Huffman codes . Consider a random variable X that takes six values (A, B, C, D, E , F) with probabilities 0.5, 0.25, 0.1, 0.05, 0.05, and 0.05, respectively. (a) Construct a binary Huffman code for this random variable. What is its average length? (b) Construct a quaternary Huffman code for this random variable [i.e., a code over an alphabet of four symbols (call them a, b, c and d )]. What is the average length of this code? (c) One way to construct a binary code for the random variable is to start with a quaternary code and convert the symbols into binary using the mapping a → 00, b → 01, c → 10, and d → 11 . What is the average length of the binary code for the random variable above constructed by this process? (d) For any random variable X , let L H be the average length of the binary Huffman code for the random variable, and let L QB be the average length code constructed by first building a quaternary Huffman code and converting it to binary. Show that (5.146) (e) The lower bound in the example is tight. Give an example where the code constructed by converting an optimal quaternary code is also the optimal binary code. (f) The upper bound (i.e., L QB < L H + 2) is not tight. In fact, a better bound is L QB < L H + 1. Prove this bound, and provide an example where this bound is tight. 5.17 Data compression . Find an optimal set of binary codeword lengths l 1 , l 2 ,… (minimizing ∑ p i l i ) for an instantaneous code for each of the following probability mass functions: (a) (b) 5.18 Classes of codes . Consider the code {0, 01}. (a) Is it instantaneous? (b) Is it uniquely decodable? (c) Is it nonsingular? 5.19 The game of Hi-Lo (a) A computer generates a number X according to a known probability mass function p ( x ), x {1, 2,…, 100}. The player asks a question, “Is X = i ?” and is told “Yes,” “You’re too high,” or “You’re too low.” He continues for a total of six questions. If he is right (i.e., he receives the answer “Yes”) during this sequence, he receives a prize of value v ( X ). How should the player proceed to maximize his expected winnings? (b) Part (a) doesn’t have much to do with information theory. Consider the following variation: X ~ p ( x ), prize = v ( x ), p ( x ) known, as before. But arbitrary yes–no questions are asked sequentially until X is determined. (“Determined” doesn’t mean that a “Yes” answer is received.) Questions cost 1 unit each. How should the player proceed? What is the expected payoff? (c) Continuing part (b), what if v ( x ) is fixed but p ( x ) can be chosen by the computer (and then announced to the player)? The computer wishes to minimize the player’s expected return. What should p ( x ) be? What is the expected return to the player? 5.20 Huffman codes with costs . Words such as “Run!”, “Help!”, and “Fire!” are short, not because they are used frequently, but perhaps because time is precious in the situations in which these words are required. Suppose that X = i with probability p i , i = 1, 2,…, m . Let l i be the number of binary symbols in the codeword associated with X = i , and let c i denote the cost per letter of the codeword when X = i . Thus, the average cost C of the description of X is . (a) Minimize C over all l 1 , l 2 ,…, lm such that ∑ 2 −1i ≤ 1. Ignore any implied integer constraints on l i . Exhibit the minimizing, l 1 *, l 2 *,…, lm * and the associated minimum value C* . (b) How would you use the Huffman code procedure to minimize C over all uniquely decodable codes? Let C Huffman denote this minimum. (c) Can you show that 5.21 Conditions for unique decodability. . Prove that a code C is uniquely decodable if (and only if) the extension is a one-to-one mapping from χ k to D* for every k ≥ 1. (The “only if part is obvious.) 5.22 Average length of an optimal code . Prove that L ( p i ,…, p m ), the average codeword length for an optimal D -ary prefix code for probabilities { p i ,… p m } , is a continuous function of p i , …, p m . This is true even though the optimal code changes discontinuously as the probabilities vary. 5.23 Unused code sequences . Let C be a variable-length code that satisfies the Kraft inequality with an equality but does not satisfy the prefix condition. (a) Prove that some finite sequence of code alphabet symbols is not the prefix of any sequence of codewords. (b) ( Optional ) Prove or disprove: C has infinite decoding delay. 5.24 Optimal codes for uniform distributions . Consider a random variable with m equiprobable outcomes. The entropy of this information source is obviously log 2 m bits. (a) Describe the optimal instantaneous binary code for this source and compute the average codeword length L m . (b) For what values of m does the average codeword length L m equal the entropy H = log 2 m ? (c) We know that L < H + 1 for any probability distribution. The redundancy of a variable-length code is defined to be p = L − H . For what value(s) of m , where 2 k ≤ m ≤ 2 k +1 , is the redundancy of the code maximized? What is the limiting value of this worst-case redundancy as m → ∞? 5.25 Optimal codeword lengths . Although the codeword lengths of an optimal variable-length code are complicated functions of the message probabilities { p 1 , p 2 ,…, p m ), it can be said that less probable symbols are encoded into longer codewords. Suppose that the message probabilities are given in decreasing order, p 1 > p 2 ≥ … ≥ p m . (a) Prove that for any binary Huffman code, if the most probable message symbol has probability p 1 > , that symbol must be assigned a codeword of length 1. (b) Prove that for any binary Huffman code, if the most probable message symbol has probability p 1 < , that symbol must be assigned a codeword of length ≥ 2. 5.26 Merges . Companies with values W 1 , W 2 ,…, W m are merged as follows. The two least valuable companies are merged, thus forming a list of m − 1 companies. The value of the merge is the sum of the values of the two merged companies. This continues until one supercompany remains. Let V equal the sum of the values of the merges. Thus, V represents the total reported dollar volume of the merges. For example, if W = (3, 3, 2, 2), the merges yield (3, 3, 2, 2) (4, 3, 3) (6, 4) (10) and V = 4 + 6 + 10 = 20. (a) Argue that V is the minimum volume achievable by sequences of pairwise merges terminating in one supercompany. ( Hint: Compare to Huffman coding.) (b) Let W = ∑ W i , = W i / W , and show that the minimum merge volume V satisfies (5.147) 5.27 Sardinas–Patterson test for unique decodability . A code is not uniquely decodable if and only if there exists a finite sequence of code symbols which can be resolved into sequences of codewords in two different ways. That is, a situation such as must occur where each A i and each B i is a codeword. Note that B i must be a prefix of A 1 with some resulting “dangling suffix.” Each dangling suffix must in turn be either a prefix of a codeword or have another codeword as its prefix, resulting in another dangling suffix. Finally, the last dangling suffix in the sequence must also be a codeword. Thus, one can set up a test for unique decodability (which is essentially the Sardinas–Patterson test [456]) in the following way: Construct a set S of all possible dangling suffixes. The code is uniquely decodable if and only if S contains no codeword. (a) State the precise rules for building the set S . (b) Suppose that the codeword lengths are l i , i = 1, 2,…, m . Find a good upper bound on the number of elements in the set S . (c) Determine which of the following codes is uniquely decodable: (i) {0, 10, 11} (ii) {0, 01, 11} (iii) {0, 01, 10} (iv) {0, 01} (v) {00, 01, 10, 11} (vi) {110, 11, 10} (vii) {110, 11, 100, 00, 10} (d) For each uniquely decodable code in part (c), construct, if possible, an infinite encoded sequence with a known starting point such that it can be resolved into codewords in two different ways. (This illustrates that unique decodability does not imply finite decodability.) Prove that such a sequence cannot arise in a prefix code. 5.28 Shannon code . Consider the following method for generating a code for a random variable X that takes on m values {1, 2,…, m } with probabilities p 1 , p 2 ,…, p m . Assume that the probabilities are ordered so that p 1 ≥ p 2 ≥ … ≥ p m . Define (5.148) the sum of the probabilities of all symbols less than i . Then the codeword for i is the number F i [0, 1} rounded off to l i bits, where . (a) Show that the code constructed by this process is prefix-free and that the average length satisfies (5.149) (b) Construct the code for the probability distribution (0.5, 0.25, 0.125, 0.125). 5.29 Optimal codes for dyadic distributions . For a Huffman code tree, define the probability of a node as the sum of the probabilities of all the leaves under that node. Let the random variable X be drawn from a dyadic distribution [i.e., p ( x ) = 2 − i , for some i , for all x X ]. Now consider a binary Huffman code for this distribution. (a) Argue that for any node in the tree, the probability of the left child is equal to the probability of the right child. (b) Let X 1 , X 2 ,…, X n be drawn i.i.d. p ( x ). Using the Huffman code for p ( x ), we map X 1 , X 2 ,…, X n , to a sequence of bits Y 1 , Y 2 ,…, Y k ( X 1 , X 2 ,…, X n ). (The length of this sequence will depend on the outcome X 1 , X 2 , X n .) Use part (a) to argue that the sequence Y 1 , Y 2 , … forms a sequence of fair coin flips [i.e., that Pr{ Y i = 0} = Pr{ Y i 1) = , independent of Y 1 , Y 2 ,…, Y i −1 ]. Thus, the entropy rate of the coded sequence is 1 bit per symbol. (c) Give a heuristic argument why the encoded sequence of bits for any code that achieves the entropy bound cannot be compressible and therefore should have an entropy rate of 1 bit per symbol. 5.30 Relative entropy is cost of miscoding . Let the random variable X have five possible outcomes {1, 2, 3, 4, 5}. Consider two distributions p ( x ) and q ( x ) on this random variable. (a) Calculate H ( p ), H ( q ), D ( p || q ), and D ( q||p ). (b) The last two columns represent codes for the random variable. Verify that the average length of C 1 under p is equal to the entropy H ( p ). Thus, C 1 is optimal for p . Verify that C 2 is optimal for q . (c) Now assume that we use code C 2 when the distribution is p . What is the average length of the codewords. By how much does it exceed the entropy p ? (d) What is the loss if we use code C 1 when the distribution is q ? 5.31 Nonsingular codes . The discussion in the text focused on instantaneous codes, with extensions to uniquely decodable codes. Both these are required in cases when the code is to be used repeatedly to encode a sequence of outcomes of a random variable. But if we need to encode only one outcome and we know when we have reached the end of a codeword, we do not need unique decodability—the fact that the code is nonsingular would suffice. For example, if a random variable X takes on three values, a, b, and c, we could encode them by 0, 1, and 00. Such a code is nonsingular but not uniquely decodable. In the following, assume that we have a random variable X which takes on m values with probabilities p 1 , p 2 ,…, p m and that the probabilities are ordered so that p 1 ≥ p 2 ≥…≥ p m . (a) By viewing the nonsingular binary code as a ternary code with three symbols, 0, 1, and “STOP,” show that the expected length of a nonsingular code L 1:1 for a random variable X satisfies the following inequality: (5.150) where H 2 ( X ) is the entropy of X in bits. Thus, the average length of a nonsingular code is at least a constant fraction of the average length of an instantaneous code. (b) Let L INST be the expected length of the best instantaneous code and L* 1:1 be the expected length of the best nonsingular code for X . Argue that L * 1:1 ≤ L * INST ≤ H ( X ) + 1. (c) Give a simple example where the average length of the nonsingular code is less than the entropy. (d) The set of codewords available for a nonsingular code is {10, 1, 00, 01, 10, 11, 000, …}. Since , show that this is minimized if we allot the shortest codewords to the most probable symbols. Thus, l 1 = l 2 = l, l / 3 = l 4 = l 5 = l 6 = 2, etc. Show that in general l i = [log 1( + 1)], and therefore L * 1:1 = . (e) Part (d) shows that it is easy to find the optimal nonsingular code for a distribution. However, it is a little more tricky to deal with the average length of this code. We now bound this average length. It follows from part (d) that L * 1:1 ≥ log ( i /2 + 1). Consider the difference (5.151) Prove by the method of Lagrange multipliers that the maximum of F ( p ) occurs when p i = c / ( i + 2), where c = 1/( H m +2 − H 2 ) and H k is the sum of the harmonic series: (5.152) (This can also be done using the nonnegativity of relative entropy.) (f) Complete the arguments for (5.153) (5.154) Now it is well known (see, e.g., Knuth [3151) that H k ≈ in k (more precisely, , where 0 < < 1/252 n 6 , and y = Euler’s constant = 0.577 …). Using either this or a simple approximation that H k ≤ In k + 1, which can be proved by integration of 1/ x , it can be shown that H ( X ) − L * 1:1 < log log m + 2. Thus, we have (5.155) A nonsingular code cannot do much better than an instantaneous code! 5.32 Bad wine . One is given six bottles of wine. It is known that precisely one bottle has gone bad (tastes terrible). From inspection of the bottles it is determined that the probability p i that the i th bottle is bad is given by ( p 1 , p 2 ,…, p 6 ) = . Tasting will determine the bad wine. Suppose that you taste the wines one at a time. Choose the order of tasting to minimize the expected number of tastings required to determine the bad bottle. Remember, if the first five wines pass the test, you don’t have to taste the last. (a) What is the expected number of tastings required? (b) Which bottle should be tasted first? Now you get smart. For the first sample, you mix some of the wines in a fresh glass and sample the mixture. You proceed, mixing and tasting, stopping when the bad bottle has been determined. (a) What is the minimum expected number of tastings required to determine the bad wine? (b) What mixture should be tasted first? 5.33 Huffman vs. Shannon . A random variable X takes on three values with probabilities 0.6, 0.3; and 0.1. (a) What are the lengths of the binary Huffman codewords for X ? What are the lengths of the binary Shannon codewords for X ? (b) What is the smallest integer D such that the expected Shannon codeword length with a D -ary alphabet equals the expected Huffman codeword length with a D -ary alphabet? 5.34 Huffman algorithm for tree construction . Consider the following problem: m binary signals S 1 , S 2 ,…, S m are available at times T 1 ≤ T 2 ≤ … ≤ T m , and we would like to find their sum S 1 ⊕ S 2 ⊕ … ⊕ S m using two-input gates, each gate with one time unit delay, so that the final result is available as quickly as possible. A simple greedy algorithm is to combine the earliest two results, forming the partial result at time max ( T 1 , T 2 ) + 1. We now have a new problem with S 1 ⊕ S 2 , S 3 ,…, S m , available at times max( T 1 , T 2 ) + 1, T 3 ,…, T m . We can now sort this list of T ’s and apply the same merging step again, repeating this until we have the final result. (a) Argue that the foregoing procedure is optimal, in that it constructs a circuit for which the final result is available as quickly as possible. (b) Show that this procedure finds the tree that minimizes (5.156) where T i is the time at which the result allotted to the i th leaf is available and l i is the length of the path from the i th leaf to the root. (c) Show that (5.157) for any tree T . (d) Show that there exists a tree such that (5.158) Thus, log 2 (∑ 2 Ti ) is the analog of entropy for this problem. 5.35 Generating random variables . One wishes to generate a random variable X (5.159) You are given fair coin flips Z 1 , Z 2 ,…. Let N be the (random) number of flips needed to generate X . Find a good way to use Z 1 , Z 2 , … to generate X . Show that EN ≤ 2. 5.36 Optimal word lengths . (a) Can l = (1, 2, 2) be the word lengths of a binary Huffman code. What about (2,2,3,3)? (b) What word lengths l = l 1 , l 2 ,…) can arise from binary Huffman codes? 5.37 Codes . Which of the following codes are (a) Uniquely decodable? (b) Instantaneous? 5.38 Huffman . Find the Huffman D-ary code for ( p 1 , p 2 , p 3 , p 4 , p 5 , p 6 ) = and the expected word length (a) For D = 2. (b) For D = 4. 5.39 Entropy of encoded bits . Let C : X → {0, 1)* be a nonsingular but nonuniquely decodable code. Let X have entropy H ( X ). (a) Compare H(C(X) ) to H ( X ). (b) Compare H(C(X n ) ) to H(X n ). 5.40 Code rate . Let X be a random variable with alphabet {1, 2, 3} and distribution The data compression code for X assigns codewords Let X 1 , X 2 , … be independent, identically distributed according to this distribution and let Z 1 Z 2 Z 3 … = C ( X 1 )C( X 2 ) … be the string of binary symbols resulting from concatenating the corresponding codewords. For example, 122 becomes 01010. (a) Find the entropy rate H(χ ) and the entropy rate in bits per symbol. Note that Z is not compressible further. (b) Now let the code be and find the entropy rate . (c) Finally, let the code be and find the entropy rate . 5.41 Optimal codes . Let l 1 , l 2 ,…, l 10 be the binary Huffman codeword lengths for the probabilities p 1 ≥ p 2 ≥ … ≥ p 10. Suppose that we get a new distribution by splitting the last probability mass. What can you say about the optimal binary codeword lengths for the probabilities p 1 , p 2 ,…, p 9 , α p 10 , (1 − α) p 10 , where 0 ≤ α ≤ 1. 5.42 Ternary codes . Which of the following codeword lengths can be the word lengths of a 3-ary Huffman code, and which cannot? (a) (1, 2, 2, 2, 2) (b) (2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3) 5.43 Piecewise Huffman . Suppose the codeword that we use to describe a random variable X ~ p ( x ) always starts with a symbol chosen from the set { A, B, C }, followed by binary digits {0, 1}. Thus, we have a ternary code for the first symbol and binary thereafter. Give the optimal uniquely decodable code (minimum expected number of symbols) for the probability distribution (5.160) 5.44 Huffman . Find the word lengths of the optimal binary encoding of . 5.45 Random 20 questions . Let X be uniformly distributed over {1, 2,…, m }. Assume that m = 2 n . We ask random questions: Is X S 1 ? Is X S 2 ?… until only one integer remains. All 2 m subsets S of { 1, 2, … m } are equally likely to be asked. (a) Without loss of generality, suppose that X = 1 is the random object. What is the probability that object 2 yields the same answers for k questions as does object 1? (b) What is the expected number of objects in {2, 3,…, m } that have the same answers to the questions as does the correct object 1? (c) Suppose that we ask random questions. What is the expected number of wrong objects agreeing with the answers? (d) Use Markov’s inequality Pr{X ≥ t π} ≤ 1/ t , to show that the probability of error (one or more wrong object remaining) goes to zero as n → ∞. HISTORICAL NOTES The foundations for the material in this chapter can be found in Shannon’s original paper [472], in which Shannon stated the source coding theorem and gave simple examples of codes. He described a simple code construction procedure (described in Problem 5.5.28), which he attributed to Fano. This method is now called the Shannon–Fano code construction procedure. The Kraft inequality for uniquely decodable codes was first proved by McMillan [385]; the proof given here is due to Karush [306]. The Huffman coding procedure was first exhibited and proved to be optimal by Huffman [283]. In recent years, there has been considerable interest in designing source codes that are matched to particular applications, such as magnetic recording. In these cases, the objective is to design codes so that the output sequences satisfy certain properties. Some of the results for this problem are described by Franaszek [219], Adler et al. [5] and Marcus [370]. The arithmetic coding procedure has its roots in the Shannon–Fano code developed by Elias (unpublished), which was analyzed by Jelinek [297]. The procedure for the construction of a prefix-free code described in the text is due to Gilbert and Moore [249]. The extension of the Shannon–Fano–Elias method to sequences is based on the enumerative methods in Cover [120] and was described with finite-precision arithmetic by Pasco [414] and Rissanen [441]. The competitive optimality of Shannon codes was proved in Cover [125] and extended to Huffman codes by Feder [203]. Section 5.11 on the generation of discrete distributions from fair coin flips follows the work of Knuth and Yao[317].

Chapter 6: Gambling and Data Compression CHAPTER 6 GAMBLING AND DATA COMPRESSION At first sight, information theory and gambling seem to be unrelated. But as we shall see, there is strong duality between the growth rate of investment in a horse race and the entropy rate of the horse race. Indeed, the sum of the growth rate and the entropy rate is a constant. In the process of proving this, we shall argue that the financial value of side information is equal to the mutual information between the horse race and the side information. The horse race is a special case of investment in the stock market, studied in Chapter 16. We also show how to use a pair of identical gamblers to compress a sequence of random variables by an amount equal to the growth rate of wealth on that sequence. Finally, we use these gambling techniques to estimate the entropy rate of English. 6.1 THE HORSE RACE Assume that m horses run in a race. Let the i th horse win with probability p i . If horse i wins, the payoff is o i for 1 (i.e., an investment of 1 dollar on horse i results in of dollars if horse i wins and 0 dollars if horse i loses). There are two ways of describing odds: a -for-1 and b -to-1. The first refers to an exchange that takes place before the race—the gambler puts down 1 dollar before the race and at a -for-1 odds will receive a dollars after the race if his horse wins, and will receive nothing otherwise. The second refers to an exchange after the race—at b -to-1 odds, the gambler will pay 1 dollar after the race if his horse loses and will pick up b dollars after the race if his horse wins. Thus, a bet at b -to-1 odds is equivalent to a bet at a -for-1 odds if b = a − 1. For example, fair odds on a coin flip would be 2-for-1 or 1-to-1, otherwise known as even odds . We assume that the gambler distributes all of his wealth across the horses. Let b i be the fraction of the gambler’s wealth invested in horse i , where b i ≥ 0 and ∑ b i = 1. Then if horse i wins the race, the gambler will receive o i times the amount of wealth bet on horse i . All the other bets are lost. Thus, at the end of the race, the gambler will have multiplied his wealth by a factor b i o i if horse i wins, and this will happen with probability p i . For notational convenience, we use b ( i ) and b i interchangeably throughout this chapter. The wealth at the end of the race is a random variable, and the gambler wishes to “maximize” the value of this random variable. It is tempting to bet everything on the horse that has the maximum expected return (i.e., the one with the maximum p i o i ) . But this is clearly risky, since all the money could be lost. Some clarity results from considering repeated gambles on this race. Now since the gambler can reinvest his money, his wealth is the product of the gains for each race. Let S n be the gambler’s wealth after n races. Then (6.1) where S ( X ) = b ( X ) o ( X ) is the factor by which the gambler’s wealth is multiplied when horse X wins. Definition The wealth relative S ( X ) = b ( X ) o ( X ) is the factor by which the gambler’s wealth grows if horse X wins the race. Definition The doubling rate of a horse race is (6.2) The definition of doubling rate is justified by the following theorem. Theorem 6.1.1 Let the race outcomes X 1 , X 2 , … be i.i.d. ~ p(x). Then the wealth of the gambler using betting strategy b grows exponentially at rate W (b, p); that is, (6.3) Proof: Functions of independent random variables are also independent, and hence log S(X 1 ), log S ( X 2 ),… are i.i.d. Then, by the weak law of large numbers, (6.4) Thus, (6.5) Now since the gambler’s wealth grows as 2 nW ( b’p ) , we seek to maximize the exponent W ( b, p ) over all choices of the portfolio b . Definition The optimum doubling rate W* ( p ) is the maximum doubling rate over all choices of the portfolio b : (6.6) We maximize W ( b, p ) as a function of b subject to the constraint ∑ b i = 1. Writing the functional with a Lagrange multiplier and changing the base of the logarithm (which does not affect the maximizing b ), we have (6.7) Differentiating this with respect to b i yields (6.8) Setting the partial derivative equal to 0 for a maximum, we have (6.9) Substituting this in the constraint ∑ b i = 1 yields λ = −1 and b i = p i . Hence, we can conclude that b = p is a stationary point of the function J(b) . To prove that this is actually a maximum is tedious if we take second derivatives. Instead, we use a method that works for many such problems: Guess and verify. We verify that proportional gambling b = p is optimal in the following theorem. Proportional gambling is known as Kelly gambling [308]. Theorem 6.1.2 ( Proportional gambling is log-optimal ) The optimum doubling rate is given by (6.10) and is achieved by the proportional gambling scheme b* = p . Proof: We rewrite the function W ( b, p ) in a form in which the maximum is obvious: (6.11) (6.12) (6.13) (6.14) with equality iff p = b (i.e., the gambler bets on each horse in proportion to its probability of winning). Example 6.1.1 Consider a case with two horses, where horse 1 wins with probability p i and horse 2 wins with probability p 2 . Assume even odds (2-for-1 on both horses). Then the optimal bet is proportional betting (i.e., b 1 = p 1 , b 2 = p 2 ). The optimal doubling rate is W *( p ) = ∑ p i log o i − H ( p ) = 1 − H ( p ), and the resulting wealth grows to infinity at this rate: (6.15) Thus, we have shown that proportional betting is growth rate optimal for a sequence of i.i.d. horse races if the gambler can reinvest his wealth and if there is no alternative of keeping some of the wealth in cash. We now consider a special case when the odds are fair with respect to some distribution (i.e., there is no track take and ). In this case, we write r i = , where r i can be interpreted as a probability mass function over the horses. (This is the bookie’s estimate of the win probabilities.) With this definition, we can write the doubling rate as (6.16) (6.17) (6.18) This equation gives another interpretation for the relative entropy distance: The doubling rate is the difference between the distance of the bookie’s estimate from the true distribution and the distance of the gambler’s estimate from the true distribution. Hence, the gambler can make money only if his estimate (as expressed by b ) is better than the bookie’s. An even more special case is when the odds are m -for-1 on each horse. In this case, the odds are fair with respect to the uniform distribution and the optimum doubling rate is (6.19) In this case we can clearly see the duality between data compression and the doubling rate. Theorem 6.1.3 ( Conservation theorem ) For uniform fair odds , (6.20) Thus, the sum of the doubling rate and the entropy rate is a constant . Every bit of entropy decrease doubles the gambler’s wealth. Low entropy races are the most profitable. In the analysis above, we assumed that the gambler was fully invested. In general, we should allow the gambler the option of retaining some of his wealth as cash. Let b (0) be the proportion of wealth held out as cash, and b (1), b (2), b(m) be the proportions bet on the various horses. Then at the end of a race, the ratio of final wealth to initial wealth (the wealth relative) is (6.21) Now the optimum strategy may depend on the odds and will not necessarily have the simple form of proportional gambling. We distinguish three subcases: 1. Fair odds with respect to some distribution: . For fair odds, the option of withholding cash does not change the analysis. This is because we can get the effect of withholding cash by betting on the i th horse, i = 1, 2,…, m . Then S ( X ) = 1 irrespective of which horse wins. Thus, whatever money the gambler keeps aside as cash can equally well be distributed over the horses, and the assumption that the gambler must invest all his money does not change the analysis. Proportional betting is optimal. 2. Superfair odds: . In this case, the odds are even better than fair odds, so one would always want to put all one’s wealth into the race rather than leave it as cash. In this race, too, the optimum strategy is proportional betting. However, it is possible to choose b so as to form a Dutch book by choosing where c = , to get o i b i = c , irrespective of which horse wins. With this allotment, one has wealth S ( X ) = with probability 1 (i.e., no risk). Needless to say, one seldom finds such odds in real life. Incidentally, a Dutch book, although risk-free, does not optimize the doubling rate. 3. Subfair odds: . This is more representative of real life. The organizers of the race track take a cut of all the bets. In this case it is optimal to bet only some of the money and leave the rest aside as cash. Proportional gambling is no longer log-optimal. A parametric form for the optimal strategy can be found using Kuhn–Tucker conditions (Problem 6.2); it has a simple “water-filling” interpretation. 6.2 GAMBLING AND SIDE INFORMATION Suppose the gambler has some information that is relevant to the outcome of the gamble. For example, the gambler may have some information about the performance of the horses in previous races. What is the value of this side information? One definition of the financial value of such information is the increase in wealth that results from that information. In the setting described in Section 6.1 the measure of the value of information is the increase in the doubling rate due to that information. We will now derive a connection between mutual information and the increase in the doubling rate. To formalize the notion, let horse X {1, 2,…, m } win the race with probability p ( x ) and pay odds of o ( x ) for 1. Let ( X, Y ) have joint probability mass function p ( x, y ). Let b ( x | y ) ≥ 0, ∑ x b ( x | y ) = 1 be an arbitrary conditional betting strategy depending on the side information Y , where b ( x | y ) is the proportion of wealth bet on horse x when y is observed. As before, let b ( x ) ≥ 0, ∑ b ( x ) = 1 denote the unconditional betting scheme. Let the unconditional and the conditional doubling rates be (6.22) (6.23) and let (6.24) We observe that for ( X i , Y i ) i.i.d. horse races, wealth grows like 2 nw* (X|Y) in with side information and like 2 nW *(X) without side information. Theorem 6.2.1 The increase ΔW in doubling rate due to side information Y for a horse race X is (6.25) Proof: With side information, the maximum value of W*(X | Y) with side information Y is achieved by conditionally proportional gambling [i.e., b *( x|y) = p(x|y)] . Thus, (6.26) (6.27) (6.28) Without side information, the optimal doubling rate is (6.29) Thus, the increase in doubling rate due to the presence of side information Y is (6.30) Hence, the increase in doubling rate is equal to the mutual information between the side information and the horse race. Not surprisingly, independent side information does not increase the doubling rate. This relationship can also be extended to the general stock market (Chapter 16). In this case, however, one can only show the inequality ΔW ≤ I , with equality if and only if the market is a horse race. 6.3 DEPENDENT HORSE RACES AND ENTROPY RATE The most common example of side information for a horse race is the past performance of the horses. If the horse races are independent, this information will be useless. If we assume that there is dependence among the races, we can calculate the effective doubling rate if we are allowed to use the results of previous races to determine the strategy for the next race. Suppose that the sequence { X k } of horse race outcomes forms a stochastic process. Let the strategy for each race depend on the results of previous races. In this case, the optimal doubling rate for uniform fair odds is (6.31) which is achieved by b * ( x k | x k −1 ,…, x 1 ) = p ( x k | x k −1 ,…, x 1 ). At the end of n races, the gambler’s wealth is (6.32) and the exponent in the growth rate (assuming m for 1 odds) is (6.33) (6.34) (6.35) The quantity H (X 1 , X 2 ,…, X n ) is the average entropy per race. For a stationary process with entropy rate H (χ) , the limit in (6.35) yields (6.36) Again, we have the result that the entropy rate plus the doubling rate is a constant. The expectation in (6.36) can be removed if the process is ergodic. It will be shown in Chapter 16 that for an ergodic sequence of horse races, (6.37) where W = log m − H ( χ ) and (6.38) Example 6.3.1 ( Red and black ) In this example, cards replace horses and the outcomes become more predictable as time goes on. Consider the case of betting on the color of the next card in a deck of 26 red and 26 black cards. Bets are placed on whether the next card will be red or black, as we go through the deck. We also assume that the game pays 2-for-1; that is, the gambler gets back twice what he bets on the right color. These are fair odds if red and black are equally probable. We consider two alternative betting schemes: 1. If we bet sequentially, we can calculate the conditional probability of the next card and bet proportionally. Thus, we should bet ( , ) on (red, black) for the first card, for the second card if the first card is black, and so on. 2. Alternatively, we can bet on the entire sequence of 52 cards at once. There are possible sequences of 26 red and 26 black cards, all of them equally likely. Thus, proportional betting implies that we put of our money on each of these sequences and let each bet “ride.” We will argue that these procedures are equivalent. For example, half the sequences of 52 cards start with red, and so the proportion of money bet on sequences that start with red in scheme 2 is also one-half, agreeing with the proportion used in the first scheme. In general, we can verify that betting of the money on each of the possible outcomes will at each stage give bets that are proportional to the probability of red and black at that stage. Since we bet of the wealth on each possible output sequence, and a bet on a sequence increases wealth by a factor of 2 52 on the sequence observed and 0 on all the others, the resulting wealth is (6.39) Rather interestingly, the return does not depend on the actual sequence. This is like the AEP in that the return is the same for all sequences. All sequences are typical in this sense. 6.4 THE ENTROPY OF ENGLISH An important example of an information source is English text. It is not immediately obvious whether English is a stationary ergodic process. Probably not! Nonetheless, we will be interested in the entropy rate of English. We discuss various stochastic approximations to English. As we increase the complexity of the model, we can generate text that looks like English. The stochastic models can be used to compress English text. The better the stochastic approximation, the better the compression. For the purposes of discussion, we assume that the alphabet of English consists of 26 letters and the space symbol. We therefore ignore punctuation and the difference between upper- and lowercase letters. We construct models for English using empirical distributions collected from samples of text. The frequency of letters in English is far from uniform. The most common letter, E, has a frequency of about 13%, and the least common letters, Q and Z, occur with a frequency of about 0.1%. The letter E is so common that it is rare to find a sentence of any length that does not contain the letter. [A surprising exception to this is the 267-page novel, Gadsby , by Ernest Vincent Wright (Lightyear Press, Boston, 1997; original publication in 1939), in which the author deliberately makes no use of the letter E.] The frequency of pairs of letters is also far from uniform. For example, the letter Q is always followed by a U. The most frequent pair is TH, which occurs normally with a frequency of about 3.7%. We can use the frequency of the pairs to estimate the probability that a letter follows any other letter. Proceeding this way, we can also estimate higher-order conditional probabilities and build more complex models for the language. However, we soon run out of data. For example, to build a third-order Markov approximation, we must estimate the values of p ( x i | x i − i , x i −2 , x i −3 ). There are 27 4 = 531, 441 entries in this table, and we would need to process millions of letters to make accurate estimates of these probabilities. The conditional probability estimates can be used to generate random samples of letters drawn according to these distributions (using a random number generator). But there is a simpler method to simulate randomness using a sample of text (a book, say). For example, to construct the second-order model, open the book at random and choose a letter at random on the page. This will be the first letter. For the next letter, again open the book at random and starting at a random point, read until the first letter is encountered again. Then take the letter after that as the second letter. We repeat this process by opening to another page, searching for the second letter, and. taking the letter after that as the third letter. Proceeding this way, we can generate text that simulates the second-order statistics of the English text. Here are some examples of Markov approximations to English from Shannon’s original paper [472]: 1. Zero-order approximation . (The symbols are independent and equiprobable.) XFOML RXKHRJFFJUJ ZLPWCFWKCYJ FFJEYVKCQSGXYD QPAAMKBZAACIBZLHJQD 2. First-order approximation . (The symbols are independent. The frequency of letters matches English text.) OCRO HLI RGWR NMIELWIS EU LL NBNESEBYA TH EEI ALHENHTTPA OOBTTVA NAH BRL 3. Second-order approximation . (The frequency of pairs of letters matches English text.) ON IE ANTSOUTINYS ARE T INCTORE ST BE S DEAMY ACHIN D ILONASIVE TUCOOWE AT TEASONARE FUSO TIZIN ANDY TOBE SEACE CTISBE 4. Third-order approximation . (The frequency of triplets of letters matches English text.) IN NO IST LAT WHEY CRATICT FROURE BERS GROCID PONDENOME OF DEMONSTURES OF THE REPTAGIN IS REGOACTIONA OF CRE 5. Fourth-order approximation . (The frequency of quadruplets of letters matches English text. Each letter depends on the previous three letters. This sentence is from Lucky’s book, Silicon Dreams [366].) THE GENERATED JOB PROVIDUAL BETTER TRAND THE DISPLAYED CODE, ABOVERY UPONDULTS WELL THE CODERST IN THESTICAL IT DO HOCK BOTHE MERG. (INSTATES CONS ERATION. NEVER ANY OF PUBLE AND TO THEORY. EVENTIAL CALLEGAND TO ELAST BENERATED IN WITH PIES AS IS WITH THE) Instead of continuing with the letter models, we jump to word models. 6. First-order word model . (The words are chosen independently but with frequencies as in English.) REPRESENTING AND SPEEDILY IS AN GOOD APT OR COME CAN DIFFERENT NATURAL HERE HE THE A IN CAME THE TO OF TO EXPERT GRAY COME TO FURNISHES THE LINE MESSAGE HAD BE THESE. 7. Second-order word model . (The word transition probabilities match English text.) THE HEAD AND IN FRONTAL ATTACK ON AN ENGLISH WRITER THAT THE CHARACTER OF THIS POINT IS THEREFORE ANOTHER METHOD FOR THE LETTERS THAT THE TIME OF WHO EVER TOLD THE PROBLEM FOR AN UNEXPECTED The approximations get closer and closer to resembling English. For example, long phrases of the last approximation could easily have occurred in a real English sentence. It appears that we could get a very good approximation by using a more complex model. These approximations could be used to estimate the entropy of English. For example, the entropy of the zeroth-order model is log 27 = 4.76 bits per letter. As we increase the complexity of the model, we capture more of the structure of English, and the conditional uncertainty of the next letter is reduced. The first-order model gives an estimate of the entropy of 4.03 bits per letter, while the fourth-order model gives an estimate of 2.8 bits per letter. But even the fourth-order model does not capture all the structure of English. In Section 6.6 we describe alternative methods for estimating the entropy of English. The distribution of English is useful in decoding encrypted English text. For example, a simple substitution cipher (where each letter is replaced by some other letter) can be solved by looking for the most frequent letter and guessing that it is the substitute for E, and so on. The redundancy in English can be used to fill in some of the missing letters after the other letters are decrypted: for example, TH_R_ _S _NLY _N_ W_Y T_ F_LL _N TH_ V_W_LS _N TH_S S_NT_NC_. Some of the inspiration for Shannon’s original work on information theory came out of his work in cryptography during World War II. The mathematical theory of cryptography and its relationship to the entropy of language is developed in Shannon [481]. Stochastic models of language also play a key role in some speech recognition systems. A commonly used model is the trigram (second-order Markov) word model, which estimates the probability of the next word given the preceding two words. The information from the speech signal is combined with the model to produce an estimate of the most likely word that could have produced the observed speech. Random models do surprisingly well in speech recognition, even when they do not explicitly incorporate the complex rules of grammar that govern natural languages such as English. We can apply the techniques of this section to estimate the entropy rate of other information sources, such as speech and images. A fascinating nontechnical introduction to these issues may be found in the book by Lucky [366]. 6.5 DATA COMPRESSION AND GAMBLING We now show a direct connection between gambling and data compression, by showing that a good gambler is also a good data compressor. Any sequence on which a gambler makes a large amount of money is also a sequence that can be compressed by a large factor. The idea of using the gambler as a data compressor is based on the fact that the gambler’s bets can be considered to be his estimate of the probability distribution of the data. A good gambler will make a good estimate of the probability distribution. We can use this estimate of the distribution to do arithmetic coding (Section 13.3). This is the essential idea of the scheme described below. We assume that the gambler has a mechanically identical twin, who will be used for the data decompression. The identical twin will place the same bets on possible sequences of outcomes as the original gambler (and will therefore make the same amount of money). The cumulative amount of money that the gambler would have made on all sequences that are lexicographically less than the given sequence will be used as a code for the sequence. The decoder will use the identical twin to gamble on all sequences, and look for the sequence for which the same cumulative amount of money is made. This sequence will be chosen as the decoded sequence. Let X 1 , X 2 ,…, X n , be a sequence of random variables that we wish to compress. Without loss of generality, we will assume that the random variables are binary. Gambling on this sequence will be defined by a sequence of bets (6.40) where b ( x k +1 | x 1 , x 2 , … x k ) is the proportion of money bet at time k on the event that X k +l = given the observed past x 1 , x 2 ,…, x k . Bets are paid at uniform odds (2-for-1). Thus, the wealth S n at the end of the sequence is given by (6.41) (6.42) where (6.43) So sequential gambling can also be considered as an assignment of probabilities (or bets) b ( x 1 , x 2 ,…, x n ) ≥ 0, b(x 1 ,…, x n ) = 1, on the 2 n possible sequences. This gambling elicits both an estimate of the true probability of the text sequence ( ( x 1 ,…, x n ) = S n /2 n ) as well as an estimate of the entropy of the text from which the sequence was drawn. We now wish to show that high values of wealth S n lead to high data compression. Specifically, we argue that if the text in question results in wealth S n , then log S n bits can be saved in a naturally associated deterministic data compression scheme. We further assert that if the gambling is log optimal, the data compression achieves the Shannon limit H . Consider the following data compression algorithm that maps the text x = x 1 x 2 … x n {0, 1} n into a code sequences c 1 c 2 … c k , c i {0, 1}. Both the compressor and the decompressor know n . Let the 2 n text sequences be arranged in lexicographical order: for example, 0100101 < 0101101. The encoder observes the sequence x n = ( x 1 , x 2 ,…, x n ). He then calculates what his wealth S n ( x ′( n )) would have been on all sequences x ′ ( n ) ≤ x(n) and calculates . Clearly, F ( x ( n )) [0, 1]. Let k = [ n − log S n ( x ( n ))]. Now express F ( x ( n )) as a binary decimal to k -place accuracy: [ F ( x ( n ))] = . c 1 c 2 … c k . The sequence c ( k ) = ( c 1 , c 2 ,…, c k ) is transmitted to the decoder. The decoder twin can calculate the precise value S ( x ′ ( n )) associated with each of the 2 n sequences x ′ ( n ). He thus knows the cumulative sum of 2 − n S ( x ′ ( n )) up through any sequence x ( n ). He tediously calculates this sum until it first exceeds .c ( k ). The first sequence x ( n ) such that the cumulative sum falls in the interval [. c 1 … c 1 c k + (1/2) k } is defined uniquely, and the size of S ( x ( n ))/2 n guarantees that this sequence will be precisely the encoded x ( n ). Thus, the twin uniquely recovers x ( n ). The number of bits required is k = [ n − log S ( x ( n ))]. The number of bits saved is n − k = [log S ( x ( n ))]. For proportional gambling, S ( x ( n )) = 2 n p ( x ( n )). Thus, the expected number of bits is Ek = ∑ p ( x ( n )) ≤ H ( X 1 ,…, X n ) + 1. We see that if the betting operation is deterministic and is known both to the encoder and the decoder, the number of bits necessary to encode x 1 ,…, x n is less than n − log S n + 1. Moreover, if p ( x ) is known, and if proportional gambling is used, the description length expected is E(n − log S n ) ≤ H(X 1 , X n ) + 1. Thus, the gambling results conespond precisely to the data compression that would have been achieved by the given human encoder–decoder identical twin pair. The data compression scheme using a gambler is similar to the idea of arithmetic coding (Section 13.3) using a distribution b ( x 1 , x 2 ,…, x n ) rather than the true distribution. The procedure above brings out the duality between gambling and data compression. Both involve estimation of the true distribution. The better the estimate, the greater the growth rate of the gambler’s wealth and the better the data compression. 6.6 GAMBLING ESTIMATE OF THE ENTROPY OF ENGLISH We now estimate the entropy rate for English using a human gambler to estimate probabilities. We assume that English consists of 27 characters (26 letters and a space symbol). We therefore ignore punctuation and case of letters. Two different approaches have been proposed to estimate the entropy of English. 1. Shannon guessing game . In this approach the human subject is given a sample of English text and asked to guess the next letter. An optimal subject will estimate the probabilities of the next letter and guess the most probable letter first, then the second most probable letter next, and so on. The experimenter records the number of guesses required to guess the next letter. The subject proceeds this way through a fairly large sample of text. We can then calculate the empirical frequency distribution of the number of guesses required to guess the next letter. Many of the letters will require only one guess; but a large number of guesses will usually be needed at the beginning of words or sentences. Now let us assume that the subject can be modeled as a computer making a deterministic choice of guesses given the past text. Then if we have the same machine and the sequence of guess numbers, we can reconstruct the English text. Just let the machine run, and if the number of guesses at any position is k , choose the k th guess of the machine as the next letter. Hence the amount of information in the sequence of guess numbers is the same as in the English text. The entropy of the guess sequence is the entropy of English text. We can bound the entropy of the guess sequence by assuming that the samples are independent. Hence, the entropy of the guess sequence is bounded above by the entropy of the histogram in the experiment. The experiment was conducted in 1950 by Shannon [482], who obtained a value of 1.3 bits per symbol for the entropy of English. 2. Gambling estimate . In this approach we let a human subject gamble on the next letter in a sample of English text. This allows finer gradations of judgment than does guessing. As in the case of a horse race, the optimal bet is proportional to the conditional probability of the next letter. The payoff is 27-for-1 on the correct letter. Since sequential betting is equivalent to betting on the entire sequence, we can write the payoff after n letters as (6.44) Thus, after n rounds of betting, the expected log wealth satisfies (6.45) (6.46) (6.47) (6.48) (6.49) (6.50) where H ( χ ) is the entropy rate of English. Thus, log 27 − E log S n is an upper bound on the entropy rate of English. The upper bound estimate, = log 27 − 1/ n log S n , converges to H ( χ ) with probability 1 if English is ergodic and the gambler uses b ( x n ) = p(x n ) . An experiment [131] with 12 subjects and a sample of 75 letters from the book Jefferson the Virginian by Dumas Malone (Little, Brown, Boston, 1948; the source used by Shannon) resulted in an estimate of 1.34 bits per letter for the entropy of English. SUMMARY Doubling rate. W ( b, p ) = E (log S(X )) = . Optimal doubling rate. W *( p ) = max b W ( b, p ). Proportional gambling is log-optimal (6.51) is achieved by b * = p . Growth rate. Wealth grows as S n 2W*(p) . Conservation law . For uniform fair odds, (6.52) Side information . In a horse race X , the increase Δ W in doubling rate due to side information Y is (6.53) PROBLEMS 6.1 Horse race . Three horses run a race. A gambler offers 3-for-1 odds on each horse. These are fair odds under the assumption that all horses are equally likely to win the race. The true win probabilities are known to be (6.54) Let b = ( b 1 , b 2 , b 3 ), b i > 0, ∑ b i = 1, be the amount invested on each of the horses. The expected log wealth is thus (6.55) (a) Maximize this over b to find b * and W *. Thus, the wealth achieved in repeated horse races should grow to infinity like 2 nW * with probability 1. (b) Show that if instead we put all of our money on horse 1, the most likely winner, we will eventually go broke with probability 1. 6.2 Horse race with subfair odds . If the odds are bad (due to a track take), the gambler may wish to keep money in his pocket. Let b ( 0 ) be the amount in his pocket and let b (1), b (2),…, b ( m ) be the amount bet on horses 1, 2,…, m , with odds o (1), o (2),…, o ( m ), and win probabilities p (1), p (2),…, p ( m ). Thus, the resulting wealth is S ( X ) = b (0) b ( x ) o ( x ), with probability p ( x ), x = 1, 2,…, m . (a) Find b* maximizing E log S if ∑ 1/ o ( i ) < 1. (b) Discuss b* if ∑ 1/ o ( i ) > 1. (There isn’t an easy closed-form solution in this case, but a “water-filling” solution results from the application of the Kuhn−Tucker conditions.) 6.3 Cards . An ordinary deck of cards containing 26 red cards and 26 black cards is shuffled and dealt out one card at time without replacement. Let X i be the color of the i th card. (a) Determine H ( X 1 ). (b) Determine H ( X 2 ). (c) Does H /( X 2 | X 1 , X 2 ,…, X k −1 ) increase or decrease? (d) Determine H ( X 1 , X 2 ,…, X 52 ). 6.4 Gambling . Suppose that one gambles sequentially on the card outcomes in Problem 6.6.3. Even odds of 2-for-1 are paid. Thus, the wealth S n at time n is S n = 2 n b ( x 1 , x 2 ,…, x n ), where b(x 1 , x 2 ,…, x n ) is the proportion of wealth bet on x 1 , x 2 ,…, x n . Find max b(.) E log S 52 . 6.5 Beating the public odds . Consider a three-horse race with win probabilities and fair odds with respect to the (false) distribution Thus, the odds are (a) What is the entropy of the race? (b) Find the set of bets ( b 1 , b 2 , b 3 ) such that the compounded wealth in repeated plays will grow to infinity. 6.6 Horse race . A three-horse race has win probabilities p = ( p 1 , p 2 , p 3 ), and odds o = (1, 1, 1). The gambler places bets b = ( b 1 , b 2 , b 3 ), b i ≥ 0, ∑ b i = 1, where b i denotes the proportion on wealth bet on horse i . These odds are very bad. The gambler gets his money back on the winning horse and loses the other bets. Thus, the wealth S n at time n resulting from independent gambles goes exponentially to zero. (a) Find the exponent. (b) Find the optimal gambling scheme b (i.e., the bet b* that maximizes the exponent). (c) Assuming that b is chosen as in part (b), what distribution p causes S n , to go to zero at the fastest rate? 6.7 Horse race . Consider a horse race with four horses. Assume that each horse pays 4-for-1 if it wins. Let the probabilities of winning of the horses be , If you started with $100 and bet optimally to maximize your long-term growth rate, what are your optimal bets on each horse? Approximately how much money would you have after 20 races with this strategy? 6.8 Lotto . The following analysis is a crude approximation to the games of Lotto conducted by various states. Assume that the player of the game is required to pay $1 to play and is asked to choose one number from a range 1 to 8. At the end of every day, the state lottery commission picks a number uniformly over the same range. The jackpot (i.e., all the money collected that day) is split among all the people who chose the same number as the one chosen by the state. For example, if 100 people played today, 10 of them chose the number 2, and the drawing at the end of the day picked 2, the $100 collected is split among the 10 people (i.e., each person who picked 2 will receive $10, and the others will receive nothing). The general population does not choose numbers uniformly—numbers such as 3 and 7 are supposedly lucky and are more popular than 4 or 8. Assume that the fraction of people choosing the various numbers 1, 2,…, 8 is ( f 1 , f 2 , … f 8 ), and assume that n people play every day. Also assume that n is very large, so that any single person’s choice does not change the proportion of people betting on any number. (a) What is the optimal strategy to divide your money among the various possible tickets so as to maximize your long-term growth rate? (Ignore the fact that you cannot buy fractional tickets.) (b) What is the optimal growth rate that you can achieve in this game? (c) If ( f 1 , f 2 ,…, f 8 ) = and you start with $1, how long will it be before you become a millionaire? 6.9 Horse race . Suppose that one is interested in maximizing the doubling rate for a horse race. Let p 1 , p 2 ,…, p m denote the win probabilities of the m horses. When do the odds ( o 1 , o 2 ,…, o m ) yield a higher doubling rate than the odds ( o ′ 1 , o ′ 2 ,…, o′ m )? 6.10 Horse race with probability estimates . (a) Three horses race. Their probabilities of winning are . The odds are 4-for-I, 3-for-1, and 3-for-1. Let W * be the optimal doubling rate. Suppose you believe that the probabilities are . If you try to maximize the doubling rate, what doubling rate W will you achieve? By how much has your doubling rate decrease due to your poor estimate of the probabilities (i.e., what is Δ W = W * − W )? (b) Now let the horse race be among m horses, with probabilities p = ( p 1 , p 2 ,…, p m ) and odds o = ( o 1 , o 2 ,…, o m ). If you believe the true probabilities to be q = ( q 1 , q 2 ,…, q m ), and try to maximize the doubling rate W , what is W * − W ? 6.11 Two-envelope problem . One envelope contains b dollars, the other 2b dollars. The amount b is unknown. An envelope is selected at random. Let X be the amount observed in this envelope, and let Y be the amount in the other envelope. Adopt the strategy of switching to the other envelope with probability p ( x ), where . Let Z be the amount that the player receives. Thus, (6.56) (6.57) (a) Show that E ( X ) = E ( Y ) = . (b) Show that E ( Y | X ) = . Since the expected ratio of the amount in the other envelope is , it seems that one should always switch. (This is the origin of the switching paradox.) However, observe that E ( Y ) ≠ E ( X ) E ( Y | X ). Thus, although E ( Y | X ) > 1, it does not follow that E ( Y ) > E ( X ). (c) Let J be the index of the envelope containing the maximum amount of money, and let J′ be the index of the envelope chosen by the algorithm. Show that for any b, I(J; J ′) > 0. Thus, the amount in the first envelope always contains some information about which envelope to choose. (d) Show that E(Z) > E(X) . Thus, you can do better than always staying or always switching. In fact, this is true for any monotonic decreasing switching function p ( x ). By randomly switching according to p ( x ), you are more likely to trade up than to trade down. 6.12 Gambling . Find the horse win probabilities p 1 , p 2 ,…, p m : (a) Maximizing the doubling rate W * for given fixed known odds o 1 , o 2 ,…, o m . (b) Minimizing the doubling rate for given fixed odds o 1 , o 2 , … o m . 6.13 Dutch book . Consider a horse race with m = 2 horses, The odds are superfair. (a) There is a bet b that guarantees the same payoff regardless of which horse wins. Such a bet is called a Dutch book . Find this b and the associated wealth factor S ( X ). (b) What is the maximum growth rate of the wealth for the optimal choice of b ? Compare it to the growth rate for the Dutch book. 6.14 Horse race . Suppose that one is interested in maximizing the doubling rate for a horse race. Let p 1 , p 2 ,…, p m denote the win probabilities of the m horses. When do the odds ( o 1 , o 2 ,…, o m ) yield a higher doubling rate than the odds ( o ′ 1 , o ′ 2 , …, o ′ m )? 6.15 Entropy of a fair horse race . Let X ~ p ( x ), x = 1, 2,…, m , denote the winner of a horse race. Suppose that the odds o ( x ) are fair with respect to p ( x ) [i.e., o ( x ) = ]. Let b ( x ) be the amount bet on horse x , b ( x ) > 0, ∑ m 1 b ( x ) = 1. Then the resulting wealth factor is S ( x ) = b ( x ) o ( x ), with probability p ( x ). (a) Find the expected wealth ES(X) . (b) Find W *, the optimal growth rate of wealth. (c) Suppose that If this side information is available before the bet, how much does it increase the growth rate W *? (d) Find I ( X; Y ). 6.16 Negative horse race . Consider a horse race with m horses with win probabilities p 1 , p 2 ,…, p m . Here the gambler hopes that a given horse will lose. He places bets ( b 1 , b 2 ,…, b m ), b i = 1, on the horses, loses his bet b i if horse i wins, and retains the rest of his bets. (No odds.) Thus, S = ∑ j ≠ i b j , with probability p i , and one wishes to maximize ∑ p i 1n(1 − b i ) subject to the constraint ∑ b i = 1. (a) Find the growth rate optimal investment strategy b *. Do not constrain the bets to be positive, but do constrain the bets to sum to 1. (This effectively allows short selling and margin.) (b) What is the optimal growth rate? 6.17 St . Petersburg paradox . Many years ago in ancient St. Petersburg the following gambling proposition caused great consternation. For an entry fee of c units, a gambler receives a payoff of 2 k units with probability 2 − k , k = 1, 2, …. (a) Show that the expected payoff for this game is infinite. For this reason, it was argued that c = ∞ was a “fair” price to pay to play this game. Most people find this answer absurd. (b) Suppose that the gambler can buy a share of the game. For example, if he invests c /2 units in the game, he receives a share and a return X /2, where Pr( X = 2 k ) = 2 − k , k = 1, 2, …. Suppose that X 1 , X 2 , … are i.i.d. according to this distribution and that the gambler reinvests all his wealth each time. Thus, his wealth S n at time n is given by (6.58) Show that this limit is ∞ or 0, with probability 1, accordingly as c < c * or c > c *. Identify the “fair” entry fee c *. More realistically, the gambler should be allowed to keep a proportion = 1 − b of his money in his pocket and invest the rest in the St. Petersburg game. His wealth at time n is then (6.59) Let (6.60) We have (6.61) Let (6.62) Here are some questions about W *( c ). (a) For what value of the entry fee c does the optimizing value b * drop below 1? (b) How does b * vary with c ? (c) How does W *( c ) fall off with c ? Note that since W *( c ) > 0, for all c , we can conclude that any entry fee c is fair. 6.18 Super St. Petersburg . Finally, we have the super St. Petersburg paradox, where Pr( X = 2 2 k ) = 2 − k , k = 1, 2, …. Here the expected log wealth is infinite for all b > 0, for all c , and the gambler’s wealth grows to infinity faster than exponentially for any b > 0. But that doesn’t mean that all investment ratios b are equally good. To see this, we wish to maximize the relative growth rate with respect to some other portfolio, say, . Show that there exists a unique b maximizing and interpret the answer. HISTORICAL NOTES The original treatment of gambling on a horse race is due to Kelly [308], who found that Δ W = I . Log-optimal portfolios go back to the work of Bernoulli, Kelly [308], Latané [346], and Latané and Tuttle [347]. Proportional gambling is sometimes referred to as the Kelly gambling scheme . The improvement in the probability of winning by switching envelopes in Problem 6.11 is based on Cover [130]. Shannon studied stochastic models for English in his original paper [472]. His guessing game for estimating the entropy rate of English is described in [482]. Cover and King [131] provide a gambling estimate for the entropy of English. The analysis of the St. Petersburg paradox is from Bell and Cover [39]. An alternative analysis can be found in Feller [208].

Chapter 7: Channel Capacity CHAPTER 7 CHANNEL CAPACITY What do we mean when we say that A communicates with B ? We mean that the physical acts of A have induced a desired physical state in B . This transfer of information is a physical process and therefore is subject to the uncontrollable ambient noise and imperfections of the physical signaling process itself. The communication is successful if the receiver B and the transmitter A agree on what was sent. In this chapter we find the maximum number of distinguishable signals for n uses of a communication channel. This number grows exponentially with n , and the exponent is known as the channel capacity. The characterization of the channel capacity (the logarithm of the number of distinguishable signals) as the maximum mutual information is the central and most famous success of information theory. The mathematical analog of a physical signaling system is shown in Figure 7.1 . Source symbols from some finite alphabet are mapped into some sequence of channel symbols, which then produces the output sequence of the channel. The output sequence is random but has a distribution that depends on the input sequence. From the output sequence, we attempt to recover the transmitted message. FIGURE 7.1. Communication system. Each of the possible input sequences induces a probability distribution on the output sequences. Since two different input sequences may give rise to the same output sequence, the inputs are confusable. In the next few sections, we show that we can choose a “nonconfusable” subset of input sequences so that with high probability there is only one highly likely input that could have caused the particular output. We can then reconstruct the input sequences at the output with a negligible probability of error. By mapping the source into the appropriate “widely spaced” input sequences to the channel, we can transmit a message with very low probability of error and reconstruct the source message at the output. The maximum rate at which this can be done is called the capacity of the channel. Definition We define a discrete channel to be a system consisting of an input alphabet χ and output alphabet and a probability transition matrix p ( y | x ) that expresses the probability of observing the output symbol y given that we send the symbol x . The channel is said to be memoryless if the probability distribution of the output depends only on the input at that time and is conditionally independent of previous channel inputs or outputs. Definition We define the “ information ” channel capacity of a discrete memoryless channel as (7.1) where the maximum is taken over all possible input distributions p ( x ). We shall soon give an operational definition of channel capacity as the highest rate in bits per channel use at which information can be sent with arbitrarily low probability of error. Shannon’s second theorem establishes that the information channel capacity is equal to the operational channel capacity. Thus, we drop the word information in most discussions of channel capacity. There is a duality between the problems of data compression and data transmission. During compression, we remove all the redundancy in the data to form the most compressed version possible, whereas during data transmission, we add redundancy in a controlled fashion to combat errors in the channel. In Section 7.13 we show that a general communication system can be broken into two parts and that the problems of data compression and data transmission can be considered separately. 7.1 EXAMPLES OF CHANNEL CAPACITY 7.1.1 Noiseless Binary Channel Suppose that we have a channel whose the binary input is reproduced exactly at the output ( Figure 7.2 ). FIGURE 7.2. Noiseless binary channel. C = 1 bit. In this case, any transmitted bit is received without error. Hence, one error-free bit can be transmitted per use of the channel, and the capacity is 1 bit. We can also calculate the information capacity C = max I ( X ; Y ) = 1 bit, which is achieved by using p ( x ) = ( , ). 7.1.2 Noisy Channel with Nonoverlapping Outputs This channel has two possible outputs corresponding to each of the two inputs ( Figure 7.3 ). The channel appears to be noisy, but really is not. Even though the output of the channel is a random consequence of the input, the input can be determined from the output, and hence every transmitted bit can be recovered without error. The capacity of this channel is also 1 bit per transmission. We can also calculate the information capacity C = max I ( X ; Y ) = 1 bit, which is achieved by using p ( x ) = ( , ). FIGURE 7.3. Noisy channel with nonoverlapping outputs. C = 1 bit. 7.1.3 Noisy Typewriter In this case the channel input is either received unchanged at the output with probability or is transformed into the next letter with probability ( Figure 7.4 ). If the input has 26 symbols and we use every alternate input symbol, we can transmit one of 13 symbols without error with each transmission. Hence, the capacity of this channel is log 13 bits per transmission. We can also calculate the information capacity C = max I ( X ; Y ) = max ( H ( Y ) − H ( Y | X )) = max H ( Y ) − 1 = log 26 − 1 = log 13, achieved by using p ( x ) distributed uniformly over all the inputs. FIGURE 7.4. Noisy Typewriter. C = log 13 bits. 7.1.4 Binary Symmetric Channel Consider the binary symmetric channel (BSC), which is shown in Fig. 7.5 . This is a binary channel in which the input symbols are complemented with probability p . This is the simplest model of a channel with errors, yet it captures most of the complexity of the general problem. FIGURE 7.5. Binary symmetric channel. C = 1 − H ( p ) bits. When an error occurs, a 0 is received as a 1, and vice versa. The bits received do not reveal where the errors have occurred. In a sense, all the bits received are unreliable. Later we show that we can still use such a communication channel to send information at a nonzero rate with an arbitrarily small probability of error. We bound the mutual information by (7.2) (7.3) (7.4) (7.5) (7.6) where the last inequality follows because Y is a binary random variable. Equality is achieved when the input distribution is uniform. Hence, the information capacity of a binary symmetric channel with parameter p is (7.7) 7.1.5 Binary Erasure Channel The analog of the binary symmetric channel in which some bits are lost (rather than corrupted) is the binary erasure channel . In this channel, a fraction α of the bits are erased. The receiver knows which bits have been erased. The binary erasure channel has two inputs and three outputs ( Figure 7.6 ). FIGURE 7.6. Binary erasure channel. We calculate the capacity of the binary erasure channel as follows: (7.8) (7.9) (7.10) The first guess for the maximum of H ( Y ) would be log 3, but we cannot achieve this by any choice of input distribution p ( x ). Letting E be the event { Y = e }, using the expansion (7.11) and letting Pr( X = 1) = π, we have (7.12) Hence (7.13) (7.14) (7.15) (7.16) where capacity is achieved by π = . The expression for the capacity has some intuitive meaning: Since a proportion α of the bits are lost in the channel, we can recover (at most) a proportion 1 − α of the bits. Hence the capacity is at most 1 − α. It is not immediately obvious that it is possible to achieve this rate. This will follow from Shannon’s second theorem. In many practical channels, the sender receives some feedback from the receiver. If feedback is available for the binary erasure channel, it is very clear what to do: If a bit is lost, retransmit it until it gets through. Since the bits get through with probability 1 − α, the effective rate of transmission is 1 − α. In this way we are easily able to achieve a capacity of 1 − α with feedback. Later in the chapter we prove that the rate 1 − α is the best that can be achieved both with and without feedback. This is one of the consequences of the surprising fact that feedback does not increase the capacity of discrete memoryless channels. 7.2 SYMMETRIC CHANNELS The capacity of the binary symmetric channel is C = 1 − H ( p ) bits per transmission, and the capacity of the binary erasure channel is C = 1 − α bits per transmission. Now consider the channel with transition matrix: (7.17) Here the entry in the x th row and the y th column denotes the conditional probability p ( y | x ) that y is received when x is sent. In this channel, all the rows of the probability transition matrix are permutations of each other and so are the columns. Such a channel is said to be symmetric . Another example of a symmetric channel is one of the form (7.18) where Z has some distribution on the integers {0, 1, 2,…, c − 1}, X has the same alphabet as Z , and Z is independent of X . In both these cases, we can easily find an explicit expression for the capacity of the channel. Letting r be a row of the transition matrix, we have (7.19) (7.20) (7.21) with equality if the output distribution is uniform. But p ( x ) = 1/|χ| achieves a uniform distribution on Y , as seen from (7.22) where c is the sum of the entries in one column of the probability transition matrix. Thus, the channel in (7.17) has the capacity (7.23) and C is achieved by a uniform distribution on the input. The transition matrix of the symmetric channel defined above is doubly stochastic. In the computation of the capacity, we used the facts that the rows were permutations of one another and that all the column sums were equal. Considering these properties, we can define a generalization of the concept of a symmetric channel as follows: Definition A channel is said to be symmetric if the rows of the channel transition matrix p ( y | x ) are permutations of each other and the columns are permutations of each other. A channel is said to be weakly symmetric if every row of the transition matrix p (.| x ) is a permutation of every other row and all the column sums ∑ x p ( y | x ) are equal. For example, the channel with transition matrix (7.24) is weakly symmetric but not symmetric. The above derivation for symmetric channels carries over to weakly symmetric channels as well. We have the following theorem for weakly symmetric channels: Theorem 7.2.1 For a weakly symmetric channel , (7.25) and this is achieved by a uniform distribution on the input alphabet . 7.3 PROPERTIES OF CHANNEL CAPACITY 1. C ≥ 0 since I ( X; Y ) ≥ 0. 2. C ≤ log |χ| since C = max I ( X; Y ) ≤ max H ( X ) = log |χ|. 3. C ≤ log | y | for the same reason. 4. I ( X; Y ) is a continuous function of p ( x ). 5. I ( X; Y ) is a concave function of p ( x ) (Theorem 2.7.4). Since I ( X; Y ) is a concave function over a closed convex set, a local maximum is a global maximum. From properties 2 and 3, the maximum is finite, and we are justified in using the term maximum rather than supremum in the definition of capacity. The maximum can then be found by standard nonlinear optimization techniques such as gradient search. Some of the methods that can be used include the following: Constrained maximization using calculus and the Kuhn–Tucker conditions. The Frank–Wolfe gradient search algorithm. An iterative algorithm developed by Arimoto [25] and Blahut [65]. We describe the algorithm in Section 10.8. In general, there is no closed-form solution for the capacity. But for many simple channels it is possible to calculate the capacity using properties such as symmetry. Some of the examples considered earlier are of this form. 7.4 PREVIEW OF THE CHANNEL CODING THEOREM So far, we have defined the information capacity of a discrete memoryless channel. In the next section we prove Shannon’s second theorem, which gives an operational meaning to the definition of capacity as the number of bits we can transmit reliably over the channel. But first we will try to give an intuitive idea as to why we can transmit C bits of information over a channel. The basic idea is that for large block lengths, every channel looks like the noisy typewriter channel ( Figure 7.4 ) and the channel has a subset of inputs that produce essentially disjoint sequences at the output. For each (typical) input n-sequence, there are approximately 2 nH(Y|X) possible Y sequences, all of them equally likely ( Figure 7.7 ). We wish to ensure that no two X sequences produce the same Y output sequence. Otherwise, we will not be able to decide which X sequence was sent. FIGURE 7.7. Channels after n uses. The total number of possible (typical) Y sequences is ≈ 2 nH ( Y ). This set has to be divided into sets of size 2 nH ( Y | X ) corresponding to the different input X sequences. The total number of disjoint sets is less than or equal to 2 n ( H ( Y )− H ( Y | X )) = 2 nI ( X; Y ). Hence, we can send at most ≈ 2 nI ( X; Y ) distinguishable sequences of length n . Although the above derivation outlines an upper bound on the capacity, a stronger version of the above argument will be used in the next section to prove that this rate I is achievable with an arbitrarily low probability of error. Before we proceed to the proof of Shannon’s second theorem, we need a few definitions. 7.5 DEFINITIONS We analyze a communication system as shown in Figure 7.8 . FIGURE 7.8. Communication channel. A message W , drawn from the index set {1, 2, … M }, results in the signal X n ( W ), which is received by the receiver as a random sequence Y n ~ p ( y n | x n ). The receiver then guesses the index W by an appropriate decoding rule = g ( Y n ). The receiver makes an error if is not the same as the index W . that was transmitted. We now define these ideas formally. Definition A discrete channel , denoted by (χ, p ( y | x ), )), consists of two finite sets χ and and a collection of probability mass functions p ( y | x ), one for each x χ, such that for every x and y, p ( y | x ) ≥ 0, and for every x , ∑ y p ( y | x ) = 1, with the interpretation that X is the input and Y is the output of the channel. Definition The nth extension of the discrete memoryless channel (DMC) is the channel (χ n , p ( y n | x n ), n ) where (7.26) Remark If the channel is used without feedback [i.e., if the input symbols do not depend on the past output symbols, namely, p ( x k | x k −1 , y k −1 ) = p ( x k | x k −1 )], the channel transition function for the nth extension of the discrete memoryless channel reduces to (7.27) When we refer to the discrete memoryless channel, we mean the discrete memoryless channel without feedback unless we state explicitly otherwise. Definition An ( M, n ) code for the channel (χ, p ( y | x ), ) consists of the following: 1. An index set (1, 2, … M }. 2. An encoding function X n : {1, 2,…, M } → χ n , yielding codewords x n (1), x n (2), … x n ( M ). The set of codewords is called the codebook . 3. A decoding function (7.28) which is a deterministic rule that assigns a guess to each possible received vector. Definition ( Conditional probability of error ) Let (7.29) be the conditional probability of error given that index i was sent, where I (·) is the indicator function. Definition The maximal probability of error λ ( n ) for an ( M, n ) code is defined as (7.30) Definition The ( arithmetic ) average probability of error P e (n) for an ( M, n ) code is defined as (7.31) Note that if the index W is chosen according to a uniform distribution over the set {1, 2,…, M }, and X n = x n ( W ), then (7.32) (i.e., P e ( n ) is the probability of error). Also, obviously, (7.33) One would expect the maximal probability of error to behave quite differently from the average probability. But in the next section we prove that a small average probability of error implies a small maximal probability of error at essentially the same rate. It is worth noting that P e ( n ) defined in (7.32) is only a mathematical construct of the conditional probabilities of error λ i and is itself a probability of error only if the message is chosen uniformly over the message set {1, 2,…, M }. However, both in the proof of achievability and the converse, we choose a uniform distribution on W to bound the probability of error. This allows us to establish the behavior of P e ( n ) and the maximal probability of error λ ( n ) and thus characterize the behavior of the channel regardless of how it is used (i.e., no matter what the distribution of W ). Definition The rate-R of an ( M, n ) code is (7.34) Definition A rate R is said to be achievable if there exists a sequence of codes such that the maximal probability of error λ ( n ) tends to 0 as n → ∞. Later, we write (2 nR , n ) codes to mean codes. This will simplify the notation. Definition The capacity of a channel is the supremum of all achievable rates. Thus, rates less than capacity yield arbitrarily small probability of error for sufficiently large block lengths. 7.6 JOINTLY TYPICAL SEQUENCES Roughly speaking, we decode a channel output Y n as the i th index if the codeword X n ( i ) is “jointly typical” with the received signal Y n . We now define the important idea of joint typicality and find the probability of joint typicality when X n ( i ) is the true cause of Y n and when it is not. Definition The set of jointly typical sequences {( x n , y n )} with respect to the distribution p ( x, y ) is the set of n -sequences with empirical entropies -close to the true entropies: (7.35) (7.36) (7.37) where (7.38) Theorem 7.6.1 ( Joint AEP ) Let ( X n , Y n ) be sequences of length n drawn i.i.d. according to p ( x n , Y n ) = . Then: 1. Pr(( X n , Y n ) → 1 as n → ∞. 2. 3. If ~ p ( x n ) p ( y n ) [i.e., and are independent with the same marginals as p(x n , y n )], then (7.39) Also, for sufficiently large n , (7.40) Proof 1. We begin by showing that with high probability, the sequence is in the typical set. By the weak law of large numbers, (7.41) Hence, given > 0, there exists n 1 , such that for all n > n 1 , (7.42) Similarly, by the weak law, (7.43) and (7.44) and there exist n 2 and n 3 , such that for all n ≥ n 2 , (7.45) and for all n ≤ n 3 , (7.46) Choosing n > max{ n 1 , n 2 , n 3 }, the probability of the union of the sets in (7.42) , (7.45) , and (7.46) must be less than . Hence for n sufficiently large, the probability of the set is greater than 1 − , establishing the first part of the theorem. 2. To prove the second part of the theorem, we have (7.47) (7.48) (7.49) and hence (7.50) 3. Now if and are independent but have the same marginals as X n and Y n , then (7.51) (7.52) (7.53) For sufficiently large n , , and therefore (7.54) (7.55) and (7.56) By similar arguments to the upper bound above, we can also show that for n sufficiently large, (7.57) (7.58) (7.59) The jointly typical set is illustrated in Figure 7.9 . There are about 2 nH ( X ) typical X sequences and about 2 nH ( Y) typical Y sequences. However, since there are only 2 nH ( X, Y ) jointly typical sequences, not all pairs of typical X n and typical Y n are also jointly typical. The probability that any randomly chosen pair is jointly typical is about 2 –nI( X; Y ) . Hence, we can consider about 2 nI ( X; Y ) such pairs before we are likely to come across a jointly typical pair. This suggests that there are about 2 nI ( X; Y ) distinguishable signals X n . FIGURE 7.9. Jointly typical sequences. Another way to look at this is in terms of the set of jointly typical sequences for a fixed output sequence Y n , presumably the output sequence resulting from the true input signal X n . For this sequence Y n , there are about 2 nH ( X|Y ) conditionally typical input signals. The probability that some randomly chosen (other) input signal X n is jointly typical with Y n is about 2 nH ( X|Y ) /2 nH ( X ) = 2 − nI ( X; Y ) . This again suggests that we can choose about 2 nI ( X; Y ) codewords X n ( W ) before one of these codewords will get confused with the codeword that caused the output Y n . 7.7 CHANNEL CODING THEOREM We now prove what is perhaps the basic theorem of information theory, the achievability of channel capacity, first stated and essentially proved by Shannon in his original 1948 paper. The result is rather counterintuitive; if the channel introduces errors, how can one correct them all? Any correction process is also subject to error, ad infinitum. Shannon used a number of new ideas to prove that information can be sent reliably over a channel at all rates up to the channel capacity. These ideas include: Allowing an arbitrarily small but nonzero probability of error Using the channel many times in succession, so that the law of large numbers comes into effect Calculating the average of the probability of error over a random choice of codebooks, which symmetrizes the probability, and which can then be used to show the existence of at least one good code Shannon’s outline of the proof was based on the idea of typical sequences, but the proof was not made rigorous until much later. The proof given below makes use of the properties of typical sequences and is probably the simplest of the proofs developed so far. As in all the proofs, we use the same essential ideas—random code selection, calculation of the average probability of error for a random choice of codewords, and so on. The main difference is in the decoding rule. In the proof, we decode by joint typicality; we look for a codeword that is jointly typical with the received sequence. If we find a unique codeword satisfying this property, we declare that word to be the transmitted codeword. By the properties of joint typicality stated previously, with high probability the transmitted codeword and the received sequence are jointly typical, since they are probabilistically related. Also, the probability that any other codeword looks jointly typical with the received sequence is 2 – nI . Hence, if we have fewer then 2 nI codewords, then with high probability there will be no other codewords that can be confused with the transmitted codeword, and the probability of error is small. Although jointly typical decoding is suboptimal, it is simple to analyze and still achieves all rates below capacity. We now give the complete statement and proof of Shannon’s second theorem: Theorem 7.7.1 (Channel coding theorem) For a discrete memoryless channel, all rates below capacity C are achievable. Specifically, for every rate R < C, there exists a sequence of (2 nR , n) codes with maximum probability of error λ (n) → 0. Conversely, any sequence of (2 nR , n) codes with λ ( n ) → 0 must have R ≤ C . Proof: We prove that rates R < C are achievable and postpone proof of the converse to Section 7.9. Achievability: Fix p ( x ). Generate a (2 nR , n ) code at random according to the distribution p ( x ) . Specifically, we generate 2 nR codewords independently according to the distribution (7.60) We exhibit the 2 nR codewords as the rows of a matrix: (7.61) Each entry in this matrix is generated i.i.d. according to p ( x ). Thus, the probability that we generate a particular code C is (7.62) Consider the following sequence of events: 1. A random code C is generated as described in (7.62) according to p ( x ). 2. The code C is then revealed to both sender and receiver. Both sender and receiver are also assumed to know the channel transition matrix p ( y | x ) for the channel. 3. A message W is chosen according to a uniform distribution (7.63) 4. The w th codeword X n ( w ), corresponding to the w th row of C , is sent over the channel. 5. The receiver receives a sequence Y n according to the distribution (7.64) 6. The receiver guesses which message was sent. (The optimum procedure to minimize probability of error is maximum likelihood decoding (i.e., the receiver should choose the a posteriori most likely message). But this procedure is difficult to analyze. Instead, we will use jointly typical decoding , which is described below. Jointly typical decoding is easier to analyze and is asymptotically optimal.) In jointly typical decoding, the receiver declares that the index was sent if the following conditions are satisfied: ( X n , Y n ) is jointly typical. There is no other index W ′ ≠ such that ( X n ( W ′), Y n ) A ( n ) If no such exists or if there is more than one such, an error is declared. (We may assume that the receiver outputs a dummy index such as 0 in this case.) 7. There is a decoding error if ≠ W . Let be the event { ≠ W }. Analysis of the probability of error Outline: We first outline the analysis. Instead of calculating the probability of error for a single code, we calculate the average over all codes generated at random according to the distribution (7.62) . By the symmetry of the code construction, the average probability of error does not depend on the particular index that was sent. For a typical codeword, there are two different sources of error when we use jointly typical decoding: Either the output Y n is not jointly typical with the transmitted codeword or there is some other codeword that is jointly typical with Y n The probability that the transmitted codeword and the received sequence are jointly typical goes to 1, as shown by the joint AEP. For any rival codeword, the probability that it is jointly typical with the received sequence is approximately 2 − nI , and hence we can use about 2 nI codewords and still have a low probability of error. We will later extend the argument to find a code with a low maximal probability of error. Detailed calculation of the probability of error: We let W be drawn according to a uniform distribution over {1, 2,…, 2 nR } and use jointly typical decoding ( y n ) as described in step 6. Let ε = { ( Y n ) ≠ W } denote the error event. We will calculate the average probability of error, averaged over all codewords in the codebook, and averaged over all codebooks; that is, we calculate (7.65) (7.66) (7.67) where P e ( n ) ( C ) is defined for jointly typical decoding. By the symmetry of the code construction, the average probability of error averaged over all codes does not depend on the particular index that was sent [i.e., does not depend on w ]. Thus, we can assume without loss of generality that the message W = 1 was sent, since (7.68) (7.69) (7.70) Define the following events: (7.71) where E i is the event that the i th codeword and Y n are jointly typical. Recall that Y n is the result of sending the first codeword X n (1) over the channel. Then an error occurs in the decoding scheme if either E c 1 occurs (when the transmitted codeword and the received sequence are not jointly typical) or E 2 ∪ E 3 ∪ · · · E 2 nR occurs (when a wrong codeword is jointly typical with the received sequence). Hence, letting P (ε) denote Pr(ε| W = 1), we have (7.72) (7.73) by the union of events bound for probabilities. Now, by the joint AEP, P ( E c 1 | W = 1) → 0, and hence (7.74) Since by the code generation process, X n (1) and X n (1) are independent for i ≠ 1, so are Y n and X n ( i ). Hence, the probability that X n ( i ) and Y n are jointly typical is ≤ 2 − n ( I ( X; Y )−3 ) by the joint AEP. Consequently, (7.75) (7.76) (7.77) (7.78) (7.79) if n is sufficiently large and R < I ( X; Y ) − 3 . Hence, if R < I ( X; Y ), we can choose and n so that the average probability of error, averaged over codebooks and codewords, is less than 2 . To finish the proof, we will strengthen this conclusion by a series of code selections. 1. Choose p ( x ) in the proof to be p *( x ), the distribution on X that achieves capacity. Then the condition R < I ( X; Y ) can be replaced by the achievability condition R < C . 2. Get rid of the average over codebooks. Since the average probability of error over codebooks is small (≤ 2 ), there exists at least one codebook C* with a small average probability of error. Thus, . Determination of C* can be achieved by an exhaustive search over all (2 nR , n ) codes. Note that (7.80) since we have chosen according to a uniform distribution as specified in (7.63) . 3. Throw away the worst half of the codewords in the best codebook C* Since the arithmetic average probability of error P e ( n ) ( C *) for this code is less then 2 , we have (7.81) which implies that at least half the indices i and their associated codewords X n ( i ) must have conditional probability of error λ i less than 4 (otherwise, these codewords themselves would contribute more than 2 to the sum). Hence the best half of the codewords have a maximal probability of error less than 4 . If we reindex these codewords, we have 2 nR −1 codewords. Throwing out half the codewords has changed the rate from R to R − , which is negligible for large n . Combining all these improvements, we have constructed a code of rate R ′ = R − , with maximal probability of error λ ( n ) ≤ 4 . This proves the achievability of any rate below capacity. Random coding is the method of proof for Theorem 7.7.1, not the method of signaling. Codes are selected at random in the proof merely to symmetrize the mathematics and to show the existence of a good deterministic code. We proved that the average over all codes of block length n has a small probability of error. We can find the best code within this set by an exhaustive search. Incidentally, this shows that the Kolmogorov complexity (Chapter 14) of the best code is a small constant. This means that the revelation (in step 2) to the sender and receiver of the best code C* requires no channel. The sender and receiver merely agree to use the best (2 nR , n ) code for the channel. Although the theorem shows that there exist good codes with arbitrarily small probability of error for long block lengths, it does not provide a way of constructing the best codes. If we used the scheme suggested by the proof and generate a code at random with the appropriate distribution, the code constructed is likely to be good for long block lengths. However, without some structure in the code, it is very difficult to decode (the simple scheme of table lookup requires an exponentially large table). Hence the theorem does not provide a practical coding scheme. Ever since Shannon’s original paper on information theory, researchers have tried to develop structured codes that are easy to encode and decode. In Section 7.11, we discuss Hamming codes, the simplest of a class of algebraic error correcting codes that can correct one error in a block of bits. Since Shannon’s paper, a variety of techniques have been used to construct error correcting codes, and with turbo codes have come close to achieving capacity for Gaussian channels. 7.8 ZERO-ERROR CODES The outline of the proof of the converse is most clearly motivated by going through the argument when absolutely no errors are allowed. We will now prove that P e ( n ) = 0 implies that R ≤ C . Assume that we have a (2 nR , n ) code with zero probability of error [i.e., the decoder output g ( Y n ) is equal to the input index W with probability 1]. Then the input index W is determined by the output sequence [i.e., H ( W | Y n ) = 0]. Now, to obtain a strong bound, we arbitrarily assume that W is uniformly distributed over {1, 2,…, 2 nR }. Thus, H ( W ) = nR . We can now write the string of inequalities: (7.82) (7.83) (7.84) (7.85) (7.86) where (a) follows from the data-processing inequality (since W → X n ( W ) → Y n forms a Markov chain), (b) will be proved in Lemma 7.9.2 using the discrete memoryless assumption, and (c) follows from the definition of (information) capacity. Hence, for any zero-error (2 nR , n ) code, for all n , (7.87) 7.9 FANO’S INEQUALITY AND THE CONVERSE TO THE CODING THEOREM We now extend the proof that was derived for zero-error codes to the case of codes with very small probabilities of error. The new ingredient will be Fano’s inequality, which gives a lower bound on the probability of error in terms of the conditional entropy. Recall the proof of Fano’s inequality, which is repeated here in a new context for reference. Let us define the setup under consideration. The index W is uniformly distributed on the set = (1, 2,…, 2 nR }, and the sequence Y n is related probabilistically to W . From Y n , we estimate the index W that was sent. Let the estimate be = g ( Y n ). Thus, W → X n ( W ) Y n → forms a Markov chain. Note that the probability of error is (7.88) We begin with the following lemma, which has been proved in Section 2.10: Lemma 7.9.1 (Fano’s inequality) For a discrete memoryless channel with a codebook C and the input message W uniformly distributed over 2 nR , we have (7.89) Proof: Since W is uniformly distributed, we have . We apply Fano’s inequality (Theorem 2.10.1) for W in an alphabet of size 2 nR We will now prove a lemma which shows that the capacity per transmission is not increased if we use a discrete memoryless channel many times. Lemma 7.9.2 Let Y n be the result of passing X n through a discrete memoryless channel of capacity C. Then (7.90) Proof (7.91) (7.92) (7.93) since by the definition of a discrete memoryless channel, Y i depends only on X i and is conditionally independent of everything else. Continuing the series of inequalities, we have (7.94) (7.95) (7.96) (7.97) where (7.95) follows from the fact that the entropy of a collection of random variables is less than the sum of their individual entropies, and (7.97) follows from the definition of capacity. Thus, we have proved that using the channel many times does not increase the information capacity in bits per transmission. We are now in a position to prove the converse to the channel coding theorem. Proof: Converse to Theorem 7.7.1 (Channel coding theorem) . We have to show that any sequence of (2 nR , n) ) codes with λ ( n ) → 0 must have R ≤ C . If the maximal probability of error tends to zero, the average probability of error for the sequence of codes also goes to zero [i.e., λ ( n ) → 0 implies , where is defined in (7.32) ]. For a fixed encoding rule X n (·) and a fixed decoding rule = g ( Y n ), we have W → X n ( W ) → Y n → . For each n , let W be drawn according to a uniform distribution over {1, 2,…, 2 nR }. Since W has a uniform distribution, Pr( ≠ W ) = . Hence, (7.98) (7.99) (7.100) (7.101) (7.102) where (a) follows from the assumption that W is uniform over {1, 2,…, 2 nR (b) is an identity, (c) is Fano’s inequality for W taking on at most 2 nR values, (d) is the data-processing inequality, and (e) is from Lemma 7.9.2. Dividing by n , we obtain (7.103) Now letting n → ∞, we see that the first two terms on the right-hand side tend to 0, and hence (7.104) We can rewrite (7.103) as (7.105) This equation shows that if R > C , the probability of error is bounded away from 0 for sufficiently large n (and hence for all n , since if P e (n) = 0 for small n , we can construct codes for large n with P e ( n ) =0 by concatenating these codes). Hence, we cannot achieve an arbitrarily low probability of error at rates above capacity. This converse is sometimes called the weak converse to the channel coding theorem. It is also possible to prove a strong converse , which states that for rates above capacity, the probability of error goes exponentially to 1. Hence, the capacity is a very clear dividing point–at rates below capacity, P e ( n ) → 0 exponentially, and at rates above capacity, P ( n ) e → 1 exponentially. 7.10 EQUALITY IN THE CONVERSE TO THE CHANNEL CODING THEOREM We have proved the channel coding theorem and its converse. In essence, these theorems state that when R < C , it is possible to send information with an arbitrarily low probability of error, and when R > C , the probability of error is bounded away from zero. It is interesting and rewarding to examine the consequences of equality in the converse; hopefully, it will give some ideas as to the kinds of codes that achieve capacity. Repeating the steps of the converse in the case when P e = 0, we have (7.106) (7.107) (7.108) (7.109) (7.110) (7.111) (7.112) (7.113) (7.114) We have equality in (a), the data-processing inequality, only if I ( Y n ; X n ( W )| W ) = 0 and I ( X n ; Y n | ) = 0, which is true if all the codewords are distinct and if is a sufficient statistic for decoding. We have equality in (b) only if the Y i ’s are independent, and equality in (c) only if the distribution of X i is p * ( x ), the distribution on X that achieves capacity. We have equality in the converse only if these conditions are satisfied. This indicates that a capacity-achieving zero-error code has distinct codewords and the distribution of the Y i ’s must be i.i.d. with (7.115) the distribution on Y induced by the optimum distribution on X . The distribution referred to in the converse is the empirical distribution on X and Y induced by a uniform distribution over codewords, that is, (7.116) We can check this result in examples of codes that achieve capacity: 1. Noisy typewriter . In this case we have an input alphabet of 26 letters, and each letter is either printed out correctly or changed to the next letter with probability . A simple code that achieves capacity (log 13) for this channel is to use every alternate input letter so that no two letters can be confused. In this case, there are 13 codewords of block length 1. If we choose the codewords i.i.d. according to a uniform distribution on {1, 3, 5, 7, …, 25}, the output of the channel is also i.i.d. and uniformly distributed on {1, 2,…, 26}, as expected. 2. Binary symmetric channel . Since given any input sequence, every possible output sequence has some positive probability, it will not be possible to distinguish even two codewords with zero probability of error. Hence the zero-error capacity of the BSC is zero. However, even in this case, we can draw some useful conclusions. The efficient codes will still induce a distribution on Y that looks i.i.d. ~ Bernoulli( ). Also, from the arguments that lead up to the converse, we can see that at rates close to capacity, we have almost entirely covered the set of possible output sequences with decoding sets corresponding to the codewords. At rates above capacity, the decoding sets begin to overlap, and the probability of error can no longer be made arbitrarily small. 7.11 HAMMING CODES The channel coding theorem promises the existence of block codes that will allow us to transmit information at rates below capacity with an arbitrarily small probability of error if the block length is large enough. Ever since the appearance of Shannon’s original paper [471], people have searched for such codes. In addition to achieving low probabilities of error, useful codes should be “simple,” so that they can be encoded and decoded efficiently. The search for simple good codes has come a long way since the publication of Shannon’s original paper in 1948. The entire field of coding theory has been developed during this search. We will not be able to describe the many elegant and intricate coding schemes that have been developed since 1948. We will only describe the simplest such scheme developed by Hamming [266]. It illustrates some of the basic ideas underlying most codes. The object of coding is to introduce redundancy so that even if some of the information is lost or corrupted, it will still be possible to recover the message at the receiver. The most obvious coding scheme is to repeat information. For example, to send a 1, we send 11111, and to send a 0, we send 00000. This scheme uses five symbols to send 1 bit, and therefore has a rate of bit per symbol. If this code is used on a binary symmetric channel, the optimum decoding scheme is to take the majority vote of each block of five received bits. If three or more bits are 1, we decode the block as a 1; otherwise, we decode it as 0. An error occurs if and only if more than three of the bits are changed. By using longer repetition codes, we can achieve an arbitrarily low probability of error. But the rate of the code also goes to zero with block length, so even though the code is “simple,” it is really not a very useful code. Instead of simply repeating the bits, we can combine the bits in some intelligent fashion so that each extra bit checks whether there is an error in some subset of the information bits. A simple example of this is a parity check code. Starting with a block of n − 1 information bits, we choose the nth bit so that the parity of the entire block is 0 (the number of l’s in the block is even). Then if there is an odd number of errors during the transmission, the receiver will notice that the parity has changed and detect the error. This is the simplest example of an error-detecting code . The code does not detect an even number of errors and does not give any information about how to correct the errors that occur. We can extend the idea of parity checks to allow for more than one parity check bit and to allow the parity checks to depend on various subsets of the information bits. The Hamming code that we describe below is an example of a parity check code. We describe it using some simple ideas from linear algebra. To illustrate the principles of Hamming codes, we consider a binary code of block length 7. All operations will be done modulo 2. Consider the set of all nonzero binary vectors of length 3. Arrange them in columns to form a matrix: (7.117) Consider the set of vectors of length 7 in the null space of H (the vectors which when multiplied by H give 000). From the theory of linear spaces, since H has rank 3, we expect the null space of H to have dimension 4. These 2 4 codewords are Since the set of codewords is the null space of a matrix, it is linear in the sense that the sum of any two codewords is also a codeword. The set of codewords therefore forms a linear subspace of dimension 4 in the vector space of dimension 7. Looking at the codewords, we notice that other than the all-0 codeword, the minimum number of l’s in any codeword is 3. This is called the minimum weight of the code. We can see that the minimum weight of a code has to be at least 3 since all the columns of H are different, so no two columns can add to 000. The fact that the minimum distance is exactly 3 can be seen from the fact that the sum of any two columns must be one of the columns of the matrix. Since the code is linear, the difference between any two codewords is also a codeword, and hence any two codewords differ in at least three places. The minimum number of places in which two codewords differ is called the minimum distance of the code. The minimum distance of the code is a measure of how far apart the codewords are and will determine how distinguishable the codewords will be at the output of the channel. The minimum distance is equal to the minimum weight for a linear code. We aim to develop codes that have a large minimum distance. For the code described above, the minimum distance is 3. Hence if a codeword c is corrupted in only one place, it will differ from any other codeword in at least two places and therefore be closer to c than to any other codeword. But can we discover which is the closest codeword without searching over all the codewords? The answer is yes. We can use the structure of the matrix H for decoding. The matrix H , called the parity check matrix , has the property that for every codeword c , H c = 0. Let e i be a vector with a 1 in the i th position and 0’s elsewhere. If the codeword is corrupted at position i , the received vector r = c e i . If we multiply this vector by the matrix H , we obtain (7.118) which is the vector corresponding to the i th column of H . Hence looking at Hr , we can find which position of the vector was corrupted. Reversing this bit will give us a codeword. This yields a simple procedure for correcting one error in the received sequence. We have constructed a codebook with 16 codewords of block length 7, which can correct up to one error. This code is called a Hamming code . We have not yet identified a simple encoding procedure; we could use any mapping from a set of 16 messages into the codewords. But if we examine the first 4 bits of the codewords in the table, we observe that they cycle through all 2 4 combinations of 4 bits. Thus, we could use these 4 bits to be the 4 bits of the message we want to send; the other 3 bits are then determined by the code. In general, it is possible to modify a linear code so that the mapping is explicit, so that the first k bits in each codeword represent the message, and the last n − k bits are parity check bits. Such a code is called a systematic code . The code is often identified by its block length n , the number of information bits k and the minimum distance d . For example, the above code is called a (7,4,3) Hamming code (i.e., n = 7, k = 4, and d = 3). An easy way to see how Hamming codes work is by means of a Venn diagram. Consider the following Venn diagram with three circles and with four intersection regions as shown in Figure 7.10 . To send the information sequence 1101, we place the 4 information bits in the four intersection regions as shown in the figure. We then place a parity bit in each of the three remaining regions so that the parity of each circle is even (i.e., there are an even number of l’s in each circle). Thus, the parity bits are as shown in Figure 7.11 . FIGURE 7.10. Venn diagram with information bits. FIGURE 7.11. Venn diagram with information bits and parity bits with even parity for each circle. Now assume that one of the bits is changed; for example one of the information bits is changed from 1 to 0 as shown in Figure 7.12 . Then the parity constraints are violated for two of the circles (highlighted in the figure), and it is not hard to see that given these violations, the only single bit error that could have caused it is at the intersection of the two circles (i.e., the bit that was changed). Similarly working through the other error cases, it is not hard to see that this code can detect and correct any single bit error in the received codeword. FIGURE 7.12. Venn diagram with one of the information bits changed. We can easily generalize this procedure to construct larger matrices H . In general, if we use l rows in H , the code that we obtain will have block length n = 2 l − 1, k = 2 l − l − 1 and minimum distance 3. All these codes are called Hamming codes and can correct one error. Hamming codes are the simplest examples of linear parity check codes. They demonstrate the principle that underlies the construction of other linear codes. But with large block lengths it is likely that there will be more than one error in the block. In the early 1950s, Reed and Solomon found a class of multiple error-correcting codes for nonbinary channels. In the late 1950s, Bose and Ray-Chaudhuri [72] and Hocquenghem [278] generalized the ideas of Hamming codes using Galois field theory to construct t -error correcting codes (called BCH codes) for any t . Since then, various authors have developed other codes and also developed efficient decoding algorithms for these codes. With the advent of integrated circuits, it has become feasible to implement fairly complex codes in hardware and realize some of the error-correcting performance promised by Shannon’s channel capacity theorem. For example, all compact disc players include error-correction circuitry based on two interleaved (32, 28, 5) and (28, 24, 5) Reed–Solomon codes that allow the decoder to correct bursts of up to 4000 errors. All the codes described above are block codes —they map a block of information bits onto a channel codeword and there is no dependence on past information bits. It is also possible to design codes where each output block depends not only on the current input block, but also on some of the past inputs as well. A highly structured form of such a code is called a convolutional code . The theory of convolutional codes has developed considerably over the last 40 years. We will not go into the details, but refer the interested reader to textbooks on coding theory [69, 356]. For many years, none of the known coding algorithms came close to achieving the promise of Shannon’s channel capacity theorem. For a binary symmetric channel with crossover probability p , we would need a code that could correct up to np errors in a block of length n and have n(1 − H (p)) information bits. For example, the repetition code suggested earlier corrects up to n/2 errors in a block of length n , but its rate goes to 0 with n . Until 1972, all known codes that could correct nα errors for block length n had asymptotic rate 0. In 1972, Justesen [301] described a class of codes with positive asymptotic rate and positive asymptotic minimum distance as a fraction of the block length. In 1993, a paper by Berrou et al. [57] introduced the notion that the combination of two interleaved convolution codes with a parallel cooperative decoder achieved much better performance than any of the earlier codes. Each decoder feeds its “opinion” of the value of each bit to the other decoder and uses the opinion of the other decoder to help it decide the value of the bit. This iterative process is repeated until both decoders agree on the value of the bit. The surprising fact is that this iterative procedure allows for efficient decoding at rates close to capacity for a variety of channels. There has also been a renewed interest in the theory of low-density parity check (LDPC) codes that were introduced by Robert Gallager in his thesis [231, 232]. In 1997, MacKay and Neal [368] showed that an iterative message-passing algorithm similar to the algorithm used for decoding turbo codes could achieve rates close to capacity with high probability for LDPC codes. Both Turbo codes and LDPC codes remain active areas of research and have been applied to wireless and satellite communication channels. 7.12 FEEDBACK CAPACITY A channel with feedback is illustrated in Figure 7.13 . We assume that all the received symbols are sent back immediately and noiselessly to the transmitter, which can then use them to decide which symbol to send next. Can we do better with feedback? The surprising answer is no, which we shall now prove. We define a ( 2 nR , n ) feedback code as a sequence of mappings x i ( W , Y i −1 ), where each x i is a function only of the message W 2 nR and the previous received values, Y 1 , Y 2 ,…, Y i −1 , and a sequence of decoding functions g : n → {1, 2,…, 2 nR }. Thus, FIGURE 7.13. Discrete memoryless channel with feedback. (7.119) when W is uniformly distributed over {1, 2,…, 2 nR }. Definition The capacity with feedback, C F B , of a discrete memoryless channel is the supremum of all rates achievable by feedback codes. Theorem 7.12.1 (Feedback capacity) (7.120) Proof: Since a nonfeedback code is a special case of a feedback code, any rate that can be achieved without feedback can be achieved with feedback, and hence (7.121) Proving the inequality the other way is slightly more tricky. We cannot use the same proof that we used for the converse to the coding theorem without feedback. Lemma 7.9.2 is no longer true, since X i depends on the past received symbols, and it is no longer true that Y i depends only on X i and is conditionally independent of the future X ’s in (7.93). There is a simple change that will fix the problem with the proof. Instead of using X n , we will use the index W and prove a similar series of inequalities. Let W be uniformly distributed over {1, 2,…, 2 nR }. Then Pr( W ≠ ) = P e (n) ) and (7.122) (7.123) (7.124) by Fano’s inequality and the data-processing inequality. Now we can bound I (W; Y n ) as follows: (7.125) (7.126) (7.127) (7.128) since X i is a function of Y 1 ,…, Y i −1 and W ; and conditional on X i , Y i is independent of W and past samples of Y . Continuing, we have (7.129) (7.130) (7.131) (7.132) from the definition of capacity for a discrete memoryless channel. Putting these together, we obtain (7.133) and dividing by n and letting n → ∞, we conclude that (7.134) Thus, we cannot achieve any higher rates with feedback than we can without feedback, and (7.135) As we have seen in the example of the binary erasure channel, feedback can help enormously in simplifying encoding and decoding. However, it cannot increase the capacity of the channel. 7.13 SOURCE–CHANNEL SEPARATION THEOREM It is now time to combine the two main results that we have proved so far: data compression ( R > H: Theorem 5.4.2) and data transmission ( R < C: Theorem 7.7.1). Is the condition H < C necessary and sufficient for sending a source over a channel? For example, consider sending digitized speech or music over a discrete memoryless channel. We could design a code to map the sequence of speech samples directly into the input of the channel, or we could compress the speech into its most efficient representation, then use the appropriate channel code to send it over the channel. It is not immediately clear that we are not losing something by using the two-stage method, since data compression does not depend on the channel and the channel coding does not depend on the source distribution. We will prove in this section that the two-stage method is as good as any other method of transmitting information over a noisy channel. This result has some important practical implications. It implies that we can consider the design of a communication system as a combination of two parts, source coding and channel coding. We can design source codes for the most efficient representation of the data. We can, separately and independently, design channel codes appropriate for the channel. The combination will be as efficient as anything we could design by considering both problems together. The common representation for all kinds of data uses a binary alphabet. Most modern communication systems are digital, and data are reduced to a binary representation for transmission over the common channel. This offers an enormous reduction in complexity. Networks like, ATM networks and the Internet use the common binary representation to allow speech, video, and digital data to use the same communication channel. The result–that a two-stage process is as good as any one-stage process—seems so obvious that it may be appropriate to point out that it is not always true. There are examples of multiuser channels where the decomposition breaks down. We also consider two simple situations where the theorem appears to be misleading. A simple example is that of sending English text over an erasure channel. We can look for the most efficient binary representation of the text and send it over the channel. But the errors will be very difficult to decode. If, however, we send the English text directly over the channel, we can lose up to about half the letters and yet be able to make sense out of the message. Similarly, the human ear has some unusual properties that enable it to distinguish speech under very high noise levels if the noise is white. In such cases, it may be appropriate to send the uncompressed speech over the noisy channel rather than the compressed version. Apparently, the redundancy in the source is suited to the channel. Let us define the setup under consideration. We have a source V that generates symbols from an alphabet V . We will not make any assumptions about the kind of stochastic process produced by V other than that it is from a finite alphabet and satisfies the AEP. Examples of such processes include a sequence of i.i.d. random variables and the sequence of states of a stationary irreducible Markov chain. Any stationary ergodic source satisfies the AEP, as we show in Section 16.8. We want to send the sequence of symbols V n = V 1 , V 2 ,…, V n over the channel so that the receiver can reconstruct the sequence. To do this, we map the sequence onto a codeword X n ( V n ) and send the codeword over the channel. The receiver looks at his received sequence Y n and makes an estimate V n of the sequence n that was sent. The receiver makes an error if V n ≠ n . We define the probability of error as (7.136) where I is the indicator function and g(y n ) is the decoding function. The system is illustrated in Figure 7.14 . FIGURE 7.14. Joint source and channel coding. We can now state the joint source–channel coding theorem: Theorem 7.13.1 (Source–channel coding theorem) If V 1 , V 2 , … V n is a finite alphabet stochastic process that satisfies the AEP and H(V) < C, there exists a source–channel code with probability of error . Conversely, for any stationary stochastic process, if H (V) > C, the probability of error is bounded away from zero, and it is not possible to send the process over the channel with arbitrarily low probability of error . Proof: Achievability . The essence of the forward part of the proof is the two-stage encoding described earlier. Since we have assumed that the stochastic process satisfies the AEP, it implies that there exists a typical set A ( n ) of size ≤ 2 n (H (V)+σ) which contains most of the probability. We will encode only the source sequences belonging to the typical set; all other sequences will result in an error. This will contribute at most c to the probability of error. We index all the sequences belonging to A ( n ) . Since there are at most 2 n (H +E)such sequences, n(H + E) bits suffice to index them. We can transmit the desired index to the receiver with probability of error less than σ if (7.137) The receiver can reconstruct V n by enumerating the typical set and choosing the sequence corresponding to the estimated index. This sequence will agree with the transmitted sequence with high probability. To be precise, (7.138) (7.139) for n sufficiently large. Hence, we can reconstruct the sequence with low probability of error for n sufficiently large if (7.140) Converse: We wish to show that Pr → 0 implies that H (V) ≤ C for any sequence of source-channel codes (7.141) (7.142) Thus X n (.) is an arbitrary (perhaps random) assignment of codewords to data sequences V n , and g n (.) is any decoding function (assignment of estimates to output sequences Y n . By Fano’s inequality, we must have (7.143) Hence for the code, (7.144) (7.145) (7.146) (7.147) (7.148) (7.149) where (a) follows from the definition of entropy rate of a stationary process, (b) follows from Fano’s inequality, (c) follows from the data-processing inequality (since V n → X n → Y n forms a Markov chain) and (d) follows from the memorylessness of the channel. Now letting n → ∞, we have Pr( n V n ) → 0 and hence (7.150) Hence, we can transmit a stationary ergodic source over a channel if and only if its entropy rate is less than the capacity of the channel. The joint source-channel separation theorem enables us to consider the problem of source coding separately from the problem of channel coding. The source coder tries to find the most efficient representation of the source, and the channel coder encodes the message to combat the noise and errors introduced by the channel. The separation theorem says that the separate encoders ( Figure 7.15 ) can achieve the same rates as the joint encoder ( Figure 7.14 ). FIGURE 7.15. Separate source and channel coding. With this result, we have tied together the two basic theorems of information theory: data compression and data transmission. We will try to summarize the proofs of the two results in a few words. The data compression theorem is a consequence of the AEP, which shows that there exists a “small” subset (of size 2 nH ) of all possible source sequences that contain most of the probability and that we can therefore represent the source with a small probability of error using H bits per symbol. The data transmission theorem is based on the joint AEP; it uses the fact that for long block lengths, the output sequence of the channel is very likely to be jointly typical with the input codeword, while any other codeword is jointly typical with probability ≈2 − nI . Hence, we can use about 2 nI . codewords and still have negligible probability of error. The source–channel separation theorem shows that we can design the source code and the channel code separately and combine the results to achieve optimal performance. SUMMARY Channel capacity . The logarithm of the number of distinguishable inputs is given by Examples Binary symmetric channel: C = 1 − H(p) . Binary erasure channel: C = 1 − α. Symmetric channel: C = log | | − H (row of transition matrix). Properties of C 1. 0 ≤ C ≤ min{log|χ| log | |. 2. I (X; Y) is a continuous concave function of p(x) . Joint typicality . The set of jointly typical sequences {( x n , y n )} with respect to the distribution p(x, y) is given by (7.151) (7.152) (7.153) (7.154) where p(x n , y n )= . Joint AEP . Let ( X n , Y n ) be sequences of length n drawn i.i.d. according to . Then: 1. Pr(( X n , Y n ) as n → ∞. 2. 3. If ~ p(x n )p(y n ) , then Pr ≤ 2 − n ( I ( X;Y )−3 ) . Channel coding theorem . All rates below capacity C are achievable, and all rates above capacity are not; that is, for all rates R < C , there exists a sequence of (2 nR , n ) codes with probability of error λ ( n ) → 0. Conversely, for rates R > C , λ (n) is bounded away from 0. Feedback capacity . Feedback does not increase capacity for discrete memoryless channels (i.e., C F B = C ). Source–channel theorem . A stochastic process with entropy rate H cannot be sent reliably over a discrete memoryless channel if H > C . Conversely, if the process satisfies the AEP, the source can be transmitted reliably if H < C . PROBLEMS 7.1 Preprocessing the output . One is given a communication channel with transition probabilities p(y|x) and channel capacity C = max p(x ) I (X; Y) . A helpful statistician preprocesses the output by forming = g(Y) . He claims that this will strictly improve the capacity. (a) Show that he is wrong. (b) Under what conditions does he not strictly decrease the capacity? 7.2 Additive noise channel . Find the channel capacity of the following discrete memoryless channel: where Pr{Z = 0} = Pr{ Z = a } = The alphabet for x is X = {0, 1}. Assume that Z is independent of X . Observe that the channel capacity depends on the value of a . 7.3 Channels with memory have higher capacity . Consider a binary symmetric channel with Y i = X i ⊕ Z i , where ⊕ is mod 2 addition, and X i , Y i {0, 1}. Suppose that (Z i 1 has constant marginal probabilities Pr{ Z i = 1} = p = 1 − Pr{ Z i = 0}, but that Z 1 , Z 2 , Z n are not necessarily independent. Assume that Z n is independent of the input X n . Let C = 1 − H(p , 1 − p ). Show that max p ( x 1 , x 2 ,…, x n ) I ( X 1 , X 2 ,…, X n ; Y 1 , Y 2 ,…, Y n ) ≥ nC . 7.4 Channel capacity . Consider the discrete memoryless channel Y = X + Z (mod 11), where and X {0, 1,…, 10}. Assume that Z is independent of X . (a) Find the capacity. (b) What is the maximizing p * (x) ? 7.5 Using two channels at once . Consider two discrete memoryless channels ( χ 1 , p ( y 1 | x 1 ), 1 ) and ( X 2 , p ( y 2 | x 2 ), 2 ) with capacities C 1 and C 2 , respectively. A new channel ( χ 1 × χ 2 , p ( y 1 | x 1 ) × p ( y 2 | x 2 ), 1 × 2 ) is formed in which x 1 χ 1 and x 2 X 2 are sent simultaneously, resulting in y 1 , y 2 . Find the capacity of this channel. 7.6 Noisy typewriter . Consider a 26-key typewriter. (a) If pushing a key results in printing the associated letter, what is the capacity C in bits? (b) Now suppose that pushing a key results in printing that letter or the next (with equal probability). Thus, A → A or B ,…, Z → Z or A . What is the capacity? (c) What is the highest rate code with block length one that you can find that achieves zero probability of error for the channel in part (b)? 7.7 Cascade of binary symmetric channels . Show that a cascade of n identical independent binary symmetric channels, each with raw error probability p , is equivalent to a single BSC with error probability (1 − (1 − 2 p ) n ) and hence that I ( X 0 ; X n ) = 0 if p ≠ 0, 1. No encoding or decoding takes place at the intermediate terminals X 1 ,…, X n −1 . Thus, the capacity of the cascade tends to zero. 7.8 Z-channel . The Z -channel has binary input and output alphabets and transition probabilities p(y|x) given by the following matrix: Find the capacity of the Z -channel and the maximizing input probability distribution. 7.9 Suboptimal codes . For the Z -channel of Problem 7.8, assume that we choose a (2 nR , n ) code at random, where each codeword is a sequence of fair coin tosses. This will not achieve capacity. Find the maximum rate R such that the probability of error P e (n) , averaged over the randomly generated codes, tends to zero as the block length n tends to infinity. 7.10 Zero-error capacity . A channel with alphabet {0, 1, 2, 3, 4} has transition probabilities of the form (a) Compute the capacity of this channel in bits. (b) The zero-error capacity of a channel is the number of bits per channel use that can be transmitted with zero probability of error. Clearly, the zero-error capacity of this pentagonal channel is at least 1 bit (transmit 0 or 1 with probability 1/2). Find a block code that shows that the zero-error capacity is greater than 1 bit. Can you estimate the exact value of the zero-error capacity? (Hint: Consider codes of length 2 for this channel.) The zero-error capacity of this channel was finally found by Lovasz [365]. 7.11 Time-varying channels . Consider a time-varying discrete memoryless channel. Let Y 1 , Y 2 ,…, Y n be conditionally independent given X 1 , X 2 ,…, X n , with conditional distribution given by p ( y | x ) = p i ( y i | x i ). Let X = ( X 1 , X 2 , …, X n ), Y = ( Y 1 , Y 2 ,…, Y n ). Find max p ( x ) I (X; Y ). 7.12 Unused symbols . Show that the capacity of the channel with probability transition matrix (7.155) is achieved by a distribution that places zero probability on one of input symbols. What is the capacity of this channel? Give an intuitive reason why that letter is not used. 7.13 Erasures and errors in a binary channel . Consider a channel with binary inputs that has both erasures and errors. Let the probability of error be and the probability of erasure be α, so the channel is follows: (a) Find the capacity of this channel. (b) Specialize to the case of the binary symmetric channel (α = 0). (c) Specialize to the case of the binary erasure channel ( = 0). 7.14 Channels with dependence between the letters . Consider the following channel over a binary alphabet that takes in 2-bit symbols and produces a 2-bit output, as determined by the following mapping: 00 → 01, 01 → 10, 10 → 11, and 11 → 00. Thus, if the 2-bit sequence 01 is the input to the channel, the output is 10 with probability 1. Let X 1 , X 2 denote the two input symbols and Y 1 , Y 2 denote the corresponding output symbols. (a) Calculate the mutual information I ( X 1 , X 2 ; Y 1 , Y 2 ) as a function of the input distribution on the four possible pairs of inputs. (b) Show that the capacity of a pair of transmissions on this channel is 2 bits. (c) Show that under the maximizing input distribution, I ( X 1 ; Y 1 ) = 0. Thus, the distribution on the input sequences that achieves capacity does not necessarily maximize the mutual information between individual symbols and their corresponding outputs. 7.15 Jointly typical sequences . As we did in Problem 3.13 for the typical set for a single random variable, we will calculate the jointly typical set for a pair of random variables connected by a binary symmetric channel, and the probability of error for jointly typical decoding for such a channel. We consider a binary symmetric channel with crossover probability 0.1. The input distribution that achieves capacity is the uniform distribution [i.e., p(x) = ( , )] which yields the joint distribution p(x, y) for this channel is given by The marginal distribution of Y is also ( , ) (a) Calculate H(X) , H(Y) , H(X, Y) , and I ( X; Y ) for the joint distribution above. (b) Let X 1 , X 2 ,…, X n be drawn i.i.d. according the Bernoulli( ) distribution. Of the 2 n possible input sequences of length n , which of them are typical [i.e., member of ( X ) for = 0.2]? Which are the typical sequences in (Y)? (c) The jointly typical set ( X, Y ) is defined as the set of sequences that satisfy equations (7.35 – 7.37 ). The first two equations correspond to the conditions that x n and y n are in ( X ) and ( Y ), respectively. Consider the last condition, which can be rewritten to state that − log p ( x n , y n ) (H(X, Y) − , H(X, Y) + ). Let k be the number of places in which the sequence x n differs from y n ( k is a function of the two sequences). Then we can write (7.156) (7.157) (7.158) An alternative way at looking at this probability is to look at the binary symmetric channel as in additive channel Y = X ⊕ Z , where Z is a binary random variable that is equal to 1 with probability p , and is independent of X . In this case, (7.159) (7.160) (7.161) (7.162) Show that the condition that (x n , y n ) being jointly typical is equivalent to the condition that x n is typical and z n = y n − x n is typical. (d) We now calculate the size of ( Z ) for n = 25 and = 0.2. As in Problem 3.13, here is a table of the probabilities and numbers of sequences with k ones: [Sequences with more than 12 ones are omitted since their total probability is negligible (and they are not in the typical set).] What is the size of the set (Z)? (e) Now consider random coding for the channel, as in the proof of the channel coding theorem. Assume that 2 nR codewords X n (1), X n (2),…, X n (2 n R ) are chosen uniformly over the 2 n possible binary sequences of length n . One of these codewords is chosen and sent over the channel. The receiver looks at the received sequence and tries to find a codeword in the code that is jointly typical with the received sequence. As argued above, this corresponds to finding a codeword X n (i) such that Y n − X n (i) ( Z ). For a fixed codeword x n (i) , what is the probability that the received sequence Y n is such that (x n (i) , Y n ) is jointly typical? (f) Now consider a particular received sequence y n = 000000 … 0, say. Assume that we choose a sequence X n at random, uniformly distributed among all the 2 n possible binary n -sequences. What is the probability that the chosen sequence is jointly typical with this y n ? [ Hint: This is the probability of all sequences x n such that y n − x n ( Z ).] (g) Now consider a code with 2 9 = 512 codewords of length 25 chosen at random, uniformly distributed among all the 2 n sequences of length n = 25. One of these codewords, say the one corresponding to i = 1, is chosen and sent over the channel. As calculated in part (e), the received sequence, with high probability, is jointly typical with the codeword that was sent. What is the probability that one or more of the other codewords (which were chosen at random, independent of the sent codeword) is jointly typical with the received sequence? [Hint: You could use the union bound, but you could also calculate this probability exactly, using the result of part (f) and the independence of the codewords.] (h) Given that a particular codeword was sent, the probability of error (averaged over the probability distribution of the channel and over the random choice of other codewords) can be written as (7.163) There are two kinds of error: the first occurs if the received sequence y n is not jointly typical with the transmitted codeword, and the second occurs if there is another codeword jointly typical with the received sequence. Using the result of the preceding parts, calculate this probability of error. By the symmetry of the random coding argument, this does not depend on which codeword was sent. The calculations above show that average probability of error for a random code with 512 codewords of length 25 over the binary symmetric channel of crossover probability 0.1 is about 0.3774. This seems quite high, but the reason for this is that the value of that we have chosen is too large. By choosing a smaller and a larger n in the definitions of , we can get the probability of error to be as small as we want as long as the rate of the code is less than I ( X ; Y ) − 3 . Also note that the decoding procedure described in the problem is not optimal. The optimal decoding procedure is maximum likelihood (i.e., to choose the codeword that is closest to the received sequence). It is possible to calculate the average probability of error for a random code for which the decoding is based on an approximation to maximum likelihood decoding, where we decode a received sequence to the unique codeword that differs from the received sequence in ≤ 4 bits, and declare an error otherwise. The only difference with the jointly typical decoding described above is that in the case when the codeword is equal to the received sequence! The average probability of error for this decoding scheme can be shown to be about 0.285. 7.16 Encoder and decoder as part of the channel . Consider a binary symmetric channel with crossover probability 0.1. A possible coding scheme for this channel with two codewords of length 3 is to encode message a 1 as 000 and a 2 as 111. With this coding scheme, we can consider the combination of encoder, channel, and decoder as forming a new BSC, with two inputs a 1 and a 2 and two outputs a 1 and a 2 . (a) Calculate the crossover probability of this channel. (b) What is the capacity of this channel in bits per transmission of the original channel? (c) What is the capacity of the original BSC with crossover probability 0.1? (d) Prove a general result that for any channel, considering the encoder, channel, and decoder together as a new channel from messages to estimated messages will not increase the capacity in bits per transmission of the original channel. 7.17 Codes of length 3 for a BSC and BEC . In Problem 7.16, the probability of error was calculated for a code with two codewords of length 3 (000 and 111) sent over a binary symmetric channel with crossover probability . For this problem, take = 0.1. (a) Find the best code of length 3 with four codewords for this channel. What is the probability of error for this code? (Note that all possible received sequences should be mapped onto possible codewords.) (b) What is the probability of error if we used all eight possible sequences of length 3 as codewords? (c) Now consider a binary erasure channel with erasure probability 0.1. Again, if we used the two-codeword code 000 and 111, received sequences 00E, 0E0, E00, 0EE, E0E, EE0 would all be decoded as 0, and similarly, we would decode 11E, 1E1, E11, 1EE, E1E, EE1 as 1. If we received the sequence EEE, we would not know if it was a 000 or a 111 that was sent–so we choose one of these two at random, and are wrong half the time. What is the probability of error for this code over the erasure channel? (d) What is the probability of error for the codes of parts (a) and (b) when used over the binary erasure channel? 7.18 Channel capacity . Calculate the capacity of the following channels with probability transition matrices: (a) χ = = {0, 1, 2} (7.164) (b) χ = = {0, 1, 2} (7.165) (c) χ = = {0, 1, 2, 3} (7.166) 7.19 Capacity of the carrier pigeon channel . Consider a commander of an army besieged in a fort for whom the only means of communication to his allies is a set of carrier pigeons. Assume that each carrier pigeon can carry one letter (8 bits), that pigeons are released once every 5 minutes, and that each pigeon takes exactly 3 minutes to reach its destination. (a) Assuming that all the pigeons reach safely, what is the capacity of this link in bits/hour? (b) Now assume that the enemies try to shoot down the pigeons and that they manage to hit a fraction α of them. Since the pigeons are sent at a constant rate, the receiver knows when the pigeons are missing. What is the capacity of this link? (c) Now assume that the enemy is more cunning and that every time they shoot down a pigeon, they send out a dummy pigeon carrying a random letter (chosen uniformly from all 8-bit letters). What is the capacity of this link in bits/hour? Set up an appropriate model for the channel in each of the above cases, and indicate how to go about finding the capacity. 7.20 Channel with two independent looks at Y . Let Y 1 and Y 2 be conditionally independent and conditionally identically distributed given X . (a) Show that I ( X ; Y 1 , Y 2 ) = 2 I ( X ; Y 1 ) − I ( Y 1 , Y 2 ). (b) Conclude that the capacity of the channel is less than twice the capacity of the channel 7.21 Tall, fat people . Suppose that the average height of people in a room is 5 feet. Suppose that the average weight is 100 lb. (a) Argue that no more than one-third of the population is 15 feet tall. (b) Find an upper bound on the fraction of 300-lb 10-footers in the room. 7.22 Can signal alternatives lower capacity? Show that adding a row to a channel transition matrix does not decrease capacity. 7.23 Binary multiplier channel (a) Consider the channel Y = X Z , where X and Z are independent binary random variables that take on values 0 and 1. Z is Bernoulli(α) [i.e., P ( Z = 1) = α]. Find the capacity of this channel and the maximizing distribution on X . (b) Now suppose that the receiver can observe Z as well as Y . What is the capacity? 7.24 Noise alphabets . Consider the channel χ = {0, 1, 2, 3}, where Y = X + Z , and Z is uniformly distributed over three distinct integer values = { z 1 , z 2 , z 3 }. (a) What is the maximum capacity over all choices of the Z alphabet? Give distinct integer values z 1 , z 2 , z 3 and a distribution on χ achieving this. (b) What is the minimum capacity over all choices for the Z alphabet? Give distinct integer values z 1 , z 2 , z 3 and a distribution on χ achieving this. 7.25 Bottleneck channel . Suppose that a signal X χ = {1, 2,…, m } goes through an intervening transition X → V → Y : where x = {1, 2,…, m }, y = {1, 2,…, m }, and ν = {1, 2,…, k }. Here p ( ν | x ) and p ( y | ν ) are arbitrary and the channel has transition probability p ( y | x ) = ∑ v p ( ν | x ) p ( y | ν ). Show that C ≤ log k . 7.26 Noisy typewriter . Consider the channel with x , y {0, 1, 2, 3} and transition probabilities p ( y | x ) given by the following matrix: (a) Find the capacity of this channel. (b) Define the random variable z = g ( y ), where For the following two PMFs for x , compute I ( X ; Z ): (i) (ii) (c) Find the capacity of the channel between x and z , specifically where x {0, 1, 2, 3}, z { A , B }, and the transition probabilities P ( z | x ) are given by (d) For the X distribution of part (i) of (b), does X → Z → Y form a Markov chain? 7.27 Erasure channel . Let { χ , p ( y | x ), } be a discrete memoryless channel with capacity C . Suppose that this channel is cascaded immediately with an erasure channel { , p ( s | y ), } that erases α of its symbols. Specifically, S = { y 1 , y 2 ,…, y m , e }, and Determine the capacity of this channel. 7.28 Choice of channels . Find the capacity C of the union of two channels (χ 1 , p 1 ( y 1 | x 1 ), 1 ) and (χ 2 , p 2 ( y 2 | x 2 ), 2 ), where at each time, one can send a symbol over channel 1 or channel 2 but not both. Assume that the output alphabets are distinct and do not intersect. (a) Show that 2 C = 2 C 1 + 2 C 2 . Thus, 2 c is the effective alphabet size of a channel with capacity C . (b) Compare with Problem 2.10 where 2 H = 2 H 1 + 2 H 2 , and interpret part, (a) in terms of the effective number of noise-free symbols. (c) Use the above result to calculate the capacity of the following channel. 7.29 Binary multiplier channel (a) Consider the discrete memoryless channel Y = X Z , where X and Z are independent binary random variables that take on values 0 and 1. Let P ( Z = 1) = α. Find the capacity of this channel and the maximizing distribution on X . (b) Now suppose that the receiver can observe Z as well as Y . What is the capacity? 7.30 Noise alphabets . Consider the channel χ = {0, 1, 2, 3}, where Y = X + Z , and Z is uniformly distributed over three distinct integer values = { z 1 , z 2 , z 3 }. (a) What is the maximum capacity over all choices of the alphabet? Give distinct integer values z 1 , z 2 , z 3 and a distribution on χ achieving this. (b) What is the minimum capacity over all choices for the alphabet? Give distinct integer values z 1 , z 2 , z 3 and a distribution on χ achieving this. 7.31 Source and channel . We wish to encode a Bernoulli( α ) process V 1 , V 2 ,… for transmission over a binary symmetric channel with crossover probability p . Find conditions on α and p so that the probability of error P ( ≠ V n ) can be made to go to zero as n → ∞. 7.32 Random 20 questions . Let X be uniformly distributed over {1, 2,…, m }. Assume that m = 2 n . We ask random questions: Is X S 1 ? Is X S 2 ? … until only one integer remains. All 2 m subsets S of {1, 2,…, m } are equally likely. (a) How many deterministic questions are needed to determine X ? (b) Without loss of generality, suppose that X = 1 is the random object. What is the probability that object 2 yields the same answers as object 1 for k questions? (c) What is the expected number of objects in {2, 3,…, m } that have the same answers to the questions as those of the correct object 1? (d) Suppose that we ask random questions. What is the expected number of wrong objects agreeing with the answers? (e) Use Markov’s inequality Pr{ X ≥ t μ} ≤ , to show that the probability of error (one or more wrong object remaining) goes to zero as n → ∞. 7.33 BSC with feedback . Suppose that feedback is used on a binary symmetric channel with parameter p . Each time a Y is received, it becomes the next transmission. Thus, X 1 is Bern( ), X 2 = Y 1 , X 3 = Y 2 ,…, X n = Y n −1 . (a) Find lim n →∞ I ( X n ; Y n ). (b) Show that for some values of p , this can be higher than capacity. (c) Using this feedback transmission scheme, X n ( W , Y n ) = ( X 1 ( W ), Y 1 , Y 2 ,…, Y m −1 ), what is the asymptotic communication rate achieved; that is, what is lim n →∞ , I ( W ; Y n )? 7.34 Capacity . Find the capacity of (a) Two parallel BSCs: (b) BSC and a single symbol: (c) BSC and a ternary channel: (d) Ternary channel: (7.167) 7.35 Capacity . Suppose that channel has capacity C , where is an m × n channel matrix. (a) What is the capacity of (b) What about the capacity of where I k if the k × k identity matrix. 7.36 Channel with memory . Consider the discrete memoryless channel Y i = Z i X i with input alphabet X i {−1, 1}. (a) What is the capacity of this channel when { Z i } is i.i.d. with (7.168) Now consider the channel with memory. Before transmission begins, Z is randomly chosen and fixed for all time. Thus, Y i = ZX i . (b) What is the capacity if (7.169) 7.37 Joint typicality . Let ( X i , Y i , Z i ) be i.i.d. according to p ( x , y , z ). We will say that ( x n , y n , z n ) is jointly typical [written ( x n , y n , z n ) if p ( x n ) 2 − n ( H ( X )± ). p ( y n ) 2 − n ( H ( Y )± ). p ( z n ) 2 − n ( H ( Z )± ). p ( x n , y n ) 2 − n ( H ( X , Y )± ). p ( x n , z n ) 2 − n ( H ( X , Z )± ). p ( y n , z n ) 2 − n ( H ( Y , Z )± ). p ( x n y n z n ) 2 − n ( H ( X , Y , Z )± ). Now suppose that is drawn according to p ( x n ) p ( y n ) p ( z n ). Thus, have the same marginals as p ( x n , y n , z n ) but are independent. Find (bounds on) in terms of the entropies H ( X ), H ( Y ), H ( Z ), H ( X , Y ), H ( X , Z ), H ( Y , Z ), and H ( X , Y , Z ). HISTORICAL NOTES The idea of mutual information and its relationship to channel capacity was developed by Shannon in his original paper [472]. In this paper, he stated the channel capacity theorem and outlined the proof using typical sequences in an argument similar to the one described here. The first rigorous proof was due to Feinstein [205], who used a painstaking “cookie-cutting” argument to find the number of codewords that can be sent with a low probability of error. A simpler proof using a random coding exponent was developed by Gallager [224]. Our proof is based on Cover [121] and on Forney’s unpublished course notes [216]. The converse was proved by Fano [201], who used the inequality bearing his name. The strong converse was first proved by Wolfowitz [565], using techniques that are closely related to typical sequences. An iterative algorithm to calculate the channel capacity was developed independently by Arimoto [25] and Blahut [65]. The idea of the zero-error capacity was developed by Shannon [474]; in the same paper, he also proved that feedback does not increase the capacity of a discrete memoryless channel. The problem of finding the zero-error capacity is essentially combinatorial; the first important result in this area is due to Lovasz [365]. The general problem of finding the zero error capacity is still open; see a survey of related results in Körner and Orlitsky [327]. Quantum information theory, the quantum mechanical counterpart to the classical theory in this chapter, is emerging as a large research area in its own right and is well surveyed in an article by Bennett and Shor [49] and in the text by Nielsen and Chuang [395].

Chapter 8: Differential Entropy CHAPTER 8 DIFFERENTIAL ENTROPY We now introduce the concept of differential entropy , which is the entropy of a continuous random variable. Differential entropy is also related to the shortest description length and is similar in many ways to the entropy of a discrete random variable. But there are some important differences, and there is need for some care in using the concept. 8.1 DEFINITIONS Definition Let X be a random variable with cumulative distribution function F ( x ) = Pr( X ≤ x ). If F ( x ) is continuous, the random variable is said to be continuous. Let f ( x ) = F ′ ( x ) when the derivative is defined. If ∫ ∞ −∞ f ( x ) = 1, f ( x ) is called the probability density function for X . The set where f ( x ) > 0 is called the support set of X . Definition The differential entropy h(X) of a continuous random variable X with density f ( x ) is defined as (8.1) where S is the support set of the random variable. As in the discrete case, the differential entropy depends only on the probability density of the random variable, and therefore the differential entropy is sometimes written as h ( f ) rather than h ( X ). Remark As in every example involving an integral, or even a density, we should include the statement if it exists . It is easy to construct examples of random variables for which a density function does not exist or for which the above integral does not exist. Example 8.1.1 ( Uniform distribution ) Consider a random variable distributed uniformly from 0 to a so that its density is 1/ a from 0 to a and 0 elsewhere. Then its differential entropy is (8.2) Note: For a < 1, log a < 0, and the differential entropy is negative. Hence, unlike discrete entropy, differential entropy can be negative. However, 2 h ( X ) = 2 log a = a is the volume of the support set, which is always nonnegative, as we expect. Example 8.1.2 ( Normal distribution ) Let X ~ . Then calculating the differential entropy in nats, we obtain (8.3) (8.4) (8.5) (8.6) (8.7) (8.8) Changing the base of the logarithm, we have (8.9) 8.2 AEP FOR CONTINUOUS RANDOM VARIABLES One of the important roles of the entropy for discrete random variables is in the AEP, which states that for a sequence of i.i.d. random variables, p ( X 1 , X 2 ,…, X n ) is close to 2 − nH(X) with high probability. This enables us to define the typical set and characterize the behavior of typical sequences. We can do the same for a continuous random variable. Theorem 8.2.1 Let X 1 , X 2 ,…, X n be a sequence of random variables drawn i.i.d. according to the density f (x). Then (8.10) Proof: The proof follows directly from the weak law of large numbers. This leads to the following definition of the typical set. Definition For > 0 and any n , we define the typical set with respect to f ( x ) as follows: (8.11) where f ( x 1 , x 2 ,…, x n ) = . The properties of the typical set for continuous random variables parallel those for discrete random variables. The analog of the cardinality of the typical set for the discrete case is the volume of the typical set for continuous random variables. Definition The volume Vol( A ) of a set is defined as (8.12) Theorem 8.2.2 The typical set has the following properties: 1. Pr for n sufficiently large . 2. Vol for all n . 3. Vol for n sufficiently large . Proof: By Theorem 8.2.1, in probability, establishing property 1. Also, (8.13) (8.14) (8.15) (8.16) (8.17) Hence we have property 2. We argue further that the volume of the typical set is at least this large. If n is sufficiently large so that property 1 is satisfied, then (8.18) (8.19) (8.20) (8.21) establishing property 3. Thus for n sufficiently large, we have (8.22) Theorem 8.2.3 The set is the smallest volume set with probability ≥ 1 − , to first order in the exponent . Proof: Same as in the discrete case. This theorem indicates that the volume of the smallest set that contains most of the probability is approximately 2 nh . This is an n -dimensional volume, so the corresponding side length is (2 nh ) = 2 h . This provides an interpretation of the differential entropy: It is the logarithm of the equivalent side length of the smallest set that contains most of the probability. Hence low entropy implies that the random variable is confined to a small effective volume and high entropy indicates that the random variable is widely dispersed. Note . Just as the entropy is related to the volume of the typical set, there is a quantity called Fisher information which is related to the surface area of the typical set. We discuss Fisher information in more detail in Sections 11.10 and 17.8. 8.3 RELATION OF DIFFERENTIAL ENTROPY TO DISCRETE ENTROPY Consider a random variable X with density f ( x ) illustrated in Figure 8.1 . Suppose that we divide the range of X into bins of length Δ. Let us assume that the density is continuous within the bins. Then, by the mean value theorem, there exists a value x i within each bin such that FIGURE 8.1. Quantization of a continuous random variable. (8.23) Consider the quantized random variable X Δ , which is defined by (8.24) Then the probability that X Δ = x i is (8.25) The entropy of the quantized version is (8.26) (8.27) (8.28) (8.29) since ∑ f ( x i ) Δ = f ( x ) = 1. If f ( x ) log f ( x ) is Riemann integrable (a condition to ensure that the limit is well defined [556]), the first term in (8.29) approaches the integral of − f ( x ) log f ( x ) as Δ → 0 by definition of Riemann integrability. This proves the following. Theorem 8.3.1 If the density f ( x ) of the random variable X is Riemann integrable, then (8.30) Thus, the entropy of an n-bit quantization of a continuous random variable X is approximately h ( X ) + n . Example 8.3.1 1. If X has a uniform distribution on [0, 1] and we let Δ = 2 −n , then h = 0, H ( X Δ ) = n , and n bits suffice to describe X to n bit accuracy. 2. If X is uniformly distributed on , the first 3 bits to the right of the decimal point must be 0. To describe X to n -bit accuracy requires only n − 3 bits, which agrees with h ( X ) = − 3. 3. If X ~ (0, σ 2 ) with σ 2 = 100, describing X to n bit accuracy would require on the average n + log(2π e σ 2 ) = n + 5.37 bits. In general, h ( X ) + n is the number of bits on the average required to describe X to n -bit accuracy. The differential entropy of a discrete random variable can be considered to be − ∞. Note that 2 −∞ = 0, agreeing with the idea that the volume of the support set of a discrete random variable is zero. 8.4 JOINT AND CONDITIONAL DIFFERENTIAL ENTROPY As in the discrete case, we can extend the definition of differential entropy of a single random variable to several random variables. Definition The differential entropy of a set X 1 , X 2 ,…, X n of random variables with density f ( x 1 , x 2 ,…, x n ) is defined as (8.31) Definition If X, Y have a joint density function f ( x , y ), we can define the conditional differential entropy h ( X | Y ) as (8.32) Since in general f ( x | y ) = f ( x , y ) / f ( y ), we can also write (8.33) But we must be careful if any of the differential entropies are infinite. The next entropy evaluation is used frequently in the text. Theorem 8.4.1 (Entropy of a multivariate normal distribution) Let X 1 , X 2 ,…, X n have a multivariate normal distribution with mean μ and covariance matrix K. Then (8.34) where | K | denotes the determinant of K . Proof: The probability density function of X 1 , X 2 ,…, X n is (8.35) Then (8.36) (8.37) (8.38) (8.39) (8.40) (8.41) (8.42) (8.43) (8.44) (8.45) 8.5 RELATIVE ENTROPY AND MUTUAL INFORMATION We now extend the definition of two familiar quantities, D ( f || g ) and I ( X ; Y ), to probability densities. Definition The relative entropy (or Kullback–Leibler distance ) D ( f || g ) between two densities f and g is defined by (8.46) Note that D ( f || g ) is finite only if the support set of f is contained in the support set of g . [Motivated by continuity, we set 0 log = 0.] Definition The mutual information I ( X ; Y ) between two random variables with joint density f ( x , y ) is defined as (8.47) From the definition it is clear that (8.48) and (8.49) The properties of D ( f || g ) and I ( X ; Y ) are the same as in the discrete case. In particular, the mutual information between two random variables is the limit of the mutual information between their quantized versions, since (8.50) (8.51) (8.52) More generally, we can define mutual information in terms of finite partitions of the range of the random variable. Let χ be the range of a random variable X . A partition of χ is a finite collection of disjoint sets P i such that ∪ i P i = χ. The quantization of X by (denoted [ X ] ) is the discrete random variable defined by (8.53) For two random variables X and Y with partitions and , we can calculate the mutual information between the quantized versions of X and Y using (2.28). Mutual information can now be defined for arbitrary pairs of random variables as follows: Definition The mutual information between two random variables X and Y is given by (8.54) where the supremum is over all finite partitions and . This is the master definition of mutual information that always applies, even to joint distributions with atoms, densities, and singular parts. Moreover, by continuing to refine the partitions P and Q , one finds a monotonically increasing sequence I ([ X ] p ; [ Y ] Q ) I . By arguments similar to (8.52), we can show that this definition of mutual information is equivalent to (8.47) for random variables that have a density. For discrete random variables, this definition is equivalent to the definition of mutual information in (2.28). Example 8.5.1 ( Mutual information between correlated Gaussian random variables with correlation ρ ) Let ( X , Y ) ~ (0, K ), where (8.55) Then h ( X ) = h ( Y ) = log(2π e )σ 2 and h ( X , Y ) = log(2π e ) 2 | K | = log(2π e ) 2 σ 4 (1 − ρ 2 ), and therefore (8.56) If ρ = 0, X and Y are independent and the mutual information is 0. If ρ = ± 1, X and Y are perfectly correlated and the mutual information is infinite. 8.6 PROPERTIES OF DIFFERENTIAL ENTROPY, RELATIVE ENTROPY, AND MUTUAL INFORMATION Theorem 8.6.1 (8.57) with equality if f = g almost everywhere ( a.e .). Proof: Let S be the support set of f . Then (8.58) (8.59) (8.60) (8.61) We have equality iff we have equality in Jensen’s inequality, which occurs iff f = g a.e. Corollary I ( X ; Y ) ≥ 0 with equality iff X and Y are independent . Corollary h ( X ( Y ) ≤ h ( X ) with equality iff X and Y are independent . Theorem 8.6.2 ( Chain rule for differential entropy ) (8.62) Proof: Follows directly from the definitions. Corollary (8.63) with equality iff X 1 , X 2 ,…, X n are independent . Proof: Follows directly from Theorem 8.6.2 and the corollary to Theorem 8.6.1. Application (Hadamard’s inequality’) If we let X ~ (0, K ) be a multivariate normal random variable, calculating the entropy in the above inequality gives us (8.64) which is Hadamard’s inequality. A number of determinant inequalities can be derived in this fashion from information-theoretic inequalities (Chapter 17) . Theorem 8.6.3 (8.65) Translation does not change the differential entropy . Proof: Follows directly from the definition of differential entropy. Theorem 8.6.4 (8.66) Proof: Let Y = aX . Then f y ( y ) = , and (8.67) (8.68) (8.69) (8.70) after a change of variables in the integral. Similarly, we can prove the following corollary for vector-valued random variables. Corollary (8.71) We now show that the multivariate normal distribution maximizes the entropy over all distributions with the same covariance. Theorem 8.6.5 Let the random vector have zero mean and covariance K = E XX t (i.e., K ij = EX i X j , 1 ≤ i , j ≤ n ). Then h ( X ) ≤ log(2π e ) n | K |, with equality iff X ~ (0, K ). Proof: Let g ( x ) be any density satisfying ∫ g ( x ) x i x i d x = K ii for all i, j . Let ϕ K be the density of a (0, K ) vector as given in (8.35) , where we set μ = 0. Note that log ϕ K ( x ) is a quadratic form and ∫ x i x j ϕ k ( x ) d x = K ij . Then (8.72) (8.73) (8.74) (8.75) (8.76) where the substitution ∫ g log ϕ K = ∫ ϕ K log ϕ K follows from the fact that g and ϕ K yield the same moments of the quadratic form log ϕ K ( x ). In particular, the Gaussian distribution maximizes the entropy over all distributions with the same variance. This leads to the estimation counterpart to Fano’s inequality. Let X be a random variable with differential entropy h ( X ). Let be an estimate of X , and let E ( X − ) 2 be the expected prediction error. Let h ( X ) be in nats. Theorem 8.6.6 ( Estimation error and differential entropy ) For any random variable X and estimator , with equality if and only if X is Gaussian and is the mean of X . Proof: Let be any estimator of X; then (8.77) (8.78) (8.79) (8.80) where (8.78) follows from the fact that the mean of X is the best estimator for X and the last inequality follows from the fact that the Gaussian distribution has the maximum entropy for a given variance. We have equality only in (8.78) only if is the best estimator (i.e., is the mean of X and equality in (8.80) only if X is Gaussian). Corollary Given side information Y and estimator ( Y ), it follows that SUMMARY (8.81) (8.82) (8.83) (8.84) (8.85) (8.86) (8.87) (8.88) (8.89) (8.90) (8.91) (8.92) 2 nH ( X ) is the effective alphabet size for a discrete random variable. 2 nh ( X ) is the effective support set size for a continuous random variable. 2 C is the effective alphabet size of a channel of capacity C . PROBLEMS 8.1 Differential entropy . Evaluate the differential entropy h ( X ) = − ∫ f In f for the following: (a) The exponential density, f ( x ) = λ e −λ x , x ≥ 0. (b) The Laplace density, f ( x ) = (c) The sum of X 1 and X 2 , where X 1 and X 2 are independent normal random variables with means μ i and variances , i = 1, 2. 8.2 Concavity of determinants . Let K 1 and K 2 be two symmetric nonnegative definite n × n matrices. Prove the result of Ky Fan [199]: where | K | denotes the determinant of K . [ Hint: Let Z = X θ , where X 1 ~ N (0, K 1 ), X 2 ~ N (0, K 2 ) and θ = Bernoulli(λ). Then use h ( Z | θ) ≤ h ( Z ).] 8.3 Uniformly distributed noise . Let the input random variable X to a channel be uniformly distributed over the interval − ≤ x ≤ + . Let the output of the channel be Y = X + Z , where the noise random variable is uniformly distributed over the interval − a /2 ≤ z ≤ + a /2. (a) Find I ( X ; Y ) as a function of a . (b) For a = 1 find the capacity of the channel when the input X is peak-limited; that is, the range of X is limited to − ≤ x ≤ + . What probability distribution on X maximizes the mutual information I ( X ; Y )? (c) (Optional) Find the capacity of the channel for all values of a , again assuming that the range of X is limited to − ≤ x ≤ + . 8.4 Quantized random variables . Roughly how many bits are required on the average to describe to three-digit accuracy the decay time (in years) of a radium atom if the half-life of radium is 80 years? Note that half-life is the median of the distribution. 8.5 Scaling . Let h ( X ) = − ∫ f ( x ) log f ( x ) d x . Show h ( A X ) = log | det( A ) | + h ( X ). 8.6 Variational inequality . Verify for positive random variables X that (8.93) where E p ( X ) = ∑ x x P ( x ) and D ( Q || P ) = , and the supremum is over all Q ( x ) ≥ 0, ∑ Q ( x ) = 1. It is enough to extremize J ( Q ) = E Q In X − D ( Q || P )+λ(∑ Q ( x ) −1). 8.7 Differential entropy bound on discrete entropy . Let X be a discrete random variable on the set χ = { a 1 , a 2 , …} with Pr( X = a i ) = p i . Show that (8.94) Moreover, for every permutation σ, (8.95) [Hint: Construct a random variable X ′ such that Pr( X ′ = i) = p i . Let U be a uniform (0,1] random variable and let Y = X ′ + U , where X ′ and U are independent. Use the maximum entropy bound on Y to obtain the bounds in the problem. This bound is due to Massey (unpublished) and Willems (unpublished).] 8.8 Channel with uniformly distributed noise . Consider a additive channel whose input alphabet χ = {0, ±1, ±2} and whose output Y = X + Z , where Z is distributed uniformly over the interval [−1, 1]. Thus, the input of the channel is a discrete random variable, whereas the output is continuous. Calculate the capacity C = max p ( x ) I (X ; Y ) of this channel. 8.9 Gaussian mutual information . Suppose that ( X , Y , Z ) are jointly Gaussian and that X → Y → Z forms a Markov chain. Let X and Y have correlation coefficient ρ 1 and let Y and Z have correlation coefficient ρ 2 . Find I ( X ; Z ). 8.10 Shape of the typical set . Let X i be i.i.d. ~ f ( x ), where Let h = − ∫ f ln f . Describe the shape (or form) or the typical set . 8.11 Nonergodic Gaussian process . Consider a constant signal V in the presence of iid observational noise { Z i ). Thus, X i = V + Z i , where V ~ N (0, S ) and Z i are iid ~ N (0, N ). Assume that V and { Z i } are independent. (a) Is { X i } stationary? (b) Find . Is the limit random? (c) What is the entropy rate h of { X i }? (d) Find the least-mean-squared error predictor n +1 ( X n ), and find = lim n →∞ , E ( n − X n ) 2 . (e) Does { X i } have an AEP? That is, does − log f ( X n ) → h ? HISTORICAL NOTES Differential entropy and discrete entropy were introduced in Shannon’s original paper [472]. The general rigorous definition of relative entropy and mutual information for arbitrary random variables was developed by Kolmogorov [319] and Pinsker [425], who defined mutual information as , where the supremum is over all finite partitions and .

Chapter 9: Gaussian Channel CHAPTER 9 GAUSSIAN CHANNEL The most important continuous alphabet channel is the Gaussian channel depicted in Figure 9.1 . This is a time-discrete channel with output Y i at time i , where Y i is the sum of the input X i and the noise Z i . The noise Z i is drawn i.i.d. from a Gaussian distribution with variance N . Thus, FIGURE 9.1. Gaussian channel. (9.1) The noise Z i is assumed to be independent of the signal X i . This channel is a model for some common communication channels, such as wired and wireless telephone channels and satellite links. Without further conditions, the capacity of this channel may be infinite. If the noise variance is zero, the receiver receives the transmitted symbol perfectly. Since X can take on any real value, the channel can transmit an arbitrary real number with no error. If the noise variance is nonzero and there is no constraint on the input, we can choose an infinite subset of inputs arbitrarily far apart, so that they are distinguishable at the output with arbitrarily small probability of error. Such a scheme has an infinite capacity as well. Thus if the noise variance is zero or the input is unconstrained, the capacity of the channel is infinite. The most common limitation on the input is an energy or power constraint. We assume an average power constraint. For any codeword ( x 1 , x 2 ,…, x n ) transmitted over the channel, we require that (9.2) This communication channel models many practical channels, including radio and satellite links. The additive noise in such channels may be due to a variety of causes. However, by the central limit theorem, the cumulative effect of a large number of small random effects will be approximately normal, so the Gaussian assumption is valid in a large number of situations. We first analyze a simple suboptimal way to use this channel. Assume that we want to send 1 bit over the channel in one use of the channel. Given the power constraint, the best that we can do is to send one of two levels, + or − The receiver looks at the corresponding Y received and tries to decide which of the two levels was sent. Assuming that both levels are equally likely (this would be the case if we wish to send exactly 1 bit of information), the optimum decoding rule is to decide that + was sent if Y > 0 and decide − was sent if Y < 0. The probability of error with such a decoding scheme is (9.3) (9.4) (9.5) (9.6) where Φ( x ) is the cumulative normal function (9.7) Using such a scheme, we have converted the Gaussian channel into a discrete binary symmetric channel with crossover probability P e . Similarly, by using a four-level input signal, we can convert the Gaussian channel into a discrete four-input channel. In some practical modulation schemes, similar ideas are used to convert the continuous channel into a discrete channel. The main advantage of a discrete channel is ease of processing of the output signal for error correction, but some information is lost in the quantization. 9.1 GAUSSIAN CHANNEL: DEFINITIONS We now define the (information) capacity of the channel as the maximum of the mutual information between the input and output over all distributions on the input that satisfy the power constraint. Definition The information capacity of the Gaussian channel with power constraint P is (9.8) We can calculate the information capacity as follows: Expanding I ( X ; Y ), we have (9.9) (9.10) (9.11) (9.12) since Z is independent of X . Now, h ( Z ) = log 2π eN . Also, (9.13) since X and Z are independent and EZ = 0. Given EY 2 = P + N , the entropy of Y is bounded by log 2π e ( P + N ) by Theorem 8.6.5 (the normal maximizes the entropy for a given variance). Applying this result to bound the mutual information, we obtain (9.14) (9.15) (9.16) Hence, the information capacity of the Gaussian channel is (9.17) and the maximum is attained when X ~ (0, P ). We will now show that this capacity is also the supremum of the rates achievable for the channel. The arguments are similar to the arguments for a discrete channel. We will begin with the corresponding definitions. Definition An ( M , n ) code for the Gaussian channel with power constraint P consists of the following: 1. An index set {1, 2,…, M }. 2. An encoding function x : {1, 2,…, M } → χ n , yielding codewords x n (1), x n (2),…, x n ( M ), satisfying the power constraint P ; that is, for every codeword (9.18) 3. A decoding function (9.19) The rate and probability of error of the code are defined as in Chapter 7 for the discrete case. The arithmetic average of the probability of error is defined by (9.20) Definition A rate R is said to be achievable for a Gaussian channel with a power constraint P if there exists a sequence of (2 nR , n ) codes with codewords satisfying the power constraint such that the maximal probability of error tends to zero. The capacity of the channel is the supremum of the achievable rates. Theorem 9.1.1 The capacity of a Gaussian channel with power constraint P and noise variance N is (9.21) Remark We first present a plausibility argument as to why we may be able to construct (2 nC , n ) codes with a low probability of error. Consider any codeword of length n . The received vector is normally distributed with mean equal to the true codeword and variance equal to the noise variance. With high probability, the received vector is contained in a sphere of radius around the true codeword. If we assign everything within this sphere to the given codeword, when this codeword is sent there will be an error only if the received vector falls outside the sphere, which has low probability. Similarly, we can choose other codewords and their corresponding decoding spheres. How many such codewords can we choose? The volume of an n -dimensional sphere is of the form C n r n , where r is the radius of the sphere. In this case, each decoding sphere has radius . These spheres are scattered throughout the space of received vectors. The received vectors have energy no greater than n ( P + N ), so they lie in a sphere of radius . The maximum number of nonintersecting decoding spheres in this volume is no more than (9.22) and the rate of the code is log(1 + ). This idea is illustrated in Figure 9.2 . FIGURE 9.2. Sphere packing for the Gaussian channel. This sphere-packing argument indicates that we cannot hope to send at rates greater than C with low probability of error. However, we can actually do almost as well as this, as is proved next. Proof: ( Achievability ). We will use the same ideas as in the proof of the channel coding theorem in the case of discrete channels: namely, random codes and joint typicality decoding. However, we must make some modifications to take into account the power constraint and the fact that the variables are continuous and not discrete. 1. Generation of the codebook . We wish to generate a codebook in which all the codewords satisfy the power constraint. To ensure this, we generate the codewords with each element i.i.d. according to a normal distribution with variance P − . Since for large n , → P − , the probability that a codeword does not satisfy the power constraint will be small. Let X i ( w ), i = 1, 2,…, n , w = 1, 2,…, 2 nR be i.i.d. ~ (0, P − ), forming codewords X n (1), X n (2),…, X n (2 nR ) n . 2. Encoding . After the generation of the codebook, the codebook is revealed to both the sender and the receiver. To send the message index w , the transmitter sends the w th codeword X n ( w ) in the codebook. 3. Decoding . The receiver looks down the list of codewords { X n ( w )} and searches for one that is jointly typical with the received vector. If there is one and only one such codeword X n ( w ), the receiver declares = w to be the transmitted codeword. Otherwise, the receiver declares an error. The receiver also declares an error if the chosen codeword does not satisfy the power constraint. 4. Probability of error . Without loss of generality, assume that codeword 1 was sent. Thus, Y n = X n (1) + Z n . Define the following events: (9.23) and (9.24) Then an error occurs if E 0 occurs (the power constraint is violated) or E c i occurs (the transmitted codeword and the received sequence are not jointly typical) or occurs (some wrong codeword is jointly typical with the received sequence). Let e denote the event and let P denote the conditional probability given that W = 1. Hence, (9.25) (9.26) by the union of events bound for probabilities. By the law of large numbers, P ( E 0 ) → 0 as n → ∞. Now, by the joint AEP (which can be proved using the same argument as that used in the discrete case), , and hence (9.27) Since by the code generation process, X n (1) and X n ( i ) are independent, so are Y n and X n ( i ). Hence, the probability that X n ( i ) and Y n will be jointly typical is ≤ 2 − n (1( X ; Y )−3 ) by the joint AEP. Now let W be uniformly distributed over {1, 2,…, 2 nR } and consequently, (9.28) Then (9.29) (9.30) (9.31) (9.32) (9.33) (9.34) for n sufficiently large and R < I ( X ; Y ) − 3 . This proves the existence of a good (2 nR , n ) code. Now choosing a good codebook and deleting the worst half of the codewords, we obtain a code with low maximal probability of error. In particular, the power constraint is satisfied by each of the remaining codewords (since the codewords that do not satisfy the power constraint have probability of error 1 and must belong to the worst half of the codewords). Hence we have constructed a code that achieves a rate arbitrarily close to capacity. The forward part of the theorem is proved. In the next section we show that the achievable rate cannot exceed the capacity. 9.2 CONVERSE TO THE CODING THEOREM FOR GAUSSIAN CHANNELS In this section we complete the proof that the capacity of a Gaussian channel is C = log(1 + ) by proving that rates R > C are not achievable. The proof parallels the proof for the discrete channel. The main new ingredient is ′the power constraint. Proof: ( Converse to Theorem 9.1.1 ). We must show that if for a sequence of (2 nR , n ) codes for a Gaussian channel with power constraint P , then (9.35) Consider any (2 nR , n ) code that satisfies the power constraint, that is, (9.36) for w = 1, 2,…, 2 nR . Proceeding as in the converse for the discrete case, let W be distributed uniformly over {1, 2,…, 2 nR }. The uniform distribution over the index set W {1, 2,…, 2 nR } induces a distribution on the input codewords, which in turn induces a distribution over the input alphabet. This specifies a joint distribution on W → X n ( W ) → Y n → . To relate probability of error and mutual information, we can apply Fano’s inequality to obtain (9.37) where n → 0 as . Hence, (9.38) (9.39) (9.40) (9.41) (9.42) (9.43) (9.44) (9.45) Here X i = x i ( W ), where W is drawn according to the uniform distribution on {1, 2,…, 2 nR }. Now let P i be the average power of the i th column of the codebook, that is, (9.46) Then, since Y i = X i + Z i and since X i and Z i are independent, the average power’ EY i 2 of Y i is P i + N . Hence, since entropy is maximized by the normal distribution, (9.47) Continuing with the inequalities of the converse, we obtain (9.48) (9.49) (9.50) Since each of the codewords satisfies the power constraint, so does their average, and hence (9.51) Since f ( x ) = log(1 + x ) is a concave function of x , we can apply Jensen’s inequality to obtain (9.52) (9.53) Thus , and we have the required converse. Note that the power constraint enters the standard proof in (9.46) . 9.3 BANDLIMITED CHANNELS A common model for communication over a radio network or a telephone line is a bandlimited channel with white noise. This is a continuous-time channel. The output of such a channel can be described as the convolution (9.54) where X ( t ) is the signal waveform, Z ( t ) is the waveform of the white Gaussian noise, and h ( t ) is the impulse response of an ideal bandpass filter, which cuts out all frequencies greater than W. In this section we give simplified arguments to calculate the capacity of such a channel. We begin with a representation theorem due to Nyquist [396] and Shannon [480], which shows that sampling a bandlimited signal at a sampling rate is sufficient to reconstruct the signal from the samples. Intuitively, this is due to the fact that if a signal is bandlimited to W , it cannot change by a substantial amount in a time less than half a cycle of the maximum frequency in the signal, that is, the signal cannot change very much in time intervals less than seconds. Theorem 9.3.1 Suppose that a function f ( t ) is bandlimited to W, namely, the spectrum of the function is 0 for all frequencies greater than W. Then the function is completely determined by samples of the function spaced seconds apart . Proof: Let F ( ω ) be the Fourier transform of f ( t ). Then (9.55) (9.56) since F (ω) is zero outside the band −2π W ≤ ω ≤ 2π W . If we consider samples spaced seconds apart, the value of the signal at the sample points can be written (9.57) The right-hand side of this equation is also the definition of the coefficients of the Fourier series expansion of the periodic extension of the function F , taking the interval −2π W to 2π W as the fundamental period. Thus, the sample values f determine the Fourier coefficients and, by extension, they determine the value of F (ω) in the interval (−2π W , 2π W ). Since a function is uniquely specified by its Fourier transform, and since F is zero outside the band W, we can determine the function uniquely from the samples. Consider the function (9.58) This function is 1 at t = 0 and is 0 for t = n /2 W , n ≠ 0. The spectrum of this function is constant in the band (− W , W ) and is zero outside this band. Now define (9.59) From the properties of the sinc function, it follows that g(t ) is bandlimited to W and is equal to f ( n /2 W ) at t = n /2 W . Since there is only one function satisfying these constraints, we must have g ( t ) = f ( t ). This provides an explicit representation of f ( t ) in terms of its samples. A general function has an infinite number of degrees of freedom–the value of the function at every point can be chosen independently. The Nyquist–Shannon sampling theorem shows that a bandlimited function has only 2 W degrees of freedom per second. The values of the function at the sample points can be chosen independently, and this specifies the entire function. If a function is bandlimited, it cannot be limited in time. But we can consider functions that have most of their energy in bandwidth W and have most of their energy in a finite time interval, say (0, T ). We can describe these functions using a basis of prolate spheroidal functions . We do not go into the details of this theory here; it suffices to say that there are about 2 T W orthonormal basis functions for the set of almost time-limited, almost bandlimited functions, and we can describe any function within the set by its coordinates in this basis. The details can be found in a series of papers by Landau, Pollak, and Slepian [340, 341, 500]. Moreover, the projection of white noise on these basis vectors forms an i.i.d. Gaussian process. The above arguments enable us to view the bandlimited, time-limited functions as vectors in a vector space of 2 T W dimensions. Now we return to the problem of communication over a bandlimited channel. Assuming that the channel has bandwidth W , we can represent both the input and the output by samples taken 1/2 W seconds apart. Each of the input samples is corrupted by noise to produce the corresponding output sample. Since the noise is white and Gaussian, it can be shown that each noise sample is an independent, identically distributed Gaussian random variable. If the noise has power spectral density N 0 /2 watts/hertz and bandwidth W hertz, the noise has power and each of the 2 W T noise samples in time T has variance N 0 W T /2 W T = N 0 /2. Looking at the input as a vector in the 2 T W -dimensional space, we see that the received signal is spherically normally distributed about this point with covariance . Now we can use the theory derived earlier for discrete-time Gaussian channels, where it was shown that the capacity of such a channel is (9.60) Let the channel be used over the time interval [0, T ]. In this case, the energy per sample is PT /2 WT = P /2 W , the noise variance per sample is , and hence the capacity per sample is (9.61) Since there are 2 W samples each second, the capacity of the channel can be rewritten as (9.62) This equation is one of the most famous formulas of information theory. It gives the capacity of a bandlimited Gaussian channel with noise spectral density N 0 /2 watts/Hz and power P watts. A more precise version of the capacity argument [576] involves consideration of signals, with a small fraction of their energy outside the bandwidth W of the channel and a small fraction of their energy outside the time interval (0, T ). The capacity above is then obtained as a limit as the fraction of energy outside the band goes to zero. If we let W → ∞ in (9.62) , we obtain (9.63) as the capacity of a channel with an infinite bandwidth, power P , and noise spectral density N 0 /2. Thus, for infinite bandwidth channels, the capacity grows linearly with the power. Example 9.3.1 (Telephone line) To allow multiplexing of many channels, telephone signals are bandlimited to 3300 Hz. Using a bandwidth of 3300 Hz and a SNR (signal-to-noise ratio) of 33 dB (i.e., P / N 0 W = 2000) in (9.62) , we find the capacity of the telephone channel to be about 36,000 bits per second. Practical modems achieve transmission rates up to 33,600 bits per second in both directions over a telephone channel. In real telephone channels, there are other factors, such as crosstalk, interference, echoes, and nonflat channels which must be compensated for to achieve this capacity. The V.90 modems that achieve 56 kb/s over the telephone channel achieve this rate in only one direction, taking advantage of a purely digital channel from the server to final telephone switch in the network. In this case, the only impairments are due to the digital-to-analog conversion at this switch and the noise in the copper link from the switch to the home: these impairments reduce the maximum bit rate from the 64 kb/s for the digital signal in the network to the 56 kb/s in the best of telephone lines. The actual bandwidth available on the copper wire that links a home to a telephone switch is on the order of a few megahertz; it depends on the length of the wire. The frequency response is far from flat over this band. If the entire bandwidth is used, it is possible to send a few megabits per second through this channel; schemes such at DSL (Digital Subscriber Line) achieve this using special equipment at both ends of the telephone line (unlike modems, which do not require modification at the telephone switch). 9.4 PARALLEL GAUSSIAN CHANNELS In this section we consider k independent Gaussian channels in parallel with a common power constraint. The objective is to distribute the total power among the channels so as to maximize the capacity. This channel models a nonwhite additive Gaussian noise channel where each parallel component represents a different frequency. Assume that we have a set of Gaussian channels in parallel as illustrated in Figure 9.3 . The output of each channel is the sum of the input and Gaussian noise. For channel j , FIGURE 9.3. Parallel Gaussian channels. (9.64) with (9.65) and the noise is assumed to be independent from channel to channel. We assume that there is a common power constraint on the total power used, that is, (9.66) We wish to distribute the power among the various channels so as to maximize the total capacity. The information capacity of the channel C is (9.67) We calculate the distribution that achieves the information capacity for this channel. The fact that the information capacity is the supremum of achievable rates can be proved by methods identical to those in the proof of the capacity theorem for single Gaussian channels and will be omitted. (9.68) (9.69) (9.70) (9.71) where P i = , and ∑ P i = P . Equality is achieved by (9.72) So the problem is reduced to finding the power allotment that maximizes the capacity subject to the constraint that ∑ P i = P . This is a standard optimization-problem and can be solved using Lagrange multipliers. Writing the functional as (9.73) and differentiating with respect to P i , we have (9.74) or (9.75) However, since the P i ’s must be nonnegative, it may not always be possible to find a solution of this form. In this case, we use the Kuhn–Tucker conditions to verify that the solution (9.76) is the assignment that maximizes capacity, where v is chosen so that (9.77) Here ( x ) + denotes the positive part of x : (9.78) This solution is illustrated graphically in Figure 9.4 . The vertical levels indicate the noise levels in the various channels. As the signal power is increased from zero, we allot the power to the channels with the lowest noise. When the available power is increased still further, some of the power is put into noisier channels. The process by which the power is distributed among the various bins is identical to the way in which water distributes itself in a vessel, hence this process is sometimes referred to as water-filling . FIGURE 9.4. Water-filling for parallel channels. 9.5 CHANNELS WITH COLORED GAUSSIAN NOISE In Section 9.4, we considered the case of a set of parallel independent Gaussian channels in which the noise samples from different channels were independent. Now we will consider the case when the noise is dependent. This represents not only the case of parallel channels, but also the case when the channel has Gaussian noise with memory. For channels with memory, we can consider a block of n consecutive uses of the channel as n channels in parallel with dependent noise. As in Section 9.4, we will calculate only the information capacity for this channel. Let K Z be the covariance matrix of the noise, and let K X be the input covariance matrix. The power constraint on the input can then be written as (9.79) or equivalently, (9.80) Unlike Section 9.4, the power constraint here depends on n ; the capacity will have to be calculated for each n . Just as in the case of independent channels, we can write (9.81) Here h ( Z 1 , Z 2 ,…, Z n ) is determined only by the distribution of the noise and is not dependent on the choice of input distribution. So finding the capacity amounts to Maximizing ( Y 1 , Y 2 ,…, Y n ). The entropy of the output is maximized when Y is normal, which is achieved when the input is normal. Since the input and the noise are independent, the covariance of the output Y is K Y = K X + K Z and the entropy is (9.82) Now the problem is reduced to choosing K X so as to maximize | K X + K Z |, subject to a trace constraint on K X . To do this, we decompose K Z into its diagonal form, (9.83) Then (9.84) (9.85) (9.86) (9.87) where A = Q t K X Q . Since for any matrices B and C , (9.88) we have (9.89) (9.90) (9.91) Now the problem is reduced to maximizing | A + Λ| subject to a trace constraint tr( A ) ≤ n P . Now we apply Hadamard’s inequality, mentioned in Chapter 8. Hadamard’s inequality states that the determinant of any positive definite matrix K is less than the product of its diagonal elements, that is, (9.92) with equality iff the matrix is diagonal. Thus, (9.93) with equality iff A is diagonal. Since A is subject to a trace constraint, (9.94) and A ii ≥ 0, the maximum value of is attained when (9.95) However, given the constraints, it may not always be possible to satisfy this equation with positive A ii . In such cases, we can show by the standard Kuhn–Tucker conditions that the optimum solution corresponds to setting (9.96) where the water level v is chosen so that ∑ A ii = n P . This value of A maximizes the entropy of Y and hence the mutual information. We can use Figure 9.4 to see the connection between the methods described above and water-filling. Consider a channel in which the additive Gaussian noise is a stochastic process with finite-dimensional covariance matrix , If the process is stationary, the covariance matrix is Toeplitz and the density of eigenvalues on the real line tends to the power spectrum of the stochastic process [262]. In this case, the above water-filling argument translates to water-filling in the spectral domain. Hence, for channels in which the noise forms a stationary stochastic process, the input signal should be chosen to be a Gaussian process with a spectrum that is large at frequencies where the noise spectrum is small. This is illustrated in Figure 9.5 . The capacity of an additive Gaussian noise channel with noise power spectrum N ( f ) can be shown to be [233] FIGURE 9.5. Water-filling in the spectral domain. (9.97) where v is chosen so that ∫ ( v − N ( f )) + df = P . 9.6 GAUSSIAN CHANNELS WITH FEEDBACK In Chapter 7 we proved that feedback does not increase the capacity for discrete memoryless channels, although it can help greatly in reducing the complexity of encoding or decoding. The same is true of an additive noise channel with white noise. As in the discrete case, feedback does not increase capacity for memoryless Gaussian channels. However, for channels with memory, where the noise is correlated from time instant to time instant, feedback does increase capacity. The capacity without feedback can be calculated using water-filling, but we do not have a simple explicit characterization of the capacity with feedback. In this section we describe an expression for the capacity in terms of the covariance matrix of the noise Z . We prove a converse for this expression for capacity. We then derive a simple bound on the increase in capacity due to feedback. The Gaussian channel with feedback is illustrated in Figure 9.6 . The output of the channel Y i is FIGURE 9.6. Gaussian channel with feedback. (9.98) The feedback allows the input of the channel to depend on the past values of the output. A (2 nR , n ) code for the Gaussian channel with feedback consists of a sequence of mappings x i (W, Y i−1 ) , where W is the input message and Y i−1 is the sequence of past values of the output. Thus, x ( W , ·) is a code function rather than a codeword. In addition, we require that the code satisfy a power constraint, (9.99) where the expectation is over all possible noise sequences. We characterize the capacity of the Gaussian channel is terms of the covariance matrices of the input X and the noise Z . Because of the feedback, X n and Z n are not independent; X i depends causally on the past values of Z . In the next section we prove a converse for the Gaussian channel with feedback and show that we achieve capacity if we take X to be Gaussian. We now state an informal characterization of the capacity of the channel with and without feedback. 1. With feedback . The capacity C n,FB in bits per transmission of the time-varying Gaussian channel with feedback is (9.100) where the maximization is taken over all X n of the form (9.101) and V n is independent of Z n . To verify that the maximization over (9.101) involves no loss of generality, note that the distribution on X n + Z n achieving the maximum entropy is Gaussian. Since Z n is also Gaussian, it can be verified that a jointly Gaussian distribution on ( X n , Z n , X n + Z n ) achieves the maximization in (9.100) . But since Z n = Y n − X n , the most general jointly normal causal dependence of X n on Y n is of the form (9.101) , where V n plays the role of the innovations process. Recasting (9.100) and (9.101) using X = BZ + V and Y = X + Z , we can write (9.102) where the maximum is taken over all nonnegative definite K v and strictly lower triangular B such that (9.103) Note that B is 0 if feedback is not allowed. 2. Without feedback . The capacity C n of the time-varying Gaussian channel without feedback is given by (9.104) This reduces to water-filling on the eigenvalues of . Thus, (9.105) where (y) + = max{y, 0} and where λ is chosen so that (9.106) We now prove an upper bound for the capacity of the Gaussian channel with feedback. This bound is actually achievable [136], and is therefore the capacity, but we do not prove this here. Theorem 9.6.1 For a Gaussian channel with feedback, the rate R n for any sequence of (2 nR n , n ) codes with satisfies (9.107) with → 0 as n → ∞, where C n, FB is defined in (9.100) . Proof: Let W be uniform over 2 nR , and therefore the probability of error P e (n) is bounded by Fano’s inequality, (9.108) where → 0 as P e (n) → 0. We can then bound the rate as follows: (9.109) (9.110) (9.111) (9.112) (9.113) (9.114) (9.115) (9.116) (9.117) where (a) follows from the fact that X i is a function of W and the past Y i ’s, and Z i−1 is Y i−1 − X i−1 , (b) follows from Y i = X i + Z i and the fact that h(X + Z|X) = h(Z|X) , and (c) follows from the fact Z i and ( W, Y i−1 , X i ) are conditionally independent given Z i−1 . Continuing the chain of inequalities after dividing by n , we have (9.118) (9.119) (9.120) by the entropy maximizing property of the normal. We have proved an upper bound on the capacity of the Gaussian channel with feedback in terms of the covariance matrix . We now derive bounds on the capacity with feedback in terms of and , which will then be used to derive bounds in terms of the capacity without feedback. For simplicity of notation, we will drop the superscript n in the symbols for covariance matrices. We first prove a series of lemmas about matrices and determinants. Lemma 9.6.1 Let X and Z be n-dimensional random vectors. Then (9.121) Proof (9.122) (9.123) (9.124) Similarly, (9.125) Adding these two equations completes the proof. Lemma 9.6.2 For two n × n nonnegative definite matrices A and B, if A − B is nonnegative definite, then |A| ≤ |B| . Proof : Let C = A − B . Since B and C are nonnegative definite, we can consider them as covariance matrices. Consider two independent normal random vectors X 1 ~ (0, B ) and X 2 ~ (0, C ). Let Y = X 1 + X 2 . Then (9.126) (9.127) (9.128) where the inequality follows from the fact that conditioning reduces differential entropy, and the final equality from the fact that X 1 and X 2 are independent. Substituting the expressions for the differential entropies of a normal random variable, we obtain (9.129) which is equivalent to the desired lemma. Lemma 9.6.3 For two n-dimensional random vectors X and Z , (9.130) Proof: From Lemma 9.6.1, (9.131) where A 0 means that A is nonnegative definite. Hence, applying Lemma 9.6.2, we have (9.132) which is the desired result. Lemma 9.6.4 For A, B nonnegative definite matrices and 0 ≥ λ ≥ 1 , (9.133) Proof: Let X ~ n (0, A ) and Y ~ n (0, B ). Let Z be the mixture random vector (9.134) where (9.135) Let X , Y , and θ be independent. Then (9.136) We observe that (9.137) (9.138) (9.139) (9.140) which proves the result. The first inequality follows from the entropy maximizing property of the Gaussian under the covariance constraint. Definition We say that a random vector X n is causally related to Z n if (9.141) Note that the feedback codes necessarily yield causally related ( X n , Z n ). Lemma 9.6.5 If X n and Z n are causally related, then (9.142) and (9.143) where K X−Z and K z are the covariance matrices of X n − Z n and Z n , respectively . Proof: We have (9.144) (9.145) (9.146) (9.147) (9.148) Here (a) follows from the chain rule, (b) follows from conditioning h(A|B) ≤ h(A|B, C) , (c) follows from the conditional determinism of X i and the invariance of differential entropy under translation, (d) follows from the causal relationship of X n and Z n , and (e) follows from the chain rule. Finally, suppose that X n and Z n are causally related and the associated covariance matrices for Z n and X n − Z n are K z and K X−Z . There obviously exists a multivariate normal (causally related) pair of random vectors , with the same covariance structure. Thus, from (9.148) , we have (9.149) (9.150) (9.151) thus proving (9.143) . We are now in a position to prove that feedback increases the capacity of a nonwhite Gaussian additive noise channel by at most half a bit. Theorem 9.6.2 (9.152) Proof: Combining all the lemmas, we obtain (9.153) (9.154) (9.155) (9.156) where the inequalities follow from Theorem 9.6.1, Lemma 9.6.3, and the definition of capacity without feedback, respectively. We now prove Pinsker’s statement that feedback can at most double the capacity of colored noise channels. Theorem 9.6.3 C n,FB ≥ 2C n . Proof: It is enough to show that (9.157) for it will then follow that by maximizing the right side and then the left side that (9.158) We have (9.159) (9.160) (9.161) (9.162) and the result is proved. Here (a) follows from Lemma 9.6.1, (b) is the inequality in Lemma 9.6.4, and (c) is Lemma 9.6.5 in which causality is used. Thus, we have shown that Gaussian channel capacity is not increased by more than half a bit or by more than a factor of 2 when we have feedback; feedback helps, but not by much. SUMMARY Maximum entropy. max EX 2 =α h(X) = log 2π eα. Gaussian channel. Y i = X i + Z i ; Z i ~ ; power constraint and (9.163) Bandlimited additive white Gaussian noise channel. Bandwidth W ; two-sided power spectral density N 0 /2; signal power P ; and (9.164) Water-filling (k parallel Gaussian channels). Y j = X j + Z j , j = 1, 2, …, k ; and (9.165) where ν is chosen so that ∑( ν − N i ) + = nP . Additive nonwhite Gaussian noise channel. and (9.166) where λ 1 , λ 2 ,…, λ n are the eigenvalues of K Z and v is chosen so that ∑ i ( v − λ i ) + = P . Capacity without feedback (9.167) Capacity with feedback (9.168) Feedback bounds (9.169) (9.170) PROBLEMS 9.1 Channel with two independent looks at Y . Let Y 1 and Y 2 be conditionally independent and conditionally identically distributed given X . (a) Show that I ( X; Y 1 , Y 2 ) = 2 I ( X; Y 1 ) − I (Y 1 ; Y 2 ). (b) Conclude that the capacity of the channel is less than twice the capacity of the channel 9.2 Two-look Gaussian channel Consider the ordinary Gaussian channel with two correlated looks at X , that is, Y = ( Y 1 , Y 2 ), where (9.171) (9.172) with a power constraint P on X , and ( Z 1 , Z 2 ) ~ 2 (0, K ), where (9.173) Find the capacity C for (a) ρ = 1 (b) ρ = 0 (c) ρ = −1 9.3 Output power constraint . Consider an additive white Gaussian noise channel with an expected output power constraint P . Thus, Y = X + Z , Z ~ N (0, σ 2 ), Z is independent of X , and EY 2 ≤ P . Find the channel capacity. 9.4 Exponential noise channels . Y i = X i Z i , where Z i is i.i.d. exponentially distributed noise with mean μ. Assume that we have a mean constraint on the signal (i.e., EX i ≤ λ). Show that the capacity of such a channel is C = log(1 + ). 9.5 Fading channel . Consider an additive noise fading channel where Z is additive noise, V is a random variable representing fading, and Z and V are independent of each other and of X . Argue that knowledge of the fading factor V improves capacity by showing that 9.6 Parallel channels and water-filling . Consider a pair of parallel Gaussian channels: (9.174) where (9.175) and there is a power constraint . Assume that . At what power does the channel stop behaving like a single channel with noise variance σ2/2, and begin behaving like a pair of channels? 9.7 Multipath Gaussian channel . Consider a Gaussian noise channel with power constraint P , where the signal takes two different paths and the received noisy signals are added together at the antenna. (a) Find the capacity of this channel if Z 1 and Z 2 are jointly normal with covariance matrix (b) What is the capacity for ρ = 0, ρ = 1, ρ = −1? 9.8 Parallel Gaussian channels . Consider the following parallel Gaussian channel: where Z 1 ~ (0, N 1 ) and Z 2 ~ (0, N 2 ) are independent Gaussian random variables and Y i = X i + Z i . We wish to allocate power to the two parallel channels. Let β 1 and β 2 be fixed. Consider a total cost constraint β 1 p 1 + β 2 p 2 ≤ β, where P i is the power allocated to the i th channel and β i is the cost per unit power in that channel. Thus, p 1 ≥ 0 and p 2 ≥ 0 can be chosen subject to the cost constraint β. (a) For what value of β does the channel stop acting like a single channel and start acting like a pair of channels? (b) Evaluate the capacity and find p 1 and p 2 that achieve capacity for β 1 , = 1, β 2 = 2, N 1 = 3, N 2 = 2, and β = 10. 9.9 Vector Gaussian channel . Consider the vector Gaussian noise channel where X = ( X 1 , X 2 , X 3 ), Z = ( Z 1 , Z 2 , Z 3 ), Y = ( Y 1 , Y 2 , Y 3 ), E || X || 2 ≤ P , and Find the capacity. The answer may be surprising. 9.10 Capacity of photographic film . Here is a problem with a nice answer that takes a little time. We’re interested in the capacity of photographic film. The film consists of silver iodide crystals, Poisson distributed, with a density of λ particles per square inch. The film is illuminated without knowledge of the position of the silver iodide particles. It is then developed and the receiver sees only the silver iodide particles that have been illuminated. It is assumed that light incident on a cell exposes the grain if it is there and otherwise results in a blank response. Silver iodide particles that are not illuminated and vacant portions of the film remain blank. The question is: What is the capacity of this film? We make the following assumptions. We grid the film very finely into cells of area dA . It is assumed that there is at most one silver iodide particle per cell and that no silver iodide particle is intersected by the cell boundaries. Thus, the film can be considered to be a large number of parallel binary asymmetric channels with crossover probability 1 − λ dA . By calculating the capacity of this binary asymmetric channel to first order in dA (making the necessary approximations), one can calculate the capacity of the film in bits per square inch. It is, of course, proportional to λ. The question is: What is the multiplicative constant? The answer would be λ bits per unit area if both illuminator and receiver knew the positions of the crystals. 9.11 Gaussian mutual information . Suppose that (X, Y, Z) are jointly Gaussian and that X → Y → Z forms a Markov chain. Let X and Y have correlation coefficient ρ 1 and let Y and Z have correlation coefficient ρ 2 . Find I ( X ; Z ). 9.12 Time-varying channel . A train pulls out of the station at constant velocity. The received signal energy thus falls off with time as 1/ i 2 . The total received signal at time i is where Z 1 , Z 2 , … are i.i.d. ~ N (0, N ). The transmitter constraint for block length n is Using Fano’s inequality, show that the capacity C is equal to zero for this channel. 9.13 Feedback capacity . Let ( Z 1 , Z 2 ) ~ N (0, K ), K = . Find the maximum of with and without feedback given a trace (power) constraint tr( K X ) ≤ 2 P . 9.14 Additive noise channel . Consider the channel Y = X + Z , where X is the transmitted signal with power constraint P, Z is independent additive noise, and Y is the received signal. Let where Z * ~ N (0, N ). Thus, Z has a mixture distribution that is the mixture of a Gaussian distribution and a degenerate distribution with mass 1 at 0. (a) What is the capacity of this channel? This should be a pleasant surprise. (b) How would you signal to achieve capacity? 9.15 Discrete input, continuous output channel . Let Pr{X = 1) = p , Pr{X = 0} = 1 − p , and let Y = X + Z , where Z is uniform over the interval [0, a ], a > 1, and Z is independent of X . (a) Calculate (b) Now calculate I (X; Y) the other way by (c) Calculate the capacity of this channel by maximizing over p . 9.16 Gaussian mutual information . Suppose that (X, Y, Z, W) are jointly Gaussian and that X → Y → Z → W forms a Markov chain. Let X and Y have correlation coefficient ρ 1 and let Y and Z have correlation coefficient ρ2. Find I (X; Z) . 9.17 Impulse power . Consider the additive white Gaussian channel where Z i ~ N (0, N ), and the input signal has average power constraint P . (a) Suppose that we use all our power at time 1 (i.e., EX 2 1 = nP and EX 2 1 = 0 for i = 2, 3,…, n ). Find where the maximization is over all distributions f(x n ) subject to the constraint EX 2 1 = nP and EX 2 1 = 0 for i = 2, 3,…, n . (b) Find and compare to part (a). 9.18 Gaussian channel with time-varying mean . Find the capacity of the following Gaussian channel: Let Z 1 , Z 2 , … be independent and let there be a power constraint P on x n (W) . Find the capacity when: (a) μ i = 0, for all i . (b) μ i = e i , i = 1, 2, …. Assume that μ i is known to the transmitter and receiver. (c) μ i unknown, but μ i i.i.d ~ N (0, N 1 ) for all i . 9.19 Parametric form for channel capacity . Consider m parallel Gaussian channels, Y i = X i + Z i , where Z i ~ N (0, λ i ) and the noises X i are independent random variables. Thus, , where λ is chosen to satisfy Show that this can be rewritten in the form Here P (λ) is piecewise linear and C (λ) is piecewise logarithmic in λ. 9.20 Robust decoding . Consider an additive noise channel whose output Y is given by where the channel input X is average power limited, and the noise process is i.i.d. with marginal distribution pz (z) (not necessarily Gaussian) of power N , (a) Show that the channel capacity, C = max EX 2 ≤ P I (X; Y) , is lower bounded by C G , where (i.e., the capacity C G corresponding to white Gaussian noise). (b) Decoding the received vector to the codeword that is closest to it in Euclidean distance is in general suboptimal if the noise is non-Gaussian. Show, however, that the rate C G is achievable even if one insists on performing nearest-neighbor decoding (minimum Euclidean distance decoding) rather than the optimal maximum-likelihood or joint typicality decoding (with respect to the true noise distribution). (c) Extend the result to the case where the noise is not i.i.d. but is stationary and ergodic with power N . ( Hint for b and c: Consider a size 2 nR random codebook whose codewords are drawn independently of each other according to a uniform distribution over the n -dimensional sphere of radius .) (a) Using a symmetry argument, show that conditioned on the noise vector, the ensemble average probability of error depends on the noise vector only via its Euclidean norm || z || (b) Use a geometric argument to show that this dependence is monotonic. (c) Given a rate R < C G , choose some N ′ > N such that Compare the case where the noise is i.i.d. (0, N ′) to the case at hand. (d) Conclude the proof using the fact that the above ensemble of codebooks can achieve the capacity of the Gaussian channel (no need to prove that). 9.21 Mutual information game . Consider the following channel: Throughout this problem we shall constrain the signal power (9.176) and the noise power (9.177) and assume that X and Z are independent. The channel capacity is given by I (X; X + Z) . Now for the game. The noise player chooses a distribution on Z to minimize I (X; X + Z ), while the signal player chooses a distribution on X to maximize I (X; X + Z ). Letting X * ~ (0, P ), Z * ~ (0, N ), show that Gaussian X * and Z * satisfy the saddlepoint conditions (9.178) Thus, (9.179) (9.180) and the game has a value. In particular, a deviation from normal for either player worsens the mutual information from that player’s standpoint. Can you discuss the implications of this? Note: Part of the proof hinges on the entropy power inequality from Section 17.8, which states that if X and Y are independent random n-vectors with densities, then (9.181) 9.22 Recovering the noise Consider a standard Gaussian channel Y n = X n + Z n , where Z i is i.i.d. ~ (0, N ), i = 1, 2,…, n , and . Here we are interested in recovering the noise Z n and we don’t care about the signal X n . By sending X n = (0, 0,…, 0), the receiver gets Y n = Z n and can fully determine the value of Z n . We wonder how much variability there can be in X n and still recover the Gaussian noise Z n . Use of the channel looks like Argue that for some R > 0, the transmitter can arbitrarily send one of 2 nR different sequences of x n without affecting the recovery of the noise in the sense that For what R is this possible? HISTORICAL NOTES The Gaussian channel was first analyzed by Shannon in his original paper [472]. The water-filling solution to the capacity of the colored noise Gaussian channel was developed by Shannon [480] and treated in detail by Pinsker [425]. The time-continuous Gaussian channel is treated in Wyner [576], Gallager [233], and Landau, Pollak, and Slepian [340, 341, 500]. Pinsker [421] and Ebert [178] argued that feedback at most doubles the capacity of a nonwhite Gaussian channel; the proof in the text is from Cover and Pombra [136], who also show that feedback increases the capacity of the nonwhite Gaussian channel by at most half a bit. The most recent feedback capacity results for nonwhite Gaussian noise channels are due to Kim [314].

Chapter 10 Rate Distortion Theory CHAPTER 10 RATE DISTORTION THEORY The description of an arbitrary real number requires an infinite number of bits, so a finite representation of a continuous random variable can never be perfect. How well can we do? To frame the question appropriately, it is necessary to define the “goodness” of a representation of a source. This is accomplished by defining a distortion measure which is a measure of distance between the random variable and its representation. The basic problem in rate distortion theory can then be stated as follows: Given a source distribution and a distortion measure, what is the minimum expected distortion achievable at a particular rate? Or, equivalently, what is the minimum rate description required to achieve a particular distortion? One of the most intriguing aspects of this theory is that joint descriptions are more efficient than individual descriptions. It is simpler to describe an elephant and a chicken with one description than to describe each alone. This is true even for independent random variables. It is simpler to describe X 1 and X 2 together (at a given distortion for each) than to describe each by itself. Why don’t independent problems have independent solutions? The answer is found in the geometry. Apparently, rectangular grid points (arising from independent descriptions) do not fill up the space efficiently. Rate distortion theory can be applied to both discrete and continuous random variables. The zero-error data compression theory of Chapter 5 is an important special case of rate distortion theory applied to a discrete source with zero distortion. We begin by considering the simple problem of representing a single continuous random variable by a finite number, of bits. 10.1 QUANTIZATION In this section we motivate the elegant theory of rate distortion by showing how complicated it is to solve the quantization problem exactly for a single random variable. Since a continuous random source requires infinite precision to represent exactly, we cannot reproduce it exactly using a finite-rate code. The question is then to find the best possible representation for any given data rate. We first consider the problem of representing a single sample from the source. Let the random variable be represented be X and let the representation of X be denoted as (X) . If we are given R bits to represent X , the function can take on 2 R values. The problem is to find the optimum set of values for (called the reproduction points or code points ) and the regions that are associated with each value . For example, let X ~ (0, σ 2 ), and assume a squared-error distortion measure. In this case we wish to find the function (X) such that takes on at most 2 R values and minimizes E(X — X(X) ) 2 . If we are given one bit to represent X , it is clear that the bit should distinguish whether or not X > 0. To minimize squared error, each reproduced symbol should be the conditional mean of its region. This is illustrated in Figure 10.1 . Thus, FIGURE 10.1. One-bit quantization of Gaussian random variable. (10.1) If we are given 2 bits to represent the sample, the situation is not as simple. Clearly, we want to divide the real line into four regions and use a point within each region to represent the sample. But it is no longer immediately obvious what the representation regions and the reconstruction points should be. We can, however, state two simple properties of optimal regions and reconstruction points for the quantization of a single random variable: Given a set { (w) } of reconstruction points, the distortion is minimized by mapping a source random variable X to the representation (w) that is closest to it. The set of regions of χ defined by this mapping is called a Voronoi or Dirichlet partition defined by the reconstruction points. The reconstruction points should minimize the conditional expected distortion over their respective assignment regions. These two properties enable us to construct a simple algorithm to find a “good” quantizer: We start with a set of reconstruction points, find the optimal set of reconstruction regions (which are the nearest-neighbor regions with respect to the distortion measure), then find the optimal reconstruction points for ‘these regions (the centroids of these regions if the distortion is squared error), and then repeat the iteration for this new set of reconstruction points. The expected distortion is decreased at each stage in the algorithm, so the algorithm will converge to a local minimum of the distortion. This algorithm is called the Lloyd algorithm [363] (for real-valued random variables) or the generalized Lloyd algorithm [358] (for vector-valued random variables) and is frequently used to design quantization systems. Instead of quantizing a single random variable, let us assume that we are given a set of n i.i.d. random variables drawn according to a Gaussian distribution. These random variables are to be represented using nR bits. Since the source is i.i.d., the symbols are independent, and it may appear that the representation of each element is an independent problem to be treated separately. But this is not true, as the results on rate distortion theory will show. We will represent the entire sequence by a single index taking 2 nR values. This treatment of entire sequences at once achieves a lower distortion for the same rate than independent quantization of the individual samples. 10.2 DEFINITIONS Assume that we have a source that produces a sequence X 1 , X 2 ,…, X n i.i.d. ~ p(x) , x χ. For the proofs in this chapter, we assume that the alphabet is finite, but-most of the proofs can be extended to continuous random variables. The encoder describes the source sequence X n by an index f n ( X n ) {1, 2,…, 2 nR }. The decoder represents X n by an estimate , as illustrated in Figure 10.2 . FIGURE 10.2. Rate distortion encoder and decoder. Definition A distortion function or distortion measure is a mapping (10.2) from the set of source alphabet-reproduction alphabet pairs into the set of nonnegative real numbers. The distortion d ( x , ) is a measure of the cost of representing the symbol x by the symbol . Definition A distortion measure is said to be bounded if the maximum value of the distortion is finite: (10.3) In most cases, the reproduction alphabet is the same as the source alphabet χ. Examples of common distortion functions are Hamming (probability of error) distortion . The Hamming distortion is given by (10.4) which results in a probability of error distortion, since Ed( X , ) = Pr( X ≠ ). Squared-error distortion The squared-error distortion, (10.5) is the most popular distortion measure used for continuous alphabets. Its advantages are its simplicity and its relationship to least-squares prediction. But in applications such as image and speech coding, various authors have pointed out that the mean-squared error is not an appropriate measure of distortion for human observers. For example, there is a large squared-error distortion between a speech waveform and another version of the same waveform slightly shifted in time, even though both would sound the same to a human observer. Many alternatives have been proposed; a popular measure of distortion in speech coding is the Itakura-Saito distance , which is the relative entropy between multivariate normal processes. In image coding, however, there is at present no real alternative to using the mean-squared error as the distortion measure. The distortion measure is defined on a symbol-by-symbol basis. We extend the definition to sequences by using the following definition: Definition The distortion between sequences x n and n is defined by (10.6) So the distortion for a sequence is the average of the per symbol distortion of the elements of the sequence. This is not the only reasonable definition. For example, one may want to measure the distortion between two sequences by the maximum of the per symbol distortions. The theory derived below does not apply directly to this more general distortion measure. Definition A (2 nR , n)-rate distortion code consists of an encoding function, (10.7) and a decoding (reproduction) function, (10.8) The distortion associated with the (2 nR , n ) code is defined as (10.9) where the expectation is with respect to the probability distribution on X : (10.10) The set of n -tuples g n (1), g n (2),…, g n (2 nR ), denoted by n (1),…, n (2 nR ), constitutes the codebook , and f n −1 (1),…, f n −1 (2 nR ) are the associated assignment regions . Many terms are used to describe the replacement of X n by its quantized version n ( w ). It is common to refer to n as the vector quantization, reproduction, reconstruction, representation, source code , or estimate of X n . Definition A rate distortion pair (R, D) is said to be achievable if there exists a sequence of (2 nR , n )-rate distortion codes ( f n , g n ) with lim n →∞ Ed( X n , g n ( f n ( X n ))) ≤ D . Definition The rate distortion region for a source is the closure of the set of achievable rate distortion pairs (R, D) . Definition The rate distortion function R(D) is the infimum of rates R such that (R, D) is in the rate distortion region of the source for a given distortion D . Definition The distortion rate function D(R) is the infimum of all distortions D such that (R, D) is in the rate distortion region of the source for a given rate R . The distortion rate function defines another way of looking at the boundary of the rate distortion region. We will in general use the rate distortion function rather than the distortion rate function to describe this boundary, although the two approaches are equivalent. We now define a mathematical function of the source, which we call the information rate distortion function . The main result of this chapter is the proof that the information rate distortion function is equal to the rate distortion function defined above (i.e., it is the infimum of rates that achieve a particular distortion). Definition The information rate distortion function R (I) (D) for a source X with distortion measure d(x , ) is defined as (10.11) where the minimization is over all conditional distributions p ( | x ) for which the joint distribution p ( x , ) = p ( x ) p ( | x ) satisfies the expected distortion constraint. Paralleling the discussion of channel capacity in Chapter 7, we initially consider the properties of the information rate distortion function and calculate it for some simple sources and distortion measures. Later we prove that we can actually achieve this function (i.e., there exist codes with rate R (I) (D) with distortion D ). We also prove a converse establishing that R ≥ R (I) (D) for any code that achieves distortion D . The main theorem of rate distortion theory can now be stated as follows: Theorem 10.2.1 The rate distortion function for an i.i.d. source X with distribution p(x) and bounded distortion function d(x, ) is equal to the associated information rate distortion function. Thus , (10.12) is the minimum achievable rate at distortion D . This theorem shows that the operational definition of the rate distortion function is equal to the information definition. Hence we will use R(D) from now on to denote both definitions of the rate distortion function. Before coming to the proof of the theorem, we calculate the information rate distortion function for some simple sources and distortions. 10.3 CALCULATION OF THE RATE DISTORTION FUNCTION 10.3.1 Binary Source We now find the description rate R(D) required to describe a Bernoulli (p) source with an expected proportion of errors less than or equal to D . Theorem 10.3.1 The rate distortion function for a Bernoulli (p) source with Hamming distortion is given by (10.13) Proof: Consider a binary source X ~ Bernoulli (p) with a Hamming distortion measure. Without loss of generality, we may assume that p < 1/2. We wish to calculate the rate distortion function, (10.14) Let ⊕ denote modulo 2 addition. Thus, X ⊕ = 1 is equivalent to X ≠ . We do not minimize I (X; ) directly; instead, we find a lower bound and then show that this lower bound is achievable. For any joint distribution satisfying the distortion constraint, we have (10.15) (10.16) (10.17) (10.18) since Pr( X ≠ ) ≤ D and H (D) increases with D for D ≤ . Thus, (10.19) We now show that the lower bound is actually the rate distortion function by finding a joint distribution that meets the distortion constraint and has I (X; ) = R(D) . For 0 ≤ D ≤ p , we can achieve the value of the rate distortion function in (10.19) by choosing (X, ) to have the joint distribution given by the binary symmetric channel shown in Figure 10.3 . FIGURE 10.3. Joint distribution for binary source. We choose the distribution of at the input of the channel so that the output distribution of X is the specified distribution. Let r = Pr( = 1). Then choose r so that (10.20) or (10.21) If D ≤ p ≤ , then Pr( = 1) ≥ 0 and Pr( = 0) ≥ 0. We then have (10.22) and the expected distortion is Pr( X ≠ ) = D . If D ≥ p , we can achieve R(D) = 0 by letting = 0 with probability 1. In this case, I (X; ) = 0 and D = p . Similarly, if D ≤ 1 — p , we can achieve R(D) = 0 by setting = 1 with probability 1. Hence, the rate distortion function for a binary source is (10.23) This function is illustrated in Figure 10.4 . FIGURE 10.4. Rate distortion function for a Bernoulli (I) source. The above calculations may seem entirely unmotivated. Why should minimizing mutual information have anything to do with quantization? The answer to this question must wait until we prove Theorem 10.2.1. 10.3.2 Gaussian Source Although Theorem 10.2.1 is proved only for discrete sources with a bounded distortion measure, it can also be proved for well-behaved continuous sources and unbounded distortion measures. Assuming this general theorem, we calculate the rate distortion function for a Gaussian source with squared-error distortion. Theorem 10.3.2 The rate distortion function for a (0, σ 2 ) source with squared-error distortion is (10.24) Proof: Let X be ~ (0, σ 2 ). By the rate distortion theorem extended to continuous alphabets, we have (10.25) As in the preceding example, we first find a lower bound for the rate distortion function and then prove that this is achievable. Since E (X — ) 2 ≤ D , we observe that (10.26) (10.27) (10.28) (10.29) (10.30) (10.31) (10.32) where (10.28) follows from the fact that conditioning reduces entropy and (10.29) follows from the fact that the normal distribution maximizes the entropy for a given second moment (Theorem 8.6.5). Hence, (10.33) To find the conditional density f ( |x) that achieves this lower bound, it is usually more convenient to look at the conditional density f (x| ), which is sometimes called the test channel (thus emphasizing the duality of rate distortion with channel capacity). As in the binary case, we construct f (x| ) to achieve equality in the bound. We choose the joint distribution as shown in Figure 10.5 . If D ≤ σ 2 , we choose FIGURE 10.5. Joint distribution for Gaussian source. (10.34) where and Z are independent. For this joint distribution, we calculate (10.35) and E (X — ) 2 = D , thus achieving the bound in (10.33) . If D > σ 2 , we choose = 0 with probability 1, achieving R(D) = 0. Hence, the rate distortion function for the Gaussian source with squared-error distortion is (10.36) as illustrated in Figure 10.6 . FIGURE 10.6. Rate distortion function for a Gaussian source. We can rewrite (10.36) to express the distortion in terms of the rate, (10.37) Each bit of description reduces the expected distortion by a factor of 4. With a 1-bit description, the best expected square error is σ 2 /4. We can compare this with the result of simple 1-bit quantization of a (0, σ 2 ) random variable as described in Section 10.1. In this case, using the two regions corresponding to the positive and negative real lines and reproduction points as the centroids of the respective regions, the expected distortion is = 0.3633σ 2 (see Problem 10.1). As we prove later, the rate distortion limit R(D) is achieved by considering long block lengths. This example shows that we can achieve a lower distortion by considering several distortion problems in succession (long block lengths) than can be achieved by considering each problem separately. This is somewhat surprising because we are quantizing independent random variables. 10.3.3 Simultaneous Description of Independent Gaussian Random Variables Consider the case of representing m independent (but not identically distributed) normal random sources X 1 ,…, X m , where X i are ~ (0, σ 2 i ), with squared-error distortion. Assume that we are given R bits with which to represent this random vector. The question naturally arises as to how we should allot these bits to the various components to minimize the total distortion. Extending the definition of the information rate distortion function to the vector case, we have (10.38) where . Now using the arguments in the preceding example, we have (10.39) (10.40) (10.41) (10.42) (10.43) (10.44) where D i = E ( X i − i ) 2 and (10.41) follows from the fact that conditioning reduces entropy. We can achieve equality in (10.41) by choosing and in (10.43) by choosing the distribution of each i ~ (0, σ 2 i − D i ), as in the preceding example. Hence, the problem of finding the rate distortion function can be reduced to the following optimization (using vats for convenience): (10.45) Using Lagrange multipliers, we construct the functional (10.46) and differentiating with respect to D i and setting equal to 0, we have (10.47) or (10.48) Hence, the optimum allotment of the bits to the various descriptions results in an equal distortion for each random variable. This is possible if the constant λ’ in (10.48) is less than σ 2 i for all i . As the total allowable distortion D is increased, the constant λ’ increases until it exceeds σ 2 i for some i . At this point the solution (10.48) is on the boundary of the allowable region of distortions. If we increase the total distortion, we must use the Kuhn—Tucker conditions to find the minimum in (10.46) . In this case the Kuhn—Tucker conditions yield (10.49) where λ is chosen so that (10.50) It is easy to check that the solution to the Kuhn—Tucker equations is given by the following theorem: Theorem 10.3.3 (Rate distortion for a parallel Gaussian source) Let X i ~ (0, σ 2 i ), i = 1, 2,…, m, be independent Gaussian random variables, and let the distortion measure be d(x m , m ) = . Then the rate distortion function is given by (10.51) where (10.52) where λ is chosen so that . This gives rise to a kind of reverse water-filling, as illustrated in Figure 10.7 . We choose a constant λ and only describe those random variables with variances greater than λ. No bits are used to describe random variables with variance less than λ. Summarizing, if FIGURE 10.7. Reverse water-filling for independent Gaussian random variables. and E(X i — i ) 2 = D i , where D i = min{λ, σ 2 i ). More generally, the rate distortion function for a multivariate normal vector can be obtained by reverse water-filling on the eigenvalues. We can also apply the same arguments to a Gaussian stochastic process. By the spectral representation theorem, a Gaussian stochastic process can be represented as an integral of independent Gaussian processes in the various frequency bands. Reverse water-filling on the spectrum yields the rate distortion function. 10.4 CONVERSE TO THE RATE DISTORTION THEOREM In this section we prove the converse to Theorem 10.2.1 by showing that we cannot achieve a distortion of less than D if we describe X at a rate less than R(D) , where (10.53) The minimization is over all conditional distributions p( |x) for which the joint distribution p(x| ) = p(x)p( |x) satisfies the expected distortion constraint. Before proving the converse, we establish some simple properties of the information rate distortion function. Lemma 10.4.1 (Convexity of R(D)) The rate distortion function R(D) given in (10.53) is a nonincreasing convex function of D . Proof: R(D) is the minimum of the mutual information over increasingly larger sets as D increases. Thus, R(D) is nonincreasing in D . To prove that R(D) is convex, consider two rate distortion pairs, ( R 1 , D 1 ) and ( R 2 , D 2 ), which lie on the rate distortion curve. Let the joint distributions that achieve these pairs be p 1 ( x , ) = p(x)p 1 ( | x ) and p 2 ( x , ) = P(x)P 2 ( | x ). Consider the distribution p λ = λ p 1 + (1 — λ) p 2 . Since the distortion is a linear function of the distribution, we have D(p λ) = λ D 1 + (1 — λ) D 2 . Mutual information, on the other hand, is a convex function of the conditional distribution (Theorem 2.7.4), and hence (10.54) Hence, by the definition of the rate distortion function, (10.55) (10.56) (10.57) which proves that R(D) is a convex function of D . The converse can now be proved. Proof: (Converse in Theorem 10.2.1) . We must show for any source X drawn i.i.d. ~ p(x) with distortion measure d(x, ) and any (2 nR , n ) rate distortion code with distortion ≤ D , that the rate R of the code satisfies R ≥ R(D) . In fact, we prove that R ≥ R(D) even for randomized mappings f n and g n , as long as f n takes on at most 2 nR values. Consider any (2 nR , n ) rate distortion code defined by functions f n and g n as given in (10.7) and (10.8) . Let n = n ( X n ) = g n ( f n ( X n )) be the reproduced sequence corresponding to X n . Assume that Ed(X n , n ) ≤ D for this code. Then we have the following chain of inequalities: (10.58) (10.59) (10.60) (10.61) (10.62) (10.63) (10.64) (10.65) (10.66) (10.67) (10.68) (10.69) (10.70) (10.71) where (a) follows from the fact that the range of f n is at most 2 nR (b) follows from the fact that H(f n ( X n )| X n ) ≥ 0 (c) follows from the data-processing inequality (d) follows from the fact that the X i are independent (e) follows from the chain rule for entropy (f) follows from the fact that conditioning reduces entropy (g) follows from the definition of the rate distortion function (h) follows from the convexity of the rate distortion function (Lemma 10.4.1) and Jensen’s inequality (i) follows from the definition of distortion for blocks of length n (j) follows from the fact that R(D) is a nonincreasing function of D and Ed(X n , n ) ≤ D This shows that the rate R of any rate distortion code exceeds the rate distortion function R(D) evaluated at the distortion level D = Ed (X n , n ) achieved by that code. A similar argument can be applied when the encoded source is passed through a noisy channel and hence we have the equivalent of the source channel separation theorem with distortion: Theorem 10.4.1 (Source—channel separation theorem with distortion) Let V 1 , V 2 ,…, V n be a finite alphabet i.i.d. source which is encoded as a sequence of n input symbols X n of a discrete memoryless channel with capacity C. The output of the channel Y n is mapped onto the reconstruction alphabet = g(Y n ). Let D = be the average distortion achieved by this combined source and channel coding scheme. Then distortion D is achievable if and only if C > R(D) . Proof: See Problem 10.17. 10.5 ACHIEVABILITY OF THE RATE DISTORTION FUNCTION We now prove the achievability of the rate distortion function. We begin with a modified version of the joint AEP in which we add the condition that the pair of sequences be typical with respect to the distortion measure. Definition Let p(x, ) be a joint probability distribution on and let d(x, ) be a distortion measure on χ × . For any > 0, a pair of sequences ( x n , n ) is said to be distortion -typical or simply distortion typical if (10.72) (10.73) (10.74) (10.75) The set of distortion typical sequences is called the distortion typical set and is denoted Note that this is the definition of the jointly typical set (Section 7.6) with the additional constraint that the distortion be close to the expected value. Hence, the distortion typical set is a subset of the jointly typical set (i.e., ). If ( X i i ), are drawn i.i.d ~ p(x, ) , the distortion between two random sequences (10.76) is an average of i.i.d. random variables, and the law of large numbers implies that it is close to its expected value with high probability. Hence we have the following lemma. Lemma 10.5.1 Let (X i , i ) be drawn i.i.d. ~ p(x, ). Then → 1 as n → ∞. Proof: The sums in the four conditions in the definition of are all normalized sums of i.i.d random variables and hence, by the law of large numbers, tend to their respective expected values with probability 1. Hence the set of sequences satisfying all four conditions has probability tending to 1 as n → ∞. The following lemma is a direct consequence of the definition of the distortion typical set. Lemma 10.5.2 For all , (10.77) Proof: Using the definition of , we can bound the probabilities p(x n ), p( n ) and p(x n , n ) for all , and hence (10.78) (10.79) (10.80) (10.81) and the lemma follows immediately. We also need the following interesting inequality. Lemma 10.5.3 For 0 ≤ x, y ≤ 1, n > 0, (10.82) Proof: Let f(y) = e − y — 1 + y . Then f (0) = 0 and f’(y) = − e − y + 1 > 0 for y > 0, and hence f (y) > 0 for y > 0. Hence for 0 ≤ y ≤ 1, we have 1 — y ≤ e − y , and raising this to the nth power, we obtain (10.83) Thus, the lemma is satisfied for x = 1. By examination, it is clear that the inequality is also satisfied for x = 0. By differentiation, it is easy to see that g y (x) = (1 — xy ) n is a convex function of x , and hence for 0 ≤ x ≤ 1, we have (10.84) (10.85) (10.86) (10.87) (10.88) We use the preceding proof to prove the achievability of Theorem 10.2.1. Proof: (Achievability in Theorem 10.2.1) . Let X 1 , X 2 ,…, X n be drawn i.i.d. ~ p (x) and let d(x ) be a bounded distortion measure for this source. Let the rate distortion function for this source be R(D) . Then for any D , and any R > R(D) , we will show that the rate distortion pair (R, D) is achievable by proving the existence of a sequence of rate distortion codes with rate R and asymptotic distortion D . Fix p( |x) , where p( |x) achieves equality in (10.53). Thus, I (X; ) = R(D) . Calculate . Choose δ > 0. We will prove the existence of a rate distortion code with rate R and distortion less than or equal to D + δ. Generation of codebook: Randomly generate a rate distortion codebook C consisting of 2 nR sequences n drawn i.i.d. ~ . Index these codewords by w {1, 2,…, 2 nR }. Reveal this codebook to the encoder and decoder. Encoding: Encode X n by w if there exists a w such that ( X n , n ( w )) , the distortion typical set. If there is more than one such w , send the least. If there is no such w , let w = 1. Thus, nR bits suffice to describe the index w of the jointly typical codeword. Decoding: The reproduced sequence is n (w) . Calculation of distortion: As in the case of the channel coding theorem, we calculate the expected distortion over the random choice of codebooks C as (10.89) where the expectation is over the random choice of codebooks and over X n For a fixed codebook C and choice of > 0, we divide the sequences x n χ n into two categories: Sequences x n such that there exists a codeword n (w) that is distortion typical with x n [i.e., d(x n , n (w) ) < D + ]. Since the total probability of these sequences is at most 1, these sequences contribute at most D + to the expected distortion. Sequences x n such that there does not exist a codeword n (w) that is distortion typical with x n . Let P e be the total probability of these sequences. Since the distortion for any individual sequence is bounded by d max , these sequences contribute at most P e d max to the expected distortion. Hence, we can bound the total distortion by (10.90) which can be made less than D + δ for an appropriate choice of if P e is small enough. Hence, if we show that P e is small, the expected distortion is close to D and the theorem is proved. Calculation of P e : We must bound the probability that for a random choice of codebook C and a randomly chosen source sequence, there is no codeword that is distortion typical with the source sequence. Let J(C) denote the set of source sequences x n such that at least one codeword in C is distortion typical with x n . Then (10.91) This is the probability of all sequences not well represented by a code, averaged over the randomly chosen code. By changing the order of summation, we can also interpret this as the probability of choosing a codebook that does not well represent sequence x n , averaged with respect to p(x n ). Thus, (10.92) Let us define (10.93) The probability that a single randomly chosen codeword n does not well represent a fixed x n is (10.94) and therefore the probability that 2 nR independently chosen codewords do not represent x n , averaged over p(x n ), is (10.95) (10.96) We now use Lemma 10.5.2 to bound the sum within the brackets. From Lemma 10.5.2, it follows that (10.97) and hence (10.98) We now use Lemma 10.5.3 to bound the term on the right-hand side of (10.98) and obtain (10.99) Substituting this inequality in (10.98) , we obtain (10.100) The last term in the bound is equal to (10.101) which goes to zero exponentially fast with n if R > I (X; ) + 3 . Hence if we choose p ( |x) to be the conditional distribution that achieves the minimum in the rate distortion function, then R > R(D) implies that R > I (X; ) and we can choose e small enough so that the last term in (10.100) goes to 0. The first two terms in (10.100) give the probability under the joint distribution p(x n , n ) that the pair of sequences is not distortion typical. Hence, using Lemma 10.5.1, we obtain (10.102) for n sufficiently large. Therefore, by an appropriate choice of and n , we can make P e as small as we like. So, for any choice of δ > 0, there exists an and n such that over all randomly chosen rate R codes of block length n , the expected distortion is less than D + δ. Hence, there must exist at least one code C * with this rate and block length with average distortion less than D + δ. Since δ was arbitrary, we have shown that (R, D) is achievable if R > R(D) . We have proved the existence of a rate distortion code with an expected distortion close to D and a rate close to R(D) . The similarities between the random coding proof of the rate distortion theorem and the random coding proof of the channel coding theorem are now evident. We will explore the parallels further by considering the Gaussian example, which provides some geometric insight into the problem. It turns out that channel coding is sphere packing and rate distortion coding is sphere covering. Channel coding for the Gaussian channel . Consider a Gaussian channel, Y i = X i + Z i , where the Z i are i.i.d. ~ (0, N ) and there is a power constraint P on the power per symbol of the transmitted codeword. Consider a sequence of n transmissions. The power constraint implies that the transmitted sequence lies within a sphere of radius in . The coding problem is equivalent to finding a set of 2 nR sequences within this sphere such that the probability of any of them being mistaken for any other is small—the spheres of radius around each of them are almost disjoint. This corresponds to filling a sphere of radius with spheres of radius . One would expect that the largest number of spheres that could be fit would be the ratio of their volumes, or, equivalently, the nth power of the ratio of their radii. Thus, if M is the number of codewords that can be transmitted efficiently, we have (10.103) The results of the channel coding theorem show that it is possible to do this efficiently for large n ; it is possible to find approximately (10.104) codewords such that the noise spheres around them are almost disjoint (the total volume of their intersection is arbitrarily small). Rate distortion for the Gaussian source . Consider a Gaussian source of variance σ 2 . A (2 nR , n ) rate distortion code for this source with distortion D is a set of 2 nR sequences in such that most source sequences of length n (all those that lie within a sphere of radius ) are within a distance of some codeword. Again, by the sphere-packing argument, it is clear that the minimum number of codewords required is (10.105) The rate distortion theorem shows that this minimum rate is asymptotically achievable (i.e., that there exists a collection of spheres of radius that cover the space except for a set of arbitrarily small probability). The above geometric arguments also enable us to transform a good code for channel transmission into a good code for rate distortion. In both cases, the essential idea is to fill the space of source sequences: In channel transmission, we want to find the largest set of codewords that have a large minimum distance between codewords, whereas in rate distortion, we wish to find the smallest set of codewords that covers the entire space. If we have any set that meets the sphere packing bound for one, it will meet the sphere packing bound for the other. In the Gaussian case, choosing the codewords to be Gaussian with the appropriate variance is asymptotically optimal for both rate distortion and channel coding. 10.6 STRONGLY TYPICAL SEQUENCES AND RATE DISTORTION In Section 10.5 we proved the existence of a rate distortion code of rate R(D) with average distortion close to D . In fact, not only is the average distortion close to D , but the total probability that the distortion is greater than D + δ is close to 0. The proof of this is similar to the proof in Section 10.5; the main difference is that we will use strongly typical sequences rather than weakly typical sequences. This will enable us to give an upper bound to the probability that a typical source sequence is not well represented by a randomly chosen codeword in (10.94) . We now outline an alternative proof based on strong typicality that will provide a stronger and more intuitive approach to the rate distortion theorem. We begin by defining strong typicality and quoting a basic theorem bounding the probability that two sequences are jointly typical. The properties of strong typicality were introduced by Berger [53] and were explored in detail in the book by Csiszár and Körner [149]. We will define strong typicality (as in Chapter 11) and state a fundamental lemma (Lemma 10.6.2). Definition A sequence x n χ n is said to be -strongly typical with respect to a distribution p(x) on χ if: 1. For all a χ with p(a) > 0, we have (10.106) 2. For all a χ with p(a) = 0, N(a|x n ) = 0. N (a|x n ) is the number of occurrences of the symbol a in the sequence x n The set of sequences x n χ n such that x n is strongly typical is called the strongly typical set and is denoted when the random variable is understood from the context. Definition A pair of sequences (x n , y n ) χ n × y n is said to be -strongly typical with respect to a distribution p(x, y) on χ × y if: 1. For all (a, b) χ × y with p(a, b) > 0, we have (10.107) 2. For all (a, b) χ × y with p(a, b) = 0, N(a, b|x n , y n ) = 0. N(a, b|x n , y n ) is the number of occurrences of the pair (a, b) in the pair of sequences (x n , y n ) . The set of sequences (x n , y n ) χ n × y n such that ( x n , y n ) is strongly typical is called the strongly typical set and is denoted or . From the definition, it follows that if (x n , y n ) , then . From the strong law of large numbers, the following lemma is immediate. Lemma 10.6.1 Let ( X i , Y i ) be drawn i.i.d. ~ p(x, y) . Then → 1 as n → ∞. We will use one basic result, which bounds the probability that an independently drawn sequence will be seen as jointly strongly typical with a given sequence. Theorem 7.6.1 shows that if we choose X n and Y n independently, the probability that they will be weakly jointly typical is ≈ 2 −– nI(X; Y) . The following lemma extends the result to strongly typical sequences. This is stronger than the earlier result in that it gives a lower bound on the probability that a randomly chosen sequence is jointly typical with a fixed typical x n . Lemma 10.6.2 Let Y 1 , Y 2 ,…, Y n be drawn i.i.d. ~ p(y). For x n (X), the probability that is bounded by (10.108) where 1 goes to 0 as → 0 and n → ∞ . Proof: We will not prove this lemma, but instead, outline the proof in Problem 10.16 at the end of the chapter. In essence, the proof involves finding a lower bound on the size of the conditionally typical set. We will proceed directly to the achievability of the rate distortion function. We will only give an outline to illustrate the main ideas. The construction of the codebook and the encoding and decoding are similar to the proof in Section 10.5. Proof: Fix p( |x) . Calculate p( ) = ∑ x p(x)p( |x) . Fix > 0. Later we will choose appropriately to achieve an expected distortion less than D + δ. Generation of codebook: Generate a rate distortion codebook C consisting of 2 nR sequences n drawn i.i.d. ~ . Denote the sequences n (1),…, n (2 nR ). Encoding: Given a sequence X n , index it by w if there exists a w such that , the strongly jointly typical set. If there is more than one such w , send the first in lexicographic order. If there is no such w , let w = 1. Decoding: Let the reproduced sequence be n (w) . Calculation of distortion: As in the case of the proof in Section 10.5, we calculate the expected distortion over the random choice of codebook as (10.109) (10.110) (10.111) where the expectation is over the random choice of codebook. For a fixed codebook C , we divide the sequences x n χ n into three categories, as shown in Figure 10.8 . FIGURE 10.8. Classes of source sequences in rate distortion theorem. Nontypical sequences . The total probability of these sequences can be made less than by choosing n large enough. Since the individual distortion between any two sequences is bounded by d max , the nontypical sequences can contribute at most d max to the expected distortion. Typical sequences such that there exists a codeword that is jointly typical with x n . In this case, since the source sequence and the codeword are strongly jointly typical, the continuity of the distortion as a function of the joint distribution ensures that they are also distortion typical. Hence, the distortion between these x n and their codewords is bounded by D + d max , and since the total probability of these sequences is at most 1, these sequences contribute at most D + d max to the expected distortion. Typical sequences such that there does not exist a codeword n that is jointly typical with x n . Let P e be the total probability of these sequences. Since the distortion for any individual sequence is bounded by d max , these sequences contribute at most P e d max to the expected distortion. The sequences in the first and third categories are the sequences that may not be well represented by this rate distortion code. The probability of the first category of sequences is less than for sufficiently large n . The probability of the last category is P e , which we will show can be made small. This will prove the theorem that the total probability of sequences that are not well represented is small. In turn, we use this to show that the average distortion is close to D . Calculation of P e : We must bound the probability that there is no codeword that is jointly typical with the given sequence X n . From the joint AEP, we know that the probability that X n and any n are jointly typical is = 2 − nI (X; ) . Hence the expected number of jointly typical n (w) is 2 nR 2 − nI (X; ) which is exponentially large if R > I (X; ) . But this is not sufficient to show that P e → 0. We must show that the probability that there is no codeword that is jointly typical with X n goes to zero. The fact that the expected number of jointly typical codewords is exponentially large does not ensure that there will at least one with high probability. Just as in (10.94) , we can expand the probability of error as (10.112) From Lemma 10.6.2 we have (10.113) Substituting this in (10.112) and using the inequality (1 — x ) n ≤ e − nx , we have (10.114) which goes to 0 as n → ∞ if R > I (X; ) + 1 . Hence for an appropriate choice of and n , we can get the total probability of all badly represented sequences to be as small as we want. Not only is the expected distortion close to D , but with probability going to 1, we will find a codeword whose distortion with respect to the given sequence is less than D + δ. 10.7 CHARACTERIZATION OF THE RATE DISTORTION FUNCTION We have defined the information rate distortion function as (10.115) where the minimization is over all conditional distributions q( |x) for which the joint distribution p(x)q( |x) satisfies the expected distortion constraint. This is a standard minimization problem of a convex function over the convex set of all q( |x) ≥ 0 satisfying for all x and We can use the method of Lagrange multipliers to find the solution. We set up the functional (10.116) (10.117) where the last term corresponds to the constraint that q( |x) is a conditional probability mass function. If we let q( ) = ∑ x p(x)q( |x) be the distribution on induced by q( |x) , we can rewrite J(q) as (10.118) (10.119) Differentiating with respect to q( |x) , we have (10.120) Setting log μ (x) = v(x)/p(x) , we obtain (10.121) or (10.122) Since , we must have (10.123) or (10.124) Multiplying this by p ( x ) and summing over all x , we obtain (10.125) If q ( ) > 0, we can divide both sides by q ( ) and obtain (10.126) for all . We can combine these equations with the equation defining the distortion and calculate λ and the unknowns q ( ). We can use this and (10.124) to find the optimum conditional distribution. The above analysis is valid if q ( ) is unconstrained (i.e., q ( ) > 0 for all ). The inequality condition q ( ) > 0 is covered by the Kuhn—Tucker conditions, which reduce to (10.127) Substituting the value of the derivative, we obtain the conditions for the minimum as (10.128) (10.129) This characterization will enable us to check if a given q ( ) is a solution to the minimization problem. However, it is not easy to solve for the optimum output distribution from these equations. In the next section we provide an iterative algorithm for computing the rate distortion function. This algorithm is a special case of a general algorithm for finding the minimum relative entropy distance between two convex sets of probability densities. 10.8 COMPUTATION OF CHANNEL CAPACITY AND THE RATE DISTORTION FUNCTION Consider the following problem: Given two convex sets A and B in R n as shown in Figure 10.9 , we would like to find the minimum distance between them: FIGURE 10.9. Distance between convex sets. (10.130) where d(a, b) is the Euclidean distance between a and b . An intuitively obvious algorithm to do this would be to take any point x A , and find the y B that is closest to it. Then fix this y and find the closest point in A . Repeating this process, it is clear that the distance decreases at each stage. Does it converge to the minimum distance between the two sets? Csiszár and Tusnády [155] have shown that if the sets are convex and if the distance satisfies certain conditions, this alternating minimization algorithm will indeed converge to the minimum. In particular, if the sets are sets of probability distributions and the distance measure is the relative entropy, the algorithm does converge to the minimum relative entropy between the two sets of distributions. To apply this algorithm to rate distortion, we have to rewrite the rate distortion function as a minimum of the relative entropy between two sets. We begin with a simple lemma. A form of this lemma comes up again in theorem 13.1.1, establishing the duality of channel capacity universal data compression. Lemma 10.8.1 Let p(x)p(y|x) be a given joint distribution. Then the distribution r(y) that minimizes the relative entropy D(p(x)p(y|x)||p(x) r(y)) is the marginal distribution r*(y) corresponding to p(y|x): (10.131) where r*(y) = ∑ x p(x)p(y|x). Also , (10.132) where (10.133) Proof (10.134) (10.135) (10.136) (10.137) (10.138) (10.139) The proof of the second part of the lemma is left as an exercise. We can use this lemma to rewrite the minimization in the definition of the rate distortion function as a double minimization, (10.140) If A is the set of all joint distributions with marginal p(x) that satisfy the distortion constraints and if B the set of product distributions p(x)r( ) with arbitrary r( ) , we can write (10.141) We now apply the process of alternating minimization, which is called the Blahut-Arimoto algorithm in this case. We begin with a choice of λ and an initial output distribution r( ) and calculate the q( |x) that minimizes the mutual information subject to the distortion constraint. We can use the method of Lagrange multipliers for this minimization to obtain (10.142) For this conditional distribution q( |x) , we calculate the output distribution r( ) that minimizes the mutual information, which by Lemma 10.8.1 is (10.143) We use this output distribution as the starting point of the next iteration. Each step in the iteration, minimizing over q(·|·) and then minimizing over r(·) , reduces the right-hand side of (10.140) . Thus, there is a limit, and the limit has been shown to be R(D) by Csiszár [139], where the value of D and R(D) depends on λ. Thus, choosing λ appropriately sweeps out the R(D) curve. A similar procedure can be applied to the calculation of channel capacity. Again we rewrite the definition of channel capacity, (10.144) as a double maximization using Lemma 10.8.1, (10.145) In this case, the Csiszár—Tusnady algorithm becomes one of alternating maximization—we start with a guess of the maximizing distribution r ( x ) and find the best conditional distribution, which is, by Lemma 10.8.1, (10.146) For this conditional distribution, we find the best input distribution r ( x ) by solving the constrained maximization problem with Lagrange multipliers. The optimum input distribution is (10.147) which we can use as the basis for the next iteration. These algorithms for the computation of the channel capacity and the rate distortion function were established by Blahut [65] and Arimoto [25] and the convergence for the rate distortion computation was proved by Csiszár [139]. The alternating minimization procedure of Csiszár and Tusnady can be specialized to many other situations as well, including the EM algorithm [166], and the algorithm for finding the log-optimal portfolio for a stock market [123]. SUMMARY Rate distortion. The rate distortion function for a source X ~ p ( x ) and distortion measure d ( x, ) is (10.148) where the minimization is over all conditional distributions p ( |x ) for which the joint distribution p ( x, ) = p ( x ) p ( |x ) satisfies the expected distortion constraint. Rate distortion theorem. If R > R ( D ), there exists a sequence of codes n ( X n ) with the number of codewords | n (·) | ≤ 2 nR with Ed ( X n , n ( X n )) → D . If R < R ( D ), no such codes exist. Bernoulli source. For a Bernoulli source with Hamming distortion, (10.149) Gaussian source. For a Gaussian source with squared-error distortion, (10.150) Source-channel separation. A source with rate distortion R ( D ) can be sent over a channel of capacity C and recovered with distortion D if and only if R ( D ) < C . Multivariate Gaussian source. The rate distortion function for a multivariate normal vector with Euclidean mean-squared-error distortion is given by reverse water-filling on the eigenvalues. PROBLEMS 10.1 One-bit quantization of a single Gaussian random variable . Let X ~ (0, σ 2 ) and let the distortion measure be squared error. Here we do not allow block descriptions. Show that the optimum reproduction points for 1-bit quantization are and that the expected distortion for 1-bit quantization is . Compare this with the distortion rate bound D = σ 2 2 − 2R for R = 1. 10.2 Rate distortion function with infinite distortion . Find the rate distortion function R ( D ) = min I ( X; ) for X ~ Bernoulli ( ) and distortion 10.3 Rate distortion for binary source with asymmetric distortion . Fix p ( |x ) and evaluate I ( X; ) and D for (The rate distortion function cannot be expressed in closed form.) 10.4 Properties of R ( D ). Consider a discrete source X χ = {1, 2,…, m } with distribution p 1 , p 2 ,…., p m and a distortion measure d ( i, j ). Let R ( D ) be the rate distortion function for this source and distortion measure. Let d ’( i, j ) = d ( i, j ) — w i be a new distortion measure, and let R ’( D ) be the corresponding rate distortion function. Show that R ’( D ) = R ( D + ), where , and use this to show that there is no essential loss of generality in assuming that min d ( i, ) = 0 (i.e., for each x χ, there is one symbol that reproduces the source with zero distortion). This result is due to Pinkston [420]. 10.5 Rate distortion for uniform source with Hamming distortion . Consider a source X uniformly distributed on the set {1, 2,…., m }. Find the rate distortion function distortion; that is, 10.6 Shannon lower bound for the rate distortion function . Consider a source X with a distortion measure d ( x, ) that satisfies the following property: All columns of the distortion matrix are per mutations of the set { d 1 , d 2 , …., d m }. Define the function (10.151) The Shannon lower bound on the rate distortion function [485] is proved by the following steps: (a) Show that ø( D ) is a concave function of D . (b) Justify the following series of inequalities for I ( X; ) if Ed ( X, ) ≤ D , (10.152) (10.153) (10.154) (10.155) (10.156) where . (c) Argue that (10.157) which is the Shannon lower bound on the rate distortion function. (d) If, in addition, we assume that the source has a uniform distribution and that the rows of the distortion matrix are permutations of each other, then R ( D ) = H ( X ) — ø( D ) (i.e., the lower bound is tight). 10.7 Erasure distortion . Consider X ~ Bernoulli ( ), and let the distortion measure be given by the matrix (10.158) Calculate the rate distortion function for this source. Can you suggest a simple scheme to achieve any value of the rate distortion function for this source? 10.8 Bounds on the rate distortion function for squared-error distortion . For the case of a continuous random variable X with mean zero and variance σ 2 and squared-error distortion, show that (10.159) For the upper bound, consider the following joint distribution: Are Gaussian random variables harder or easier to describe than other random variables with the same variance? 10.9 Properties of optimal rate distortion code . A good ( R, D ) rate distortion code with R ≈ R ( D ) puts severe constraints on the relationship of the source X n and the representations n . Examine the chain of inequalities ( 10.58 – 10.71 ) considering the conditions for equality and interpret as properties of a good code. For example, equality in (10.59) implies that n is a deterministic function of X n . 10.10 Rate distortion . Find and verify the rate distortion function R ( D ) for X uniform on χ = {1, 2,…, 2 m } and where is defined on = {1, 2,…, 2 m }. (You may wish to use the Shannon lower bound in your argument.) 10.11 Lower bound . Let and Define g ( a ) = max h ( X ) over all densities such that EX 4 ≤ a . Let R ( D ) be the rate distortion function for X with the density above and with distortion criterion d ( x , ) = ( x − ). Show that R ( D ) ≤ g ( c ) — g ( D ). 10.12 Adding a column to the distortion matrix . Let R ( D ) be the rate distortion function for an i.i.d. process with probability mass function p ( x ) and distortion function . Now suppose that we add a new reproduction symbol to χ with associated distortion . Does this increase or decrease R ( D ), and why? 10.13 Simplification . Suppose that χ = {1, 2, 3, 4}, = {1, 2, 3, 4}, p ( i ) = 1/4, i = 1, 2, 3, 4, and X 1 , X 2 , … are i.i.d. ~ p ( x ). The distortion matrix d ( x, ) is given by (a) Find R (0), the rate necessary to describe the process with zero distortion. (b) Find the rate distortion function R ( D ). There are some irrelevant distinctions in alphabets χ and , which allow the problem to be collapsed. (c) Suppose that we have a nonuniform distribution p ( i ) = p i , i = 1, 2, 3, 4. What is R ( D )? 10.14 Rate distortion for two independent sources . Can one compress two independent sources simultaneously better than by compressing the sources individually? The following problem addresses this question. Let { X i } be i.i.d. ~ p ( x ) with distortion d ( x , ) and rate distortion function R x ( D ). Similarly, let { Y i } be i.i.d. ~ p ( y ) with distortion d ( y, ) and rate distortion function R Y ( D ). Suppose we now wish to describe the process {( X i , Y i )} subject to distortions Ed ( X , ) ≤ D 1 and Ed ( Y , ) ≤ D 2 . Thus, a rate R X, Y ( D 1 , D 2 ) is sufficient, where Now suppose that the { X i } process and the { Y i } process are independent of each other. (a) Show that (b) Does equality hold? Now answer the question. 10.15 Distortion rate function . Let (10.160) be the distortion rate function. (a) Is D(R) increasing or decreasing in R ? (b) Is D(R) convex or concave in R ? (c) Converse for distortion rate functions: We now wish to prove the converse by focusing on D(R) . Let X 1 , X 2 ,…, X n be i.i.d. ~ p(x) . Suppose that one is given a (2 nR , n ) rate distortion code X n → i ( X n ) → n ( i ( X n )), with i ( X n ) 2 nR , and suppose that the resulting distortion is D = Ed(X n , ( n ( i ( X n ))), We must show that D ≥ D(R) . Give reasons for the following steps in the proof: (10.161) (10.162) (10.163) (10.164) (10.165) (10.166) (10.167) 10.16 Probability of conditionally typical sequences . In Chapter 7 we calculated the probability that two independently drawn sequences X n and Y n are weakly jointly typical. To prove the rate distortion theorem, however, we need to calculate this probability when one of the sequences is fixed and the other is random. The techniques of weak typicality allow us only to calculate the average set size of the conditionally typical set. Using the ideas of strong typicality, on the other hand, provides us with stronger bounds that work for all typical x n sequences. We outline the proof that for all typical x n . This approach was introduced by Berger [53] and is fully developed in the book by Csiszár and Körner [149]. Let ( X i , Y i ) be drawn i.i.d. ~ p ( x, y ). Let the marginals of X and Y be p(x) and p(y) , respectively. (a) Let be the strongly typical set for X . Show that (10.168) (Hint: Theorems 11.1.1 and 11.1.3.) (b) The joint type of a pair of sequences ( x n , y n ) is the proportion of times ( x i , y i ) = ( a, b ) in the pair of sequences: (10.169) The conditional type of a sequence y n given x n is a stochastic matrix that gives the proportion of times a particular element of occurred with each element of χ in the pair of sequences. Specifically, the conditional type V y n | x n ( b|a ) is defined as (10.170) Show that the number of conditional types is bounded by ( n + 1) |X||Y| (c) The set of sequences y n y n with conditional type V with respect to a sequence x n is called the conditional type class T v ( x n ). Show that (10.171) (d) The sequence is said to be -strongly conditionally typical with the sequence x n with respect to the conditional distribution V (·|·) if the conditional type is close to V . The conditional type should satisfy the following two conditions: (i) For all ( a, b ) , (10.172) (ii) N ( a, b | x n , y n ) = 0 for all ( a, b ) such that V ( b|a ) = 0. The set of such sequences is called the conditionally typical set and is denoted . Show that the number of sequences y n that are conditionally typical with a given x n χ n is bounded by (10.173) where 1 → 0 as → 0. (e) For a pair of random variables (X, Y) with joint distribution p(x, y) , the -strongly typical set is the set of sequences satisfying (i) (10.174) for every pair (a, b) with p(a, b) > 0. (ii) N(a, b|x n , y n ) = 0 for all (a, b) with p(a, b) = 0. The set of -strongly jointly typical sequences is called the -strongly jointly typical set and is denoted . Let ( X, Y ) be drawn i.i.d. ~ p(x, y ). For any x n such that there exists at least one pair , the set of sequences y n such that satisfies (10.175) where δ ( ) → 0 as → 0. In particular, we can write (10.176) where we can make 2 arbitrarily small with an appropriate choice of and n . (f) Let Y 1 , Y 2 ,…, Y n be drawn i.i.d. ~ . For , the probability that is bounded by (10.177) where 3 goes to 0 as → 0 and n → ∞. 10.17 Source-channel separation theorem with distortion . Let V 1 , V 2 ,…, V n be a finite alphabet i.i.d. source which is encoded as a sequence of n input symbols X n of a discrete memoryless channel. The output of the channel Y n is mapped onto the reconstruction alphabet = g ( Y n ). Let D = be the average distortion achieved by this combined source and channel coding scheme. (a) Show that if C > R(D) , where R(D) is the rate distortion function for V , it is possible to find encoders and decoders that achieve a average distortion arbitrarily close to D . (b) (Converse) Show that if the average distortion is equal to D , the capacity of the channel C must be greater than R(D) . 10.18 Rate distortion . Let d(x, ) be a distortion function. We have a source X ~ p(x) . Let R(D) be the associated rate distortion function. (a) Find (D) in terms of R(D) , where (D) is the rate distortion function associated with the distortion for some constant a > 0. (They are not equal.) (b) Now suppose that d(x, ) ≥ 0 for all x , and define a new distortion function d* ( x, ) = bd ( x, ), where b is some number ≥ 0. Find the associated rate distortion function R* (D) in terms of R(D) . (c) Let X ~ N (0, σ 2 ) and d ( x, ) = 5( x − ) 2 + 3. What is R(D) ? 10.19 Rate distortion with two constraints . Let X i be iid ~ p(x) . We are given two distortion functions, d 1 ( x, ) and d 2 ( x, ). We wish to describe X n at rate R and reconstruct it with distortions , and , as shown here: Here i (.) takes on 2 nR values. What is the rate distortion function R ( D 1 , D 2 )? 10.20 Rate distortion . Consider the standard rate distortion problem, X i i.i.d. ~ p(x) , X n → i ( X n ) → n , | i (.)| = 2 nR . Consider two distortion criteria d 1 ( x, ) and d 2 ( x, ). Suppose that d 1 ( x , ) ≤ d 2 ( x, ) for all x χ , χ. Let R 1 ( D ) and R 2 ( D ) be the corresponding rate distortion functions. (a) Find the inequality relationship between R 1 ( D ) and R 2 ( D ). (b) Suppose that we must describe the source { X i } at the minimum rate R achieving . Thus, and | i (.)| = 2 nR . Find the minimum rate R . HISTORICAL NOTES The idea of rate distortion was introduced by Shannon in his original paper [472]. He returned to it and dealt with it exhaustively in his 1959 paper [485], which proved the first rate distortion theorem. Meanwhile, Kolmogorov and his school in the Soviet Union began to develop rate distortion theory in 1956. Stronger versions of the rate distortion theorem have been proved for more general sources in the comprehensive book by Berger [52]. The inverse water-filling solution for the rate distortion function for parallel Gaussian sources was established by McDonald and Schultheiss [381]. An iterative algorithm for the calculation of the rate distortion function for a general i.i.d. source and arbitrary distortion measure was described by Blahut [65], Arimoto [25], and Csiszár [139]. This algorithm is a special case of a general alternating minimization algorithm due to Csiszár and Tusnády [155].

Chapter 11 Information Theory and Statistics CHAPTER 11 INFORMATION THEORY AND STATISTICS We now explore the relationship between information theory and statistics. We begin by describing the method of types, which is a powerful technique in large deviation theory. We use the method of types to calculate the probability of rare events and to show the existence of universal source codes. We also consider the problem of testing hypotheses and derive the best possible error exponents for such tests (the Chernoff–Stein lemma). Finally, we treat the estimation of the parameters of a distribution and describe the role of Fisher information. 11.1 METHOD OF TYPES The AEP for discrete random variables (Chapter 3) focuses our attention on a small subset of typical sequences. The method of types is an even more powerful procedure in which we consider sequences that have the same empirical distribution. With this restriction, we can derive strong bounds on the number of sequences with a particular empirical distribution and the probability of each sequence in this set. It is then possible to derive strong error bounds for the channel coding theorem and prove a variety of rate distortion results. The method of types was fully developed by Csiszár and Körner [149], who obtained most of their results from this point of view. Let X 1 , X 2 ,…, X n be a sequence of n symbols from an alphabet χ = { a 1 , a 2 ,…, a | χ |}. We use the notation x n and x interchangeably to denote a sequence x 1 ,…, x n . Definition The type P x , (or empirical probability distribution) of a sequence x 1 , x 2 ,…, x n is the relative proportion of occurrences of each symbol of χ (i.e., P x (a) = N ( a | x ) / n for all a χ , where N ( a | x ) is the number of times the symbol a occurs in the sequence x χ n ). The type of a sequence x is denoted as P x . It is a probability mass function on χ . (Note that in this chapter, we will use capital letters to denote types and distributions. We also loosely use the word distribution to mean a probability mass function.) Definition The probability simplex in R m is the set of points x = ( x 1 , x 2 ,…, x m ) R m such that . The probability simplex is an ( m − 1)-dimensional manifold in m -dimensional space. When m = 3, the probability simplex is the set of points {( x 1 , x 2 , x 3 ) : x 1 ≥ 0, x 2 ≥ 0, x 3 ≥ 0, x 1 + x 2 + x 3 = 1} ( Figure 11.1 ). Since this is a triangular two-dimensional flat in R 3 , we use a triangle to represent the probability simplex in later sections of this chapter. FIGURE 11.1. Probability simplex in R 3 . Definition Let n denote the set of types with denominator n . For example, if χ = {0, 1}, the set of possible types with denominator n is (11.1) Definition If P n , the set of sequences of length n and type P is called the type class of P , denoted T ( P ): (11.2) The type class is sometimes called the composition class of P . Example 11.1.1 Let χ = {1, 2, 3}, a ternary alphabet. Let x = 11321. Then the type P x is (11.3) The type class of P x is the set of all sequences of length 5 with three 1’s, one 2, and one 3. There are 20 such sequences, and (11.4) The number of elements in T (P) is (11.5) The essential power of the method of types arises from the following theorem, which shows that the number of types is at most polynomial in n . Theorem 11.1.1 (11.6) Proof: There are |χ| components in the vector that specifies P x . The numerator in each component can take on only n + 1 values. So there are at most ( n + 1) |χ| choices for the type vector. Of course, these choices are not independent (e.g., the last choice is fixed by the others). But this is a sufficiently good upper bound for our needs. The crucial point here is that there are only a polynomial number of types of length n . Since the number of sequences is exponential in n , it follows that at least one type has exponentially many sequences in its type class. In fact, the largest type class has essentially the same number of elements as the entire set of sequences, to first order in the exponent. Now, we assume that the sequence X 1 , X 2 ,…, X n , is drawn i.i.d. according to a distribution Q(x) . All sequences with the same type have the same probability, as shown in the following theorem. Let Q n ( x n ) = denote the product distribution associated with Q . Theorem 11.1.2 If X 1 , X 2 ,…, X n are drawn i.i.d. according to Q(x) , the probability of x depends only on its type and is given by (11.7) Proof (11.8) (11.9) (11.10) (11.11) (11.12) (11.13) (11.14) Corollary If x is in the type class of Q, then (11.15) Proof: If x T (Q) , then P x = Q , which can be substituted into (11.14) . Example 11.1.2 The probability that a fair die produces a particular sequence of length n with precisely n /6 occurrences of each face ( n is a multiple of 6) is . This is obvious. However, if the die has a probability mass function , the probability of observing a particular sequence with precisely these frequencies is precisely for n a multiple of 12. This is more interesting. We now give an estimate of the size of a type class T (P) . Theorem 11.1.3 (Size of a type class T ( P )) For any type P n , (11.16) Proof: The exact size of T (P) is easy to calculate. It is a simple combinatorial problem—the number of ways of arranging n P ( a 1 ), n P ( a 2 ),…, nP ( a | χ |) objects in a sequence, which is (11.17) This value is hard to manipulate, so we derive simple exponential bounds on its value. We suggest two alternative proofs for the exponential bounds. The first proof uses Stirling’s formula [208] to bound the factorial function, and after some algebra, we can obtain the bounds of the theorem. We give an alternative proof. We first prove the upper bound. Since a type class must have probability ≤ 1, we have (11.18) (11.19) (11.20) (11.21) using Theorem 11.1.2. Thus, (11.22) Now for the lower bound. We first prove that the type class T(P) has the highest probability among all type classes under the probability distribution P : (11.23) We lower bound the ratio of probabilities, (11.24) (11.25) (11.26) Now using the simple bound (easy to prove by separately considering the cases m ≥ n and m < n ) (11.27) we obtain (11.28) (11.29) (11.30) (11.31) (11.32) Hence, P n ( T ( P )) ≥ P n ( T ( )). The lower bound now follows easily from this result, since (11.33) (11.34) (11.35) (11.36) (11.37) (11.38) (11.39) where (11.36) follows from Theorem 11.1.1 and (11.38) follows from Theorem 11.1.2. We give a slightly better approximation for the binary case. Example 11.1.3 (Binary alphabet) In this case, the type is defined by the number of l’s in the sequence, and the size of the type class is therefore . We show that (11.40) These bounds can be proved using Stirling’s approximation for the factorial function (Lemma 17.5.1). But we provide a more intuitive proof below. We first prove the upper bound. From the binomial formula, for any p , (11.41) Since all the terms of the sum are positive for 0 ≤ p ≤ 1, each of the terms is less than 1. Setting p = k/n and taking the k th term, we get (11.42) (11.43) (11.44) (11.45) Hence, (11.46) For the lower bound, let S be a random variable with a binomial distribution with parameters n and p . The most likely value of S is S = . This can easily be verified from the fact that (11.47) and considering the cases when i < np and when i > np . Then, since there are n + 1 terms in the binomial sum, (11.48) (11.49) Now let p = k/n . Then we have (11.50) which by the arguments in (11.45) is equivalent to (11.51) or (11.52) Combining the two results, we see that (11.53) A more precise bound can be found in theorem 17.5.1 when k ≠ 0 or n . Theorem 11.1.4 ( Probability of type class) for any P n and any distribution Q, the probability of the type class T (P) under Q n is 2 −nD(P||Q) to first order in the exponent. More precisely , (11.54) Proof: We have (11.55) (11.56) (11.57) by Theorem 11.1.2. Using the bounds on | T ( P )| derived in Theorem 11.1.3, we have (11.58) We can summarize the basic theorems concerning types in four equations: (11.59) (11.60) (11.61) (11.62) These equations state that there are only a polynomial number of types and that there are an exponential number of sequences of each type. We also have an exact formula for the probability of any sequence of type P under distribution Q and an approximate formula for the probability of a type class. These equations allow us to calculate the behavior of long sequences based on the properties of the type of the sequence. For example, for long sequences drawn i.i.d. according to some distribution, the type of the sequence is close to the distribution generating the sequence, and we can use the properties of this distribution to estimate the properties of the sequence. Some of the applications that will be dealt with in the next few sections are as follows: The law of large numbers Universal source coding Sanov’s theorem The Chernoff-Stein lemma and hypothesis testing Conditional probability and limit theorems 11.2 LAW OF LARGE NUMBERS The concept of type and type classes enables us to give an alternative statement of the law of large numbers. In fact, it can be used as a proof of a version of the weak law in the discrete case. The most important property of types is that there are only a polynomial number of types, and an exponential number of sequences of each type. Since the probability of each type class depends exponentially on the relative entropy distance between the type P and the distribution Q , type classes that are far from the true distribution have exponentially smaller probability. Given an > 0, we can define a typical set T Q of sequences for the distribution Q n as (11.63) Then the probability that x n is not typical is (11.64) (11.65) (11.66) (11.67) (11.68) which goes to 0 as n → ∞. Hence, the probability of the typical set T Q goes to 1 as n → ∞. This is similar to the AEP proved in Chapter 3, which is a form of the weak law of large numbers. We now prove that the empirical distribution P X n converges to P . Theorem 11.2.1 Let X 1 , X 2 ,…, X n be i.i.d. ~ P (x). Then (11.69) and consequently, D(P x n ||P) → 0 with probability I . Proof: The inequality (11.69) was proved in (11.68) . Summing over n , we find that (11.70) Thus, the expected number of occurrences of the event ( D ( P x n || P ) > } for all n is finite, which implies that the actual number of such occurrences is also finite with probability 1 (Borel–Cantelli lemma). Hence D ( P x n || P ) → 0 with probability 1. We now define a stronger version of typicality than in Chapter 3. Definition We define the strongly typical set to be the set of sequences in χ n for which the sample frequencies are close to the true values: (11.71) Hence, the typical set consists of sequences whose type does not differ from the true probabilities by more than /|χ| in any component. By the strong law of large numbers, it follows that the probability of the strongly typical set goes to 1 as n → ∞. The additional power afforded by strong typicality is useful in proving stronger results, particularly in universal coding, rate distortion theory, and large deviation theory. 11.3 UNIVERSAL SOURCE CODING Huffman coding compresses an i.i.d. source with a known distribution p(x) to its entropy limit H(X) . However, if the code is designed for some incorrect distribution q(x) , a penalty of D(p||q) is incurred. Thus, Huffman coding is sensitive to the assumed distribution. What compression can be achieved if the true distribution p(x) is unknown? Is there a universal code of rate R , say, that suffices to describe every i.i.d. source with entropy H(X) < R? The surprising answer is yes. The idea is based on the method of types. There are 2 nH(P) sequences of type P . Since there are only a polynomial number of types with denominator n , an enumeration of all sequences x n with type P x n such that H ( P x n ) < R will require roughly nR bits. Thus, by describing all such sequences, we are prepared to describe any sequence that is likely to arise from any distribution Q having entropy H ( Q ) < R . We begin with a definition. Definition A fixed-rate block code of rate R for a source X 1 , X 2 ,…, X n which has an unknown distribution Q consists of two mappings: the encoder, (11.72) and the decoder, (11.73) Here R is called the rate of the code. The probability of error for the code with respect to the distribution Q is (11.74) Definition A rate R block code for a source will be called universal if the functions f n and ø n do not depend on the distribution Q and if as n → ∞ if R > H(Q) . We now describe one such universal encoding scheme, due to Csiszár and Körner [149], that is based on the fact that the number of sequences of type P increases exponentially with the entropy and the fact that there are only a polynomial number of types. Theorem 11.3.1 There exists a sequence of (2 nR , n ) universal source codes such that for every source Q such that H(Q) < R . Proof: Fix the rate R for the code. Let (11.75) Consider the set of sequences (11.76) Then (11.77) (11.78) (11.79) (11.80) (11.81) (11.82) By indexing the elements of A , we define the encoding function f n as (11.83) The decoding function maps each index onto the corresponding element of A . Hence all the elements of A are recovered correctly, and all the remaining sequences result in an error. The set of sequences that are recovered correctly is illustrated in Figure 11.2 . FIGURE 11.2. Universal code and the probability simplex. Each sequence with type that lies outside the circle is encoded by its index. There are fewer than 2 nR such sequences. Sequences with types within the circle are encoded by 0. We now show that this encoding scheme is universal. Assume that the distribution of X 1 , X 2 , X n is Q and H(Q) < R . Then the probability of decoding error is given by (11.84) (11.85) (11.86) (11.87) Since R n ↑ R and H(Q) < R , there exists n 0 such that for all n ≥ n 0 , R n > H(Q) . Then for n ≥ n 0 , min P:H(P)>R n D ( P ||Q) must be greater than 0, and the probability of error P (n) e converges to 0 exponentially fast as n → ∞. On the other hand, if the distribution Q is such that the entropy H(Q) is greater than the rate R , then with high probability the sequence will have a type outside the set A . Hence, in such cases the probability of error is close to 1. The exponent in the probability of error is (11.88) which is illustrated in Figure 11.3 . FIGURE 11.3. Error exponent for the universal code. The universal coding scheme described here is only one of many such schemes. It is universal over the set of i.i.d. distributions. There are other schemes, such as the Lempel–Ziv algorithm, which is a variable-rate universal code for all ergodic sources. The Lempel–Ziv algorithm, discussed in Section 13.4, is often used in practice to compress data that cannot be modeled simply, such as English text or computer source code. One may wonder why it is ever necessary to use Huffman codes, which are specific to a probability distribution. What do we lose in using a universal code? Universal codes need a longer block length to obtain the same performance as a code designed specifically for the probability distribution. We pay the penalty for this increase in block length by the increased complexity of the encoder and decoder. Hence, a distribution specific code is best if one knows the distribution of the source. 11.4 LARGE DEVIATION THEORY The subject of large deviation theory can be illustrated by an example. What is the probability that ∑ X i is near if X 1 , X 2 ,…, X n , are drawn i.i.d. Bernoulli( )? This is a small deviation (from the expected outcome) and the probability is near 1. Now what is the probability that is greater than given that X 1 , X 2 ,…, X n are Bernoulli( )? This is a large deviation, and the probability is exponentially small. We might estimate the exponent using the central limit theorem, but this is a poor approximation for more than a few standard deviations. We note that is equivalent to . Thus, the probability that n is near 3/4 is the probability that type Px is near . The probability of this large deviation will turn out to be . In this section we estimate the probability of a set of nontypical types. Let E be a subset of the set of probability mass functions. For example, E may be the set of probability mass functions with mean μ . With a slight abuse of notation, we write (11.89) If E contains a relative entropy neighborhood of Q , then by the weak law of large numbers (Theorem 11.2.1), Q n ( E ) → 1. On the other hand, if E does not contain Q or a neighborhood of Q , then by the weak law of large numbers, Q n ( E ) → 0 exponentially fast. We will use the method of types to calculate the exponent. Let us first give some examples of the kinds of sets E that we are considering. For example, assume that by observation we find that the sample average of g ( X ) is greater than or equal to α [i.e., ≥ α]. This event is equivalent to the event P X E ∩ n , where (11.90) because (11.91) (11.92) Thus, (11.93) Here E is a half space in the space of probability vectors, as illustrated in Figure 11.4 . FIGURE 11.4. Probability simplex and Sanov’s theorem. Theorem 11.4.1 ( Sanov’s theorem) Let X 1 , X 2 ,…, X n be i.i.d . ~ Q(x) . Let E ⊆ be a set of probability distributions. Then (11.94) where (11.95) is the distribution in E that is closest to Q in relative entropy . If in addition, the set E is the closure of its interior, then (11.96) Proof: We first prove the upper bound: (11.97) (11.98) (11.99) (11.100) (11.101) (11.102) (11.103) where the last inequality follows from Theorem 11.1.1. Note that P* need not be a member of n . We now come to the lower bound, for which we need a “nice” set E , so that for all large n , we can find a distribution in E ∩ n , that is close to P* . If we now assume that E is the closure of its interior (thus, the interior must be nonempty), then since ∪ n n is dense in the set of all distributions, it follows that E ∩ n is nonempty for all n ≥ n 0 for some n 0 . We can then find a sequence of distributions P n such that P n E ∩ n and D ( P n || Q ) → D ( P *|| Q ). For each n ≥ n 0 , (11.104) (11.105) (11.106) Consequently, (11.107) Combining this with the upper bound establishes the theorem. This argument can be extended to continuous distributions using quantization. 11.5 EXAMPLES OF SANOV’S THEOREM Suppose that we wish to find g j ( X i ) ≥ α j , j = 1, 2,…, k }. Then the set E is defined as (11.108) To find the closest distribution in E to Q , we minimize D ( P ||Q) subject to the constraints in (11.108) . Using Lagrange multipliers, we construct the functional (11.109) We then differentiate and calculate the closest distribution to Q to be of the form (11.110) where the constants λ i are chosen to satisfy the constraints. Note that if Q is uniform, P* is the maximum entropy distribution. Verification that P* is indeed the minimum follows from the same kinds of arguments as given in Chapter 12. Let us consider some specific examples: Example 11.5.1 (Dice) Suppose that we toss a fair die n times; what is the probability that the average of the throws is greater than or equal to 4? From Sanov’s theorem, it follows that (11.111) where P* minimizes D (P||Q) over all distributions P that satisfy (11.112) From (11.110) , it follows that P* has the form (11.113) with λ chosen so that ∑ i P*(i) = 4. Solving numerically, we obtain λ = 0.2519, P* = (0.1031, 0.1227, 0.1461, 0.1740, 0.2072, 0.2468), and therefore D ( P* || Q ) = 0.0624 bit. Thus, the probability that the average of 10000 throws is greater than or equal to 4 is ≈ 2 −624 . Example 11.5.2 ( Coins ) Suppose that we have a fair coin and want to estimate the probability of observing more than 700 heads in a series of 1000 tosses. The problem is like Example 11.5.1. The probability is (11.114) where P* is the (0.7, 0.3) distribution and Q is the (0.5, 0.5) distribution. In this case, D ( P*||Q ) = 1 − H(P*) = 1 – H (0.7) = 0.119. Thus, the probability of 700 or more heads in 1000 trials is approximately 2 −119 . Example 11.5.3 (Mutual dependence) Let Q ( x, y ) be a given joint distribution and let Q 0 ( x, y ) = Q(x)Q(y) be the associated product distribution formed from the marginals of Q . We wish to know the likelihood that a sample drawn according to Q 0 will “appear” to be jointly distributed according to Q . Accordingly, let ( X i , Y i ) be i.i.d. ~ Q 0 ( x, y ) = Q(x)Q(y) . We define joint typicality as we did in Section 7.6; that is, ( x n , y n ) is jointly typical with respect to a joint distribution Q(x, y) if the sample entropies are close to their true values: (11.115) (11.116) and (11.117) We wish to calculate the probability (under the product distribution) of seeing a pair ( x n , y n ) that looks jointly typical of Q [i.e., ( x n , y n ) satisfies (11.115) – (11.117) ]. Thus, ( x n , y n ) are jointly typical with respect to Q(x, y) if P x n , y n E ∩ n ( X , Y ) where (11.118) Using Sanov’s theorem, the probability is (11.119) where P* is the distribution satisfying the constraints that is closest to Q 0 in relative entropy. In this case, as → 0, it can be verified (Problem 11.10) that P* is the joint distribution Q , and Q 0 is the product distribution, so that the probability is 2 − n D (Q (x, y)||Q(x)Q(y)) = 2 − n I (X; Y) , which is the same as the result derived in Chapter 7 for the joint AEP. In the next section we consider the empirical distribution of the sequence of outcomes given that the type is in a particular set of distributions E . We will show that not only is the probability of the set E essentially determined by D ( P *||Q), the distance of the closest element of E to Q , but also that the conditional type is essentially P* , so that given that we are in set E , the type is very likely to be close to P* . 11.6 CONDITIONAL LIMIT THEOREM It has been shown that the probability of a set of types under a distribution Q is determined essentially by the probability of the closest element of the set to Q; the probability is 2 − nD* to first order in the exponent, where (11.120) This follows because the probability of the set of types is the sum of the probabilities of each type, which is bounded by the largest term times the number of terms. Since the number of terms is polynomial in the length of the sequences, the sum is equal to the largest term to first order in the exponent. We now strengthen the argument to show that not only is the probability of the set E essentially the same as the probability of the closest type P* but also that the total probability of other types that are far away from P* is negligible. This implies that with very high probability, the type observed is close to P* . We call this a conditional limit theorem . Before we prove this result, we prove a “Pythagorean” theorem, which gives some insight into the geometry of D ( P||Q ). Since D ( P||Q ) is not a metric, many of the intuitive properties of distance are not valid for D ( P||Q ). The next theorem shows a sense in which D ( P||Q ) behaves like the square of the Euclidean metric ( Figure 11.5 ). FIGURE 11.5. Pythagorean theorem for relative entropy. Theorem 11.6.1 For a closed convex set E ⊂ and distribution Q E, let P* E be the distribution that achieves the minimum distance to Q; that is , (11.121) Then (11.122) for all P E . Note . The main use of this theorem is as follows: Suppose that we have a sequence P n E that yields D ( P n || Q ) → D ( P*||Q ). Then from the Pythagorean theorem, D ( P n || P* ) 0 as well. Proof: Consider any P E . Let (11.123) Then P λ → P* as λ → 0. Also, since E is convex, P λ . E for 0 ≤ λ ≤ 1. Since D ( P*||Q ) is the minimum of D ( P λ || Q ) along the path P* → P , the derivative of D ( P λ || Q ) as a function of λ is nonnegative at λ = 0. Now (11.124) and (11.125) Setting λ = 0, so that P λ = P* and using the fact that ∑ P ( x ) = ∑ P* ( x ) = 1, we have (11.126) (11.127) (11.128) (11.129) (11.130) which proves the theorem. Note that the relative entropy D ( P || Q ) behaves like the square of the Euclidean distance. Suppose that we have a convex set E in R n . Let A be a point outside the set, B the point in the set closest to A , and C any other point in the set. Then the angle between the lines BA and BC must be obtuse, which implies that , which is of the same form as Theorem 11.6.1. This is illustrated in Figure 11.6 . FIGURE 11.6. Triangle inequality for distance squared. We now prove a useful lemma which shows that convergence in relative entropy implies convergence in the 1 norm. Definition The 1 distance between any two distributions is defined as (11.131) Let A be the set on which p 1 ( x ) > p 2 ( x ). Then (11.132) (11.133) (11.134) (11.135) (11.136) Also note that (11.137) The left-hand side of (11.137) is called the variational distance between p 1 and p 2 . Lemma 11.6.1 (11.138) Proof: We first prove it for the binary case. Consider two binary distributions with parameters p and q with p ≥ q . We will show that (11.139) The difference g ( p, q ) between the two sides is (11.140) Then (11.141) (11.142) (11.143) since q (1 − q ) ≤ 1/4 and q ≤ p . For q = p , g ( p, q ) = 0, and hence g ( p, q ) ≥ 0 for q ≤ p , which proves the lemma for the binary case. For the general case, for any two distributions p 1 and P 2 , let (11.144) Define a new binary random variable Y = ø ( X ), the indicator of the set A , and let 1 and 2 be the distributions of Y . Thus, 1 and 2 correspond to the quantized versions of p 1 and P 2 . Then by the data-processing inequality applied to relative entropies (which is proved in the same way as the data-processing inequality for mutual information), we have (11.145) (11.146) (11.147) by (11.137) , and the lemma is proved. We can now begin the proof of the conditional limit theorem. We first outline the method used. As stated at the beginning of the chapter, the essential idea is that the probability of a type under Q depends exponentially on the distance of the type from Q , and hence types that are farther away are exponentially less likely to occur. We divide the set of types in E into two categories: those at about the same distance from Q as P* and those a distance 2δ farther away. The second set has exponentially less probability than the first, and hence the first set has a conditional probability tending to 1. We then use the Pythagorean theorem to establish that all the elements in the first set are close to P* , which will establish the theorem. The following theorem is an important strengthening of the maximum entropy principle. Theorem 11.6.2 ( Conditional limit theorem) Let E be a closed convex subset of and let Q be a distribution not in E. Let X 1 , X 2 ,…, X n be discrete random variables drawn i.i.d. ~ Q. Let P* achieve min p E D(P||Q). Then (11.148) in probability as n → ∞, i.e., the conditional distribution of X 1 , given that the type of the sequence is in E, is close to P* for large n . Example 11.6.1 If X i ~ Q , then (11.149) where P* (a) minimizes D ( P ||Q) over P satisfying ∑ P (a)a 2 ≥ α. This minimization results in (11.150) where λ is chosen to satisfy ∑ P* (a)a 2 = α. Thus, the conditional distribution on X 1 given a constraint on the sum of the squares is a (normalized) product of the original probability mass function and the maximum entropy probability mass function (which in this case is Gaussian). Proof of Theorem: Define the sets (11.151) The set S t is convex since D ( P ||Q) is a convex function of P . Let (11.152) Then P* is unique, since D ( P ||Q) is strictly convex in P . Now define the set (11.153) and (11.154) Thus, A ∪ B = E . These sets are illustrated in Figure 11.7 . Then FIGURE 11.7. Conditional limit theorem. (11.155) (11.156) (11.157) (11.158) since there are only a polynomial number of types. On the other hand, (11.159) (11.160) (11.161) (11.162) since the sum is greater than one of the terms, and for sufficiently large n , there exists at least one type in S D*+δ ∩ E ∩ n . Then, for n sufficiently large, (11.163) (11.164) (11.165) (11.166) which goes to 0 as n → ∞. Hence the conditional probability of B goes to 0 as n → ∞, which implies that the conditional probability of A goes to 1. We now show that all the members of A are close to P* in relative entropy. For all members of A , (11.167) Hence by the “Pythagorean” theorem (Theorem 11.6.1), (11.168) which in turn implies that (11.169) since D ( P *||Q) = D* . Thus, P x A implies that D ( P x ||Q) ≤ D* + 2δ, and therefore that D ( P x ||P*) ≤ 2δ. Consequently, since Pr{ P X n A | P X n E } → 1, it follows that (11.170) as n → ∞. By Lemma 11.6.1, the fact that the relative entropy is small implies that the 1 distance is small, which in turn implies that max a χ | P X n ( a ) − P* ( a )| is small. Thus, Pr(| P X n ( a ) − P* ( a )|≥ | P X n E ) → 0 as n → ∞. Alternatively, this can be written as (11.171) In this theorem we have only proved that the marginal distribution goes to P* as n → ∞. Using a similar argument, we can prove a stronger version of this theorem: (11.172) This holds for fixed m as n → ∞. The result is not true for m = n , since there are end effects; given that the type of the sequence is in E , the last elements of the sequence can be determined from the remaining elements, and the elements are no longer independent. The conditional limit theorem states that the first few elements are asymptotically independent with common distribution P* . Example 11.6.2 As an example of the conditional limit theorem, let us consider the case when n fair dice are rolled. Suppose that the sum of the outcomes exceeds 4 n . Then by the conditional limit theorem, the probability that the first die shows a number a {1, 2,…, 6} is approximately P* ( a ), where P*(a) is the distribution in E that is closest to the uniform distribution, where E = { P : ∑ P ( a)a ≥ 4}. This is the maximum entropy distribution given by (11.173) with λ chosen so that ∑ iP*(i) = 4 (see Chapter 12). Here P* is the conditional distribution on the first (or any other) die. Apparently, the first few dice inspected will behave as if they are drawn independently according to an exponential distribution. 11.7 HYPOTHESIS TESTING One of the standard problems in statistics is to decide between two alternative explanations for the data observed. For example, in medical testing, one may wish to test whether or not a new drug is effective. Similarly, a sequence of coin tosses may reveal whether or not the coin is biased. These problems are examples of the general hypothesis-testing problem. In the simplest case, we have to decide between two i.i.d. distributions. The general problem can be stated as follows: Problem 11.7.1 Let X 1 , X 2 ,…, X n , be i.i.d. ~ Q(x) . We consider two hypotheses: H 1 : Q = p 1 . H 2 : Q = p 2 . Consider the general decision function g ( x 1 , x 2 ,…, x n ), where g ( x 1 , x 2 ,…, x n ) = 1 means that H 1 is accepted and g ( x 1 , x 2 ,…, x n ) = 2 means that H 2 is accepted. Since the function takes on only two values, the test can also be specified by specifying the set A over which g ( x 1 , x 2 ,…, x n ) is 1; the complement of this set is the set where g ( x 1 , x 2 ,…, x n ) has the value 2. We define the two probabilities of error: (11.174) and (11.175) In general, we wish to minimize both probabilities, but there is a trade-off. Thus, we minimize one of the probabilities of error subject to a constraint on the other probability of error. The best achievable error exponent in the probability of error for this problem is given by the Chernoff–Stein lemma. We first prove the Neyman–Pearson lemma, which derives the form of the optimum test between two hypotheses. We derive the result for discrete distributions; the same results can be derived for continuous distributions as well. Theorem 11.7.1 ( Neyman–Pearson lemma) Let X 1 , X 2 ,…, X n be drawn i.i.d. according to probability mass function Q. Consider the decision problem corresponding to hypotheses Q = P 1 vs. Q = P 2 . For T ≥ 0, define a region (11.176) Let (11.177) be the corresponding probabilities of error corresponding to decision region A n . Let B n be any other decision region with associated probabilities of error α and β. If α ≤ α*, then β ≥ β*. Proof: Let A = A n ( T ) be the region defined in (11.176) and let B ⊆ χ n be any other acceptance region. Let ø A and ø B be the indicator functions of the decision regions A and B , respectively. Then for all x = ( x 1 , x 2 ,…, x n ) χ n , (11.178) This can be seen by considering separately the cases x A and x A . Multiplying out and summing this over the entire space, we obtain (11.179) (11.180) (11.181) (11.182) Since T ≥ 0, we have proved the theorem. The Neyman–Pearson lemma indicates that the optimum test for two hypotheses is of the form (11.183) This is the likelihood ratio test and the quantity is called the likelihood ratio . For example, in a test between two Gaussian distributions [i.e., between f 1 = (1, σ 2 ) and f 2 = (−1, σ 2 )], the likelihood ratio becomes (11.184) (11.185) (11.186) Hence, the likelihood ratio test consists of comparing the sample mean , with a threshold. If we want the two probabilities of error to be equal, we should set T = 1. This is illustrated in Figure 11.8 . FIGURE 11.8. Testing between two Gaussian distributions. In Theorem 11.7.1 we have shown that the optimum test is a likelihood ratio test. We can rewrite the log-likelihood ratio as (11.187) (11.188) (11.189) (11.190) (11.191) (11.192) the difference between the relative entropy distances of the sample type to each of the two distributions. Hence, the likelihood ratio test (11.193) is equivalent to (11.194) We can consider the test to be equivalent to specifying a region of the simplex of types that corresponds to choosing hypothesis H 1 . The optimum region is of the form (11.194) , for which the boundary of the region is the set of types for which the difference between the distances is a constant. This boundary is the analog of the perpendicular bisector in Euclidean geometry. The test is illustrated in Figure 11.9 . FIGURE 11.9. Likelihood ratio test on the probability simplex. We now offer some informal arguments based on Sanov’s theorem to show how to choose the threshold to obtain different probabilities of error. Let B denote the set on which hypothesis 1 is accepted. The probability of error of the first kind is (11.195) Since the set B c is convex, we can use Sanov’s theorem to show that the probability of error is determined essentially by the relative entropy of the closest member of B c to p 1 . Therefore, (11.196) where P * 1 is the closest element of B c to distribution p 1 . Similarly, (11.197) where P * 2 is the closest element in B to the distribution p 2 . Now minimizing D ( P || p 2 ) subject to the constraint D ( P || p 2 ) − D ( P || p 1 ) ≥ log T will yield the type in B that is closest to p 2 . Setting up the minimization of D ( P || p 2 ) subject to D ( P || p 2 ) − D ( P || p 1 ) = 1/ n log T using Lagrange multipliers, we have (11.198) Differentiating with respect to P(x) and setting to 0, we have (11.199) Solving this set of equations, we obtain the minimizing P of the form (11.200) where λ is chosen so that D ( P λ* || p 1 ) − D ( P λ* || p 2 ) = log T . From the symmetry of expression (11.200) , it is clear that P * 1 = P * 2 and that the probabilities of error behave exponentially with exponents given by the relative entropies D ( P *|| p 1 ) and D ( P *|| p 2 ). Also note from the equation that as λ → 1, P λ → p 1 and as λ → 0, P λ → p 2 . The curve that P λ. traces out as λ varies is a geodesic in the simplex. Here P λ is a normalized convex combination, where the combination is in the exponent ( Figure 11.9 ). In the next section we calculate the best error exponent when one of the two types of error goes to zero arbitrarily slowly (the Chernoff–Stein lemma). We will also minimize the weighted sum of the two probabilities of error and obtain the Chernoff information bound. 11.8 CHERNOFF–STEIN LEMMA We consider hypothesis testing in the case when one of the probabilities of error is held fixed and the other is made as small as possible. We will show that the other probability of error is exponentially small, with an exponential rate equal to the relative entropy between the two distributions. The method of proof uses a relative entropy version of the AEP. Theorem 11.8.1 (AEP for relative entropy) Let X 1 , X 2 ,…, X n be a sequence of random variables drawn i.i.d. according to p 1 (x) , and let p 2 (x) be any other distribution on χ Then (11.201) Proof: This follows directly from the weak law of large numbers. (11.202) (11.203) (11.204) (11.205) Just as for the regular AEP, we can define a relative entropy typical sequence as one for which the empirical relative entropy is close to its expected value. Definition For a fixed n and > 0, a sequence ( x 1 , x 2 ,…, x n ) χ n is said to be relative entropy typical if and only if (11.206) The set of relative entropy typical sequences is called the relative entropy typical set ( p 1 || p 2 ). As a consequence of the relative entropy AEP, we can show that the relative entropy typical set satisfies the following properties: Theorem 11.8.2 1. For ( x 1 , x 2 ,…, x n ) , (11.207) 2. , for n sufficiently large . 3. 4. , for n sufficiently large . Proof: The proof follows the same lines as the proof of Theorem 3.1.2, with the counting measure replaced by probability measure p 2 . The proof of property 1 follows directly from the definition of the relative entropy typical set. The second property follows from the AEP for relative entropy (Theorem 11.8.1). To prove the third property, we write (11.208) (11.209) (11.210) (11.211) (11.212) where the first inequality follows from property 1, and the second inequality follows from the fact that the probability of any set under p 1 is less than 1. To prove the lower bound on the probability of the relative entropy typical set, we use a parallel argument with a lower bound on the probability: (11.213) (11.214) (11.215) (11.216) (11.217) where the second inequality follows from the second property of ( p 1 || p 2 ). With the standard AEP in Chapter 3, we also showed that any set that has a high probability has a high intersection with the typical set, and therefore has about 2 n H elements. We now prove the corresponding result for relative entropy. Lemma 11.8.1 Let B n &⊂ χ n be any set of sequences x 1 , x 2 ,…, x n such that p 1 ( B n ) > 1 – . Let p 2 be any other distribution such that D ( p 1 || p 2 ) < ∞. Then p 2 ( B n ) > (1 – 2 )2 − n(D ( p 1 || p 2 )+ ) Proof: For simplicity, we will denote ( p 1 || p 2 ) by A n . Since p 1 ( B n ) > 1 – and P (A n ) > 1 – (Theorem 11.8.2), we have, by the union of events bound, , or equivalently, p 1 (A n ( A n ∩ B n ) > 1 – 2 . Thus, (11.218) (11.219) (11.220) (11.221) (11.222) (11.223) where the second inequality follows from the properties of the relative entropy typical sequences (Theorem 11.8.2) and the last inequality follows from the union bound above. We now consider the problem of testing two hypotheses, p 1 vs. p 2 . We hold one of the probabilities of error fixed and attempt to minimize the other probability of error. We show that the relative entropy is the best exponent in probability of error. Theorem 11.8.3 (Chernoff-Stein Lemma) Let X 1 , X 2 ,…, X n be i.i.d . ~ Q. Consider the hypothesis test between two alternatives, Q = P 1 and Q = P 2 , where D ( p 1 || p 2 ) < ∞. Let A n ⊆ χ n be an acceptance region for hypothesis H 1 . Let the probabilities of error be (11.224) and for 0 < , define (11.225) Then (11.226) Proof: We prove this theorem in two parts. In the first part we exhibit a sequence of sets A n for which the probability of error β n goes exponentially to zero as D ( p 1 || p 2 ). In the second part we show that no other sequence of sets can have a lower exponent in the probability of error. For the first part, we choose as the sets A n = ( p 1 || p 2 ). As proved in Theorem 11.8.2, this sequence of sets has for n large enough. Also, (11.227) from property 3 of Theorem 11.8.2. Thus, the relative entropy typical set satisfies the bounds of the lemma. To show that no other sequence of sets can do better, consider any sequence of sets B n , with p 1 ( B n ) > 1 – . By Lemma 11.8.1, we have p 2 ( B n ) > (1 − 2 ) 2 − n(D ( p 1 || p 2 + ) and therefore (11.228) Thus, no other sequence of sets has a probability of error exponent better than D ( p 1 || p 2 ). Thus, the set sequence A n = ( p 1 || p 2 ) is asymptotically optimal in terms of the exponent in the probability. Note that the relative entropy typical set, although asymptotically optimal (i.e., achieving the best asymptotic rate), is not the optimal set for any fixed hypothesis-testing problem. The optimal set that minimizes the probabilities of error is that given by the Neyman–Pearson lemma. 11.9 CHERNOFF INFORMATION We have considered the problem of hypothesis testing in the classical setting, in which we treat the two probabilities of error separately. In the derivation of the Chernoff–Stein lemma, we set α n ≤ and achieved β n , 2 − nD . But this approach lacks symmetry. Instead, we can follow a Bayesian approach, in which we assign prior probabilities to both hypotheses. In this case we wish to minimize the overall probability of error given by the weighted sum of the individual probabilities of error. The resulting error exponent is the Chernoff information . The setup is as follows: X 1 , X 2 ,…, X n i.i.d. ~ Q . We have two hypotheses: Q = p 1 with prior probability π 1 and Q = p 2 with prior probability 7T2. The overall probability of error is (11.229) Let (11.230) Theorem 11.9.1 ( Chernoff ) The best achievable exponent in the Bayesian probability of error is D*, where (11.231) with (11.232) and λ* the value of A such that (11.233) Proof: The basic details of the proof were given in Section 11.7. We have shown that the optimum test is a likelihood ratio test, which can be considered to be of the form (11.234) The test divides the probability simplex into regions corresponding to hypothesis 1 and hypothesis 2, respectively. This is illustrated in Figure 11.10 . FIGURE 11.10. Probability simplex and Chernoff information. Let A be the set of types associated with hypothesis 1. From the discussion preceding (11.200) , it follows that the closest point in the set Ac to p 1 is on the boundary of A and is of the form given by (11.232) . Then from the discussion in Section 11.8, it is clear that P λ, is the distribution in A that is closest to p 2 ; it is also the distribution in A c that is closest to p 1 . By Sanov’s theorem, we can calculate the associated probabilities of error, (11.235) and (11.236) In the Bayesian case, the overall probability of error is the weighted sum of the two probabilities of error, (11.237) since the exponential rate is determined by the worst exponent. Since D ( P λ || p 1 ) decreases with λ and D ( P λ || p 2 ) increases with λ, the maximum value of the minimum of D ( P λ || p 1 ), D ( P λ || p 2 ) is attained when they are equal. This is illustrated in Figure 11.11 . Hence, we choose λ so that FIGURE 11.11. Relative entropy D ( P λ || p 1 ) and D ( P λ || p 2 ) as a function of λ. (11.238) Thus, C ( p 1 , p 2 ) is the highest achievable exponent for the probability of error and is called the Chernoff information. The definition D * = D ( P λ || p 1 ) = D ( P λ || p 2 ) is equivalent to the standard definition of Chernoff information, (11.239) It is left as an exercise to the reader to show the equivalence of (11.231) and (11.239) . We outline briefly the usual derivation of the Chernoff information bound. The maximum a posteriori probability decision rule minimizes the Bayesian probability of error. The decision region A for hypothesis Hi for the maximum a posteriori rule is (11.240) the set of outcomes where the a posteriori probability of hypothesis H 1 is greater than the a posteriori probability of hypothesis H 2 . The probability of error for this rule is (11.241) (11.242) (11.243) Now for any two positive numbers a and b , we have (11.244) Using this to continue the chain, we have (11.245) (11.246) (11.247) For a sequence of i.i.d. observations, , and (11.248) (11.249) (11.250) (11.251) where (11.250) follows since π 1 ≤ 1, π 2 ≤ 1. Hence, we have (11.252) Since this is true for all λ, we can take the minimum over 0 ≤ λ ≤ 1, resulting in the Chernoff information bound. This proves that the exponent is no better than C(Pi, P2). Achievability follows from Theorem 11.9.1. Note that the Bayesian error exponent does not depend on the actual value of π 1 and π 2 , as long as they are nonzero. Essentially, the effect of the prior is washed out for large sample sizes. The optimum decision rule is to choose the hypothesis with the maximum a posteriori probability, which corresponds to the test (11.253) Taking the log and dividing by n , this test can be rewritten as (11.254) where the second term tends to D ( p 1 || p 2 ) or − D ( p 2 || p 1 ) accordingly as p 1 or p 2 is the true distribution. The first term tends to 0, and the effect of the prior distribution washes out. Finally, to round off our discussion of large deviation theory and hypothesis testing, we consider an example of the conditional limit theorem. Example 11.9.1 Suppose that major league baseball players have a batting average of 260 with a standard deviation of 15 and suppose that minor league ballplayers have a batting average of 240 with a standard deviation of 15. A group of 100 ballplayers from one of the leagues (the league is chosen at random) are found to have a group batting average greater than 250 and are therefore judged to be major leaguers. We are now told that we are mistaken; these players are minor leaguers. What can we say about the distribution of batting averages among these 100 players? The conditional limit theorem can be used to show that the distribution of batting averages among these players will have a mean of 250 and a standard deviation of 15. To see this, we abstract the problem as follows. Let us consider an example of testing between two Gaussian distributions, f 1 = (1, σ 2 ) and f 2 = (−1, σ −2 ), with different means and the same variance. As discussed in Section 11.8, the likelihood ratio test in this case is equivalent to comparing the sample mean with a threshold. The Bayes test is “Accept the hypothesis f = f 1 if .” Now assume that we make an error of the first kind (we say that f = f 1 when indeed f = f 2 ) in this test. What is the conditional distribution of the samples given that we have made an error? We might guess at various possibilities: The sample will look like a mix of the two normal distributions. Plausible as this is, it is incorrect. X i ≈ 0 for all i . This is quite clearly very unlikely, although it is conditionally likely that , is close to 0. The correct answer is given by the conditional limit theorem. If the true distribution is f 2 and the sample type is in the set A , the conditional distribution is close to f *, the distribution in A that is closest to f 2 . By symmetry, this corresponds to λ = in (11.232) . Calculating the distribution, we get (11.255) (11.256) (11.257) (11.258) It is interesting to note that the conditional distribution is normal with mean 0 and with the same variance as the original distributions. This is strange but true; if we mistake a normal population for another, the “shape” of this population still looks normal with the same variance and a different mean. Apparently, this rare event does not result from bizarre-looking data. Example 11.9.2 ( Large deviation theory and football ) Consider a very simple version of football in which the score is directly related to the number of yards gained. Assume that the coach has a choice between two strategies: running or passing. Associated with each strategy is a distribution on the number of yards gained. For example, in general, running results in a gain of a few yards with very high probability, whereas passing results in huge gains with low probability. Examples of the distributions are illustrated in Figure 11.12 . FIGURE 11.12. Distribution of yards gained in a run or a pass play. At the beginning of the game, the coach uses the strategy that promises the greatest expected gain. Now assume that we are in the closing minutes of the game and one of the teams is leading by a large margin. (Let us ignore first downs and adaptable defenses.) So the trailing team will win only if it is very lucky. If luck is required to win, we might as well assume that we will be lucky and play accordingly. What is the appropriate strategy? Assume that the team has only n plays left and it must gain l yards, where l is much larger than n times the expected gain under each play. The probability that the team succeeds in achieving l yards is exponentially small; hence, we can use the large deviation results and Sanov’s theorem to calculate the probability of this event. To be precise, we wish to calculate the probability that , where Z i are independent random variables and Z i has a distribution corresponding to the strategy chosen. The situation is illustrated in Figure 11.13 . Let E be the set of types corresponding to the constraint, FIGURE 11.13. Probability simplex for a football game. (11.259) If p 1 is the distribution corresponding to passing all the time, the probability of winning is the probability that the sample type is in E , which by Sanov’s theorem is , where P * 1 is the distribution in E that is closest to p 1 . Similarly, if the coach uses the running game all the time, the probability of winning is . What if he uses a mixture of strategies? Is it possible that , the probability of winning with a mixed strategy, P λ = λ p 1 + (1 − λ) p 2 , is better than the probability of winning with either pure passing or pure running? The somewhat surprising answer is yes, as can be shown by example. This provides a reason to use a mixed strategy other than the fact that it confuses the defense. We end this section with another inequality due to Chernoff, which is a special version of Markov’s inequality. This inequality is called the Chernoff bound . Lemma 11.9.1 Let Y be any random variable and let ψ (s) be the moment generating function of Y , (11.260) Then for all s ≥ 0, (11.261) and thus (11.262) Proof: Apply Markov’s inequality to the nonnegative random variable e sY . 11.10 FISHER INFORMATION AND THE CRAMÉR-RAO INEQUALITY A standard problem in statistical estimation is to determine the parameters of a distribution from a sample of data drawn from that distribution. For example, let X 1 , X 2 ,…, X n be drawn i.i.d. ~ (θ, 1). Suppose that we wish to estimate θ from a sample of size n . There are a number of functions of the data that we can use to estimate θ . For example, we can use the first sample X 1 . Although the expected value of X 1 is θ , it is clear that we can do better by using more of the data. We guess that the best estimate of θ is the sample mean . Indeed, it can be shown that , is the minimum mean-squared-error unbiased estimator. We begin with a few definitions. Let { f (x ; θ)}, θ Θ, denote an indexed family of densities, f (x, θ ) ≥ 0, f f (x, θ) dx = 1 for all θ Θ. Here Θ is called the parameter set . Definition An estimator for θ for sample size n is a function T : . An estimator is meant to approximate the value of the parameter. It is therefore desirable to have some idea of the goodness of the approximation. We will call the difference T − θ the error of the estimator. The error is a random variable. Definition The bias of an estimator T ( X 1 , X 2 ,…, X n ) for the parameter θ is the expected value of the error of the estimator [i.e., the bias is E θ T ( x 1 , x 2 , …., x n ) − θ ]. The subscript θ means that the expectation is with respect to the density f (·; θ ). The estimator is said to be unbiased if the bias is zero for all θ Θ (i.e., the expected value of the estimator is equal to the parameter). Example 11.10.1 Let X 1 , X 2 ,…, X n drawn i.i.d. ~ f (x) = (1/λ) x −x/λ , x ≥ 0 be a sequence of exponentially distributed random variables. Estimators of λ include X 1 and n . Both estimators are unbiased. The bias is the expected value of the error, and the fact that it is zero does not guarantee that the error is low with high probability. We need to look at some loss function of the error; the most commonly chosen loss function is the expected square of the error. A good estimator should have a low expected squared error and should have an error that approaches 0 as the sample size goes to infinity. This motivates the following definition: Definition An estimator T (X 1 , X 2 ,…, X n ) for θ is said to be consistent in probability if T(X 1 , X 2 ,…, X n ) → θ in probability as n → ∞. Consistency is a desirable asymptotic property, but we are interested in the behavior for small sample sizes as well. We can then rank estimators on the basis of their mean-squared error. Definition An estimator T 1 ( X 1 , X 2 ,…, X n ) is said to dominate another estimator T 2 ( X 1 , X 2 ,…, X n ) if, for all θ , (11.263) This raises a natural question: Is there a best estimator of θ that dominates every other estimator? To answer this question, we derive the Cramér–Rao lower bound on the mean-squared error of any estimator. We first define the score function of the distribution f (x , θ ). We then use the Cauchy–Schwarz inequality to prove the Cramér–Rao lower bound on the variance of all unbiased estimators. Definition The score V is a random variable defined by (11.264) where X ~ f (x; θ ). The mean value of the score is (11.265) (11.266) (11.267) (11.268) (11.269) and therefore EV 2 = var( V ). The variance of the score has a special significance. Definition The Fisher information J(θ) is the variance of the score: (11.270) If we consider a sample of n random variables X 1 , X 2 ,…, X n , drawn i.i.d. ~ f (x; θ ), we have (11.271) and the score function is the sum of the individual score functions, (11.272) (11.273) (11.274) where the V(X i ) are independent, identically distributed with zero mean. Hence, the n -sample Fisher information is (11.275) (11.276) (11.277) (11.278) (11.279) Consequently, the Fisher information for n i.i.d. samples is n times the individual Fisher information. The significance of the Fisher information is shown in the following theorem. Theorem 11.10.1 (Cramér–Rao inequality) The mean-squared error of any unbiased estimator T (X) of the parameter θ is lower bounded by the reciprocal of the Fisher information: (11.280) Proof: Let V be the score function and T be the estimator. By the Cauchy–Schwarz inequality, we have (11.281) Since T is unbiased, E θ T = θ for all θ . By (11.269) , E θ V = 0 and hence E θ (V − E θ V)(T − E θ T) = E θ (VT ). Also, by definition, var( V ) = J(θ) . Substituting these conditions in (11.281) , we have (11.282) Now, (11.283) (11.284) (11.285) (11.286) (11.287) (11.288) where the interchange of differentiation and integration in (11.285) can be justified using the bounded convergence theorem for appropriately well behaved f (x ; θ), and (11.287) follows from the fact that the estimator T is unbiased. Substituting this in (11.282) , we obtain (11.289) which is the Cramér–Rao inequality for unbiased estimators. By essentially the same arguments, we can show that for any estimator (11.290) where b T (θ) = E θ T − θ and b ′ T (θ) is the derivative of b T (θ) with respect to θ. The proof of this is left as a problem at the end of the chapter. Example 11.10.2 Let X 1 , X 2 ,…, X n be i.i.d. ~ (θ, σ 2 ), σ 2 known. Here J(θ) = n/σ −2 . Let T (X 1 , X 2 ,…, X n ) = . Then E θ ( n − θ) 2 = σ 2 / n = 1/ J(θ) . Thus, n is the minimum variance unbiased estimator of θ , since it achieves the Cramér–Rao lower bound. The Cramér–Rao inequality gives us a lower bound on the variance for all unbiased estimators. When this bound is achieved, we call the estimator efficient. Definition An unbiased estimator T is said to be efficient if it meets the Cramér–Rao bound with equality [i.e., if var( T ) = ]. The Fisher information is therefore a measure of the amount of “information” about θ that is present in the data. It gives a lower bound on the error in estimating θ from the data. However, it is possible that there does not exist an estimator meeting this lower bound. We can generalize the concept of Fisher information to the multiparameter case, in which case we define the Fisher information matrix J(θ) with elements (11.291) The Cramér-Rao inequality becomes the matrix inequality (11.292) where ∑ is the covariance matrix of a set of unbiased estimators for the parameters θ and ∑ ≥ J −1 (θ) in the sense that the difference ∑ − J −1 is a nonnegative definite matrix. We will not go into the details of the proof for multiple parameters; the basic ideas are similar. Is there a relationship between the Fisher information J (θ) and quantities such as entropy defined earlier? Note that Fisher information is defined with respect to a family of parametric distributions, unlike entropy, which is defined for all distributions. But we can parametrize any distribution f (x) by a location parameter θ and define Fisher information with respect to the family of densities f (x − θ) under translation. We explore the relationship in greater detail in Section 17.8, where we show that while entropy is related to the volume of the typical set, the Fisher information is related to the surface area of the typical set. Further relationships of Fisher information to relative entropy are developed in the problems. SUMMARY Basic identities (11.293) (11.294) (11.295) (11.296) Universal data compression (11.297) where (11.298) Large deviations (Sanov’s theorem) (11.299) (11.300) If E is the closure of its interior, then (11.301) 1 bound on relative entropy (11.302) Pythagorean theorem. If E is a convex set of types, distribution Q E , and P* achieves D ( P *||Q) = min P E D ( P ||Q), we have (11.303) for all P E . Conditional limit theorem. If X 1 , X 2 ,…, X n i.i.d. ~ Q , then (11.304) where P* minimizes D ( P ||Q) over P E . In particular, (11.305) Neyman-Pearson lemma. The optimum test between two densities p 1 and p 2 has a decision region of the form “accept P = p 1 if > T .” Chernoff-Stein lemma. The best achievable error exponent if α n ≤ : (11.306) (11.307) Chernoff information. The best achievable exponent for a Bayesian probability of error is (11.308) where (11.309) with λ = λ* chosen so that (11.310) Fisher information (11.311) Cramér-Rao inequality. For any unbiased estimator T of θ , (11.312) PROBLEMS 11.1 Chernoff-Stein lemma . Consider the two-hypothesis test Find D(f 1 || f 2 ) if (a) f i (x) = N(0, ), i = 1, 2. (b) f i (x) = λ i e −λ ix x, x ≥ 0, i = 1, 2. (c) f 1 (x) is the uniform density over the interval [0, 1] and f 2 ( x ) is the uniform density over [ a, a + 1]. Assume that 0 < a < 1. (d) f 1 corresponds to a fair coin and f 2 corresponds to a two-headed coin. 11.2 Relation between D(P || Q) and chi-square . Show that the χ 2 statistic is (twice) the first term in the Taylor series expansion of D ( P || Q ) about Q . Thus, D ( P || Q) = χ 2 + ···. [ Suggestion: Write and expand the log.] 11.3 Error exponent for universal codes . A universal source code of rate R achieves a probability of error , where Q is the true distribution and P* achieves min D ( P || Q ) over all P such that H(P) ≥ R . (a) Find P* in terms of Q and R . (b) Now let X be binary. Find the region of source probabilities Q(x), x {0, 1}, for which rate R is sufficient for the universal source code to achieve . 11.4 Sequential projection . We wish to show that projecting Q onto p 1 and then projecting the projection onto p 1 p 2 is the same as projecting Q directly onto p 1 p 2 . Let 1 be the set of probability mass functions on χ satisfying (11.313) (11.314) Let 2 be the set of probability mass functions on χ satisfying (11.315) (11.316) Suppose that . Let P* minimize D ( P || Q ) over all P 1 . Let R* minimize D(R || Q) over all . Argue that R* minimizes D(R || P*) over all R . 11.5 Counting . Let χ = {1, 2, … m }. Show that the number of sequences x n χ n satisfying is approximately equal to 2 n H* , to first order in the exponent, for n sufficiently large, where (11.317) 11.6 Biased estimates may be better . Consider the problem of estimating μ, and σ 2 from n samples of data drawn i.i.d. from a (μ, σ 2 ) distribution. (a) Show that n is an unbiased estimator of μ . (b) Show that the estimator (11.318) is a biased estimator of σ 2 and the estimator (11.319) is unbiased. (c) Show that S 2 n has a lower mean-squared error than that of . This illustrates the idea that a biased estimator may be “better” than an unbiased estimator. 11.7 Fisher information and relative entropy . Show for a parametric family { p θ ( x )}, that (11.320) 11.8 Examples of Fisher information . The Fisher information J (Θ) for the family f θ ( x ), θ R is defined by Find the Fisher information for the following families: (a) f θ ( x ) = N (0, θ ) = (b) f θ ( x ) = θ e −θ x , x ≥ 0 (c) What is the Cramèr–Rao lower bound on , where is an unbiased estimator of θ for parts (a) and (b)? 11.9 Two conditionally independent looks double the Fisher information . Let g θ ( x 1 , x 2 ) = f θ ( x 1 ) f θ ( x 2 ). Show that J g (θ) = 2 J f (θ) . 11.10 Joint distributions and product distributions . Consider a joint distribution Q(x, y) with marginals Q(x) and Q(y) . Let E be the set of types that look jointly typical with respect to Q : (11.321) (a) Let Q 0 (x, y) be another distribution on χ × . Argue that the distribution P* in E that is closest to Q 0 is of the form (11.322) where λ 0 , λ 1 , λ 2 , and λ 3 are chosen to satisfy the constraints. Argue that this distribution is unique. (b) Now let Q 0 (x, y) = Q(x)Q(y) . Verify that Q(x, y) is of the form (11.322) and satisfies the constraints. Thus, P* (x, y) = Q (x, y) (i.e., the distribution in E closest to the product distribution is the joint distribution). 11.11 Cramér–Rao inequality with a bias term . Let X ~ (x, 0) and let T (X) be an estimator for θ . Let b T (θ) = E θ T – θ be the bias of the estimator. Show that (11.323) 11.12 Hypothesis testing . Let X 1 , X 2 , … X n be i.i.d. ~ p(x) . Consider the hypothesis test H 1 : p = p 1 vs. H 2 : p = p 2 Let and Find the error exponent for Pr{Decide H 2 |H 1 true} in the best hypothesis test of H 1 vs. H 2 subject to Pr{Decide H 1 | H 2 true) ≤ 1/2. 11.13 Sanov’s theorem . Prove a simple version of Sanov’s theorem for Bernoulli( q ) random variables. Let the proportion of 1’s in the sequence X 1 , X 2 ,…, X n be (11.324) By the law of large numbers, we would expect n to be close to q for large n . Sanov’s theorem deals with the probability that p X n is far away from q . In particular, for concreteness, if we take p > q > , Sanov’s theorem states that (11.325) Justify the following steps: (11.326) Argue that the term corresponding to is the largest term in the sum on the right-hand side of the last equation. Show that this term is approximately 2 − nD . Prove an upper bound on the probability in Sanov’s theorem using the steps above. Use similar arguments to prove a lower bound and complete the proof of Sanov’s theorem. 11.14 Sanov . Let X i be i.i.d. ~ N (0, σ 2 ). (a) Find the exponent in the behavior of . This can be done from first principles (since the normal distribution is nice) or by using Sanov’s theorem. (b) What do the data look like if ? That is, what is the P* that minimizes D ( P || Q)? 11.15 Counting states . Suppose that an atom is equally likely to be in each of six states, X { S 1 , S 2 , S 3 ,…, S 6 }. One observes n atoms X 1 , X 2 ,…, X n independently drawn according to this uniform distribution. It is observed that the frequency of occurrence of state s 1 is twice the frequency of occurrence of state s 2 . (a) To first order in the exponent, what is the probability of observing this event? (b) Assuming n large, find the conditional distribution of the state of the first atom X 1 , given this observation. 11.16 Hypothesis testing . Let { X 1 } be i.i.d. ~ p(x) , x {1, 2, …}. Consider two hypotheses, H 0 : p (x) = p0 (x) vs. H 1 : p(x) = p 1 ( x ), where p0(x) = ( ) x and p 1 ( x ) = qp x−1 , x = 1, 2, 3, …. (a) Find D(p0 || p 1 ). (b) Let Pr{ H 0 } = . Find the minimal probability of error test for H 0 vs. H 1 given data X 1 , X 2 ,…, X n ~ p(x) . 11.17 Maximum likelihood estimation . Let {f θ (x) } denote a parametric family of densities with parameter . Let X 1 , X 2 ,…, X n be i.i.d. ~ f θ (x) . The function is known as the log likelihood function . Let 90 denote the true parameter value. (a) Let the expected log likelihood be and show that (b) Show that the maximum over θ of the expected log likelihood is achieved by θ = θ 0 . 11.18 Large deviations . Let X 1 , X 2 , … be i.i.d. random variables drawn according to the geometric distribution Find good estimates (to first order in the exponent) of: (a) . (b) . (c) Evaluate parts (a) and (b) for p = , α = 4. 11.19 Another expression for Fisher information . Use integration by parts to show that 11.20 Stirling’s approximation . Derive a weak form of Stirling’s approximation for factorials; that is, show that (11.327) using the approximation of integrals by sums. Justify the following steps: (11.328) and (11.329) 11.21 Asymptotic value of . Use the simple approximation of Problem 11.20 to show that if 0 ≤ p ≤ 1, and (i.e., k is the largest integer less than or equal to np ), then (11.330) Now let p i , i = 1,…, m be a probability distribution on m symbols (i.e., p i ≥ 0 and . What is the limiting value of (11.331) 11.22 Running difference . Let X 1 , X 2 ,…, X n be i.i.d. ~ Q 1 (x) , and Y 1 , Y 2 , … Y n be i.i.d. ~ Q 2 ( y ). Let X n and Y n be independent. Find an expression for good to first order in the exponent. Again, this answer can be left in parametric form. 11.23 Large likelihoods . Let X 1 , X 2 , … be i.i.d. ~ Q(x) , x {1, 2,…, m }. Let P (x) be some other probability mass function. We form the log likelihood ratio of the sequence X n and ask for the probability that it exceeds a certain threshold. Specifically, find (to first order in the exponent) There may be an undetermined parameter in the answer. 11.24. Fisher information for mixtures . Let f 1 (x) and f 0 (x) be two given probability densities. Let Z be Bernoulli(θ), where θ is unknown. Let X ~ f 1 (x) if Z = 1 and X ~ f 0 (x) if Z = 0. (a) Find the density f 0 (x) of the observed X . (b) Find the Fisher information J(θ) . (c) What is the Cramér-Rao lower bound on the mean-squared error of an unbiased estimate of θ ? (d) Can you exhibit an unbiased estimator of θ ? 11.25 Bent coins . Let ( X i } be iid ~ Q , where Thus, the X i ’s are iid ~ Binomial( m, q ). Show that as n → ∞, where P* is Binomial( m , λ) (i.e., P*(k) = for some λ [0, 1]). Find λ. 11.26 Conditional limiting distribution (a) Find the exact value of (11.332) if X 1 , X 2 ,…, are Bernoulli( ) and n is a multiple of 4. (b) Now let X i (-1, 0, 1) and let X 1 , X 2 … be i.i.d. uniform over (-1, 0, +1). Find the limit of (11.333) for n = 2 k , k → ∞. 11.27 Variational inequality . Verify for positive random variables X that (11.334) where E P (X) = ∑ xP(x) and D(Q|| P ) = and the supremum is over all Q(x) ≥ 0, ∑ Q(x) = 1. It is enough to extremize J(Q) = E Q In X − D(Q||P) + λ(∑ Q(x) -1). 11.28 Type constraints (a) Find constraints on the type P X n such that the sample variance , where and . (b) Find the exponent in the probability . You can leave the answer in parametric form. 11.29 Uniform distribution on the simplex . Which of these methods will generate a sample from the uniform distribution on the simplex ? (a) Let Y i be i.i.d. uniform [0, 1] with . (b) Let Y i be i.i.d. exponentially distributed ~ λe −λy , y ≥ 0, with . (c) (Break stick into n parts) Let Y 1 , Y 2 ,…, Y n−1 be i.i.d. uniform [0, 1], and let X i be the length of the i th interval. HISTORICAL NOTES The method of types evolved from notions of strong typicality; some of the ideas were used by Wolfowitz [566] to prove channel capacity theorems. The method was fully developed by Csiszár and Körner [149], who derived the main theorems of information theory from this viewpoint. The method of types described in Section 11.1 follows the development in Csiszár and Körner. The 1 lower bound on relative entropy is due to Csiszár [138], Kullback [336], and Kemperman [309]. Sanov’s theorem [455] was generalized by Csiszár [141] using the method of types.

Chapter 12: Maximum Entropy CHAPTER 12 MAXIMUM ENTROPY The temperature of a gas corresponds to the average kinetic energy of the molecules in the gas. What can we say about the distribution of velocities in the gas at a given temperature? We know from physics that this distribution is the maximum entropy distribution under the temperature constraint, otherwise known as the Maxwell–Boltzmann distribution. The maximum entropy distribution corresponds to the macrostate (as indexed by the empirical distribution) that has the most microstates (the individual gas velocities). Implicit in the use of maximum entropy methods in physics is a sort of AEP which says that all microstates are equally probable. 12.1 MAXIMUM ENTROPY DISTRIBUTIONS Consider the following problem: Maximize the entropy h ( f ) over all probability densities f satisfying (12.1) Thus, f is a density on support set S meeting certain moment constraints α 1 , α 2 ,…, α m . Approach 1 (Calculus) The differential entropy h ( f ) is a concave function over a convex set. We form the functional (12.2) and “differentiate” with respect to f ( x ), the x th component of f , to obtain (12.3) Setting this equal to zero, we obtain the form of the maximizing density (12.4) where λ 0 , λ 1 ,…, λ m , are chosen so that f satisfies the constraints. The approach using calculus only suggests the form of the density that maximizes the entropy. To prove that this is indeed the maximum, we can take the second variation. It is simpler to use the information inequality D ( g || f ) ≥ 0. Approach 2 ( Information inequality ) If g satisfies (12.1) and if f * is of the form (12.4) , then 0 ≤ D ( g || f *) = – h ( g ) + h ( f *). Thus h ( g ) ≤ h ( f *) for all g satisfying the constraints. We prove this in the following theorem. Theorem 12.1.1 ( Maximum entropy distribution ) Let f * ( x ) = f λ ( x ) = , where λ 0 ,…, λ m are chosen so that f * satisfies ( 12.1 ). Then f * uniquely maximizes h ( f ) over all probability densities f satisfying constraints (12.1) . Proof: Let g satisfy the constraints (12.1) . Then (12.5) (12.6) (12.7) (12.8) (12.9) (12.10) (12.11) (12.12) where (a) follows from the nonnegativity of relative entropy, (b) follows from the definition of f *, and (c) follows from the fact that both f * and g satisfy the constraints. Note that equality holds in (a) if and only if g ( x ) = f*( x ) for all x , except for a set of measure 0, thus proving uniqueness. The same approach holds for discrete entropies and for multivariate distributions. 12.2 EXAMPLES Example 12.2.1 ( One-dimensional gas with a temperature constraint ) Let the constraints be E X = 0 and E X 2 = σ 2 . Then the form of the maximizing distribution . is (12.13) To find the appropriate constants, we first recognize that this distribution has the same form as a normal distribution. Hence, the density that satisfies the constraints and also maximizes the entropy is the (0, σ 2 ) distribution: (12.14) Example 12.2.2 ( Dice, no constraints ) Let S = {1, 2, 3, 4, 5, 6}. The distribution that maximizes the entropy is the uniform distribution, p ( x ) = for x S . Example 12.2.3 ( Dice, with E X = ∑ ip i = α) This important example was used by Boltzmann. Suppose that n dice are thrown on the table and we are told that the total number of spots showing is n α. What proportion of the dice are showing face i , i = 1, 2,…, 6? One way of going about this is to count the number of ways that n dice can fall so that n i dice show face i . There are such ways. This is a macrostate indexed by ( n 1 , n 2 ,…, n 6 ) corresponding to microstates, each having probability . To find the most probable macrostate, we wish to maximize under the constraint observed on the total number of spots, (12.15) Using a crude Stirling’s approximation, , we find that (12.16) (12.17) (12.18) Thus, maximizing under the constraint (12.15) is almost equivalent to maximizing H ( p 1 , p 2 ,…, p 6 ) under the constraint ∑ ip i = α. Using Theorem 12.1.1 under this constraint, we find the maximum entropy probability mass function to be (12.19) where λ is chosen so that . Thus, the most probable macrostate is , and we expect to find dice showing face i . In Chapter 11 we show that the reasoning and the approximations are essentially correct. In fact, we show that not only is the maximum entropy macrostate the most likely, but it also contains almost all of the probability. Specifically, for rational α, (12.20) as n → ∞ along the subsequence such that nα is an integer. Example 12.2.4 Let S = [ a, b ], with no other constraints. Then the maximum entropy distribution is the uniform distribution over this range. Example 12.2.5 S = [0, ∞) and EX = μ. Then the entropy-maximizing distribution is (12.21) This problem has a physical interpretation. Consider the distribution of the height X of molecules in the atmosphere. The average potential energy of the molecules is fixed, and the gas tends to the distribution that has the maximum entropy subject to the constraint that E ( mg X ) is fixed. This is the exponential distribution with density f ( x ) = λ e −λ x , x ≥ 0. The density of the atmosphere does indeed have this distribution. Example 12.2.6 S = (−∞, ∞), and EX = μ. Here the maximum entropy is infinite, and there is no maximum entropy distribution. (Consider normal distributions with larger and larger variances.) Example 12.2.7 S = (−∞, ∞), EX = α 1 , and EX 2 = α 2 . The maximum entropy distribution is Example 12.2.8 S = R n , EX i X j = K ij , 1 ≤ i , j ≤ n . This is a multivariate example, but the same analysis holds and the maximum entropy density is of the form (12.22) Since the exponent is a quadratic form, it is clear by inspection that the density is a multivariate normal with zero mean. Since we have to satisfy the second moment constraints, we must have a multivariate normal with covariance K ij , and hence the density is (12.23) which has an entropy (12.24) as derived in Chapter 8. Example 12.2.9 Suppose that we have the same constraints as in Example 12.2.8, but EX i X j = K ij only for some restricted set of ( i , j ) A . For example, we might know only K ij for i = j ± 2. Then by comparing (12.22) and (12.23) , we can conclude that ( K −1 ) ij = 0 for ( i , j ) A c (i.e., the entries in the inverse of the covariance matrix are 0 when ( i , j ) is outside the constraint set). 12.3 ANOMALOUS MAXIMUM ENTROPY PROBLEM We have proved that the maximum entropy distribution subject to the constraints (12.25) is of the form (12.26) if λ 0 , λ 1 ,…, λ p satisfying the constraints (12.25) exist. We now consider a tricky problem in which the cannot be chosen to satisfy the constraints. Nonetheless, the “maximum” entropy can be found. We consider the following problem: Maximize the entropy subject to the constraints (12.27) (12.28) (12.29) (12.30) Here, the maximum entropy distribution, if it exists, must be of the form (12.31) But if λ 3 is nonzero, and the density cannot be normalized. So λ 3 must be 0. But then we have four equations and only three variables, so that in general it is not possible to choose the appropriate constants. The method seems to have failed in this case. The reason for the apparent failure is simple: The entropy has a least upper bound under these constraints, but it is not possible to attain it. Consider the corresponding problem with only first and second moment constraints. In this case, the results of Example 12.2.1 show that the entropy-maximizing distribution is the normal with the appropriate moments. With the additional third moment constraint, the maximum entropy cannot be higher. Is it possible to achieve this value? We cannot achieve it, but we can come arbitrarily close. Consider a normal distribution with a small “wiggle” at a very high value of x. The moments of the new distribution are almost the same as those of the old one, the biggest change being in the third moment. We can bring the first and second moments back to their original values by adding new wiggles to balance out the changes caused by the first. By choosing the position of the wiggles, we can get any value of the third moment without reducing the entropy significantly below that of the associated normal. Using this method, we can come arbitrarily close to the upper bound for the maximum entropy distribution. We conclude that (12.32) This, example shows that the maximum entropy may only be -achievable. 12.4 SPECTRUM ESTIMATION Given a stationary zero-mean stochastic process { X i }, we define the autocorrelation function as (12.33) The Fourier transform of the autocorrelation function for a zero-mean process is the power spectral density S (λ): (12.34) where Since the power spectral density is indicative of the structure of the process, it is useful to form an estimate from a sample of the process. There are many methods to estimate the power spectrum. The simplest way is to estimate the autocorrelation function by taking sample averages for a sample of length n , (12.35) If we use all the values of the sample correlation function to calculate the spectrum, the estimate that we obtain from (12.34) does not converge to the true power spectrum for large n . Hence, this method, the periodogram method , is rarely used. One of the reasons for the problem with the periodogram method is that the estimates of the autocorrelation function from the data have different accuracies. The estimates for low values of k (called the lags ) are based on a large number of samples and those for high k on very few samples. So the estimates are more accurate at low k . The method can be modified so that it depends only on the autocorrelations at low k by setting the higher lag autocorrelations to 0. However, this introduces some artifacts because of the sudden transition to zero autocorrelation. Various windowing schemes have been suggested to smooth out the transition. However, windowing reduces spectral resolution and can give rise to negative power spectral estimates. In the late 1960s, while working on the problem of spectral estimation for geophysical applications, Burg suggested an alternative method. Instead of setting the autocorrelations at high lags to zero, he set them to values that make the fewest assumptions about the data (i.e., values that maximize the entropy rate of the process). This is consistent with the maximum entropy principle as articulated by Jaynes [294]. Burg assumed the process to be stationary and Gaussian and found that the process which maximizes the entropy subject to the correlation constraints is an autoregressive Gaussian process of the appropriate order. In some applications where we can assume an underlying autoregressive model for the data, this method has proved useful in determining the parameters of the model (e.g., linear predictive coding for speech). This method (known as the maximum entropy method or Burg’s method ) is a popular method for estimation of spectral densities. We prove Burg’s theorem in Section 12.6. 12.5 ENTROPY RATES OF A GAUSSIAN PROCESS In Chapter 8 we defined the differential entropy of a continuous random variable. We can now extend the definition of entropy rates to real-valued stochastic processes. Definition The differential entropy rate of a stochastic process { X i }, X i , is defined to be (12.36) if the limit exists. Just as in the discrete case, we can show that the limit exists for stationary processes and that the limit is given by the two expressions (12.37) (12.38) For a stationary Gaussian stochastic process, we have (12.39) where the covariance matrix K ( n ) is Toeplitz with entries R (0), R (1),…, R ( n − 1) along the top row. Thus, = E ( X i − EX i )( X j − EX j ). As n → ∞, the density of the eigenvalues of the covariance matrix tends to a limit, which is the spectrum of the stochastic process. Indeed, Kolmogorov showed that the entropy rate of a stationary Gaussian stochastic process can be expressed as (12.40) The entropy rate is also lim n →∞ h ( X n | X n −1 ). Since the stochastic process is Gaussian, the conditional distribution is also Gaussian, and hence the conditional entropy is log 2π e , where is the variance of the error in the best estimate of X n given the infinite past. Thus, (12.41) where h (χ) is given by (12.40) . Hence, the entropy rate corresponds to the minimum mean-squared error of the best estimator of a sample of the process given the infinite past. 12.6 BURG’S MAXIMUM ENTROPY THEOREM Theorem 12.6.1 The maximum entropy rate stochastic process { X i } satisfying the constraints (12.42) is the p th-order Gauss–Markov process of the form (12.43) where the Z i are i.i.d . ~ (0, σ 2 ) and a 1 , a 2 ,…, a p , σ 2 are chosen to satisfy (12.42) . Remark We do not assume that {Xi} is (a) zero mean, (b) Gaussian, or (c) wide-sense stationary. Proof: Let X 1 , X 2 ,…, X n be any stochastic process that satisfies the constraints (12.42) . Let Z 1 , Z 2 ,…, Z n be a Gaussian process with the same covariance matrix as X 1 , X 2 ,…, X n . Then since the multivariate normal distribution maximizes the entropy over all vector-valued random variables under a covariance constraint, we have (12.44) (12.45) (12.46) by the chain rule and the fact that conditioning reduces entropy. Now define as a p th-order Gauss–Markov process with the same distribution as Z 1 , Z 2 ,…, Z n for all orders up to p . (Existence of such a process will be verified using the Yule–Walker equations immediately after the proof.) Then since h ( Z i | Z i −1 ,…, Z i−p ) depends only on the p th-order distribution, h ( Z i | Z i −1 ,…, Z i−p ) = and continuing the chain of inequalities, we obtain (12.47) (12.48) (12.49) where the last equality follows from the p th-order Markovity of the . Dividing by n and taking the limit, we obtain (12.50) where (12.51) which is the entropy rate of the Gauss–Markov process. Hence, the maximum entropy rate stochastic process satisfying the constraints is the p th-order Gauss–Markov process satisfying the constraints. A bare-bones summary of the proof is that the entropy of a finite segment of a stochastic process is bounded above by the entropy of a segment of a Gaussian random process with the same covariance structure. This entropy is in turn bounded above by the entropy of the minimal order Gauss–Markov process satisfying the given covariance constraints. Such a process exists and has a convenient characterization by means of the Yule–Walker equations given below. Note on the choice of a 1 ,…, a p and : Given a sequence of covariances R (0), R (1),…, R ( p ), does there exist a p th-order Gauss–Markov process with these covariances? Given a process of the form (12.43) , can we choose the a k ’s to satisfy the constraints? Multiplying (12.43) by X i−l and taking expectations, noting that R ( k ) = R (− k ), we get (12.52) and (12.53) These equations are called the Yule–Walker equations . There are p + 1 equations in the p + 1 unknowns a 1 , a 2 ,…, a p , σ 2 . Therefore, we can solve for the parameters of the process from the covariances. Fast algorithms such as the Levinson algorithm and the Durbin algorithm [433] have been devised to use the special structure of these equations to calculate the coefficients a 1 , a 2 ,…, a p efficiently from the covariances. (We set a 0 = 1 for a consistent notation.) Not only do the Yule–Walker equations provide a convenient set of linear equations for calculating the a k ’s and σ 2 from the R ( k )’s, they also indicate how the autocorrelations behave for lags greater than p . The autocorrelations for high lags are an extension of the values for lags less than p . These values are called the Yule–Walker extension of the autocorrelations. The spectrum of the maximum entropy process is seen to be (12.54) (12.55) This is the maximum entropy spectral density subject to the constraints R (0), R (1),…, R ( p ). However, for the p th-order Gauss–Markov process, it is possible to calculate the entropy rate directly without calculating the a i ’s. Let K p be the autocorrelation matrix corresponding to this process–the matrix with R 0 , R 1 ,…, R p along the top row. For this process, the entropy rate is equal to (12.56) (12.57) (12.58) In a practical problem, we are generally given a sample sequence X 1 , X 2 ,…, X n , from which we calculate the autocorrelations. An important question is: How many autocorrelation lags should we consider (i.e., what is the optimum value of p )? A logically sound method is to choose the value of p that minimizes the total description length in a two-stage description of the data. This method has been proposed by Rissanen [442, 447] and Barron [33] and is closely related to the idea of Kolmogorov complexity. SUMMARY Maximum entropy distribution. Let f be a probability density satisfying the constraints (12.59) Let S , and let λ 0 ,…, λ m be chosen so that f * satisfies (12.59) . Then f * uniquely maximizes h ( f ) over all f satisfying these constraints. Maximum entropy spectral density estimation. The entropy rate of a stochastic process subject to autocorrelation constraints R 0 , R 1 ,…, R p is maximized by the p th order zero-mean Gauss-Markov process satisfying these constraints. The maximum entropy rate is (12.60) and the maximum entropy spectral density is (12.61) PROBLEMS 12.1 Maximum entropy . Find the maximum entropy density f , defined for x ≥ 0, satisfying EX = α 1 , E ln X = α 2 . That is, maximize − ∫ f ln f subject to ∫ xf ( x ) dx = α 1 , ∫ (In x ) f ( x ) dx = α 2 , where the integral is over 0 ≤ x < ∞. What family of densities is this? 12.2 Min D ( P || Q ) under constraints on P . We wish to find the (parametric form) of the probability mass function P ( x ), x {1, 2,…} that minimizes the relative entropy D ( P || Q ) over all P such that ∑ P ( x ) g i ( x ) = α i , i = 1, 2,…. (a) Use Lagrange multipliers to guess that (12.62) achieves this minimum if there exist Ai ‘s satisfying the constraints. This generalizes the theorem on maximum entropy distributions subject to constraints. (b) Verify that P * minimizes D ( P || Q ). 12.3 Maximum entropy processes . Find the maximum entropy rate stochastic process subject to the constraints: (a) EX 2 i = 1, i = 1, 2,…. (b) EX 2 i = 1, EX i X i +1 = , i = 1, 2,…. (c) Find the maximum entropy spectrum for the processes in parts (a) and (b). 12.4 Maximum entropy with marginals . What is the maximum entropy distribution p ( x , y ) that has the following marginals? ( Hint: You may wish to guess and verify a more general result.) 12.5 Processes with fixed marginals . Consider the set of all densities with fixed pairwise marginals f X 1 , X 2 ( X 1 , X 2 ), f X 2 , X 3 ( X 2 , X 3 ),…, f X n −1 , X n ( x n −1 , x n ). Show that the maximum entropy process with these marginals is the first-order (possibly time-varying) Markov process with these marginals. Identify the maximizing f * ( x 1 , x 2 ,…, x n ). 12.6 Every density is a maximum entropy density . Let f 0 ( x ) be a given density. Given r ( x ), let g α ( x ) be the density maximizing h ( X ) over all f satisfying ∫ f ( x ) r ( x ) dx = α. Now let r ( x ) = In f o ( x ). Show that g α ( x ) = f 0 ( x ) for an appropriate choice α = α 0 . Thus, f 0 ( x ) is a maximum entropy density under the constraint ∫ f In f 0 = α 0 . 12.7 Mean-squared error . Let satisfy E X i X i+k = R k , k = 0, 1,…, p . Consider linear predictors for X n ; that is, Assume that n > p . Find where the minimum is over all linear predictors b and the maximum is over all densities f satisfying R 0 ,…, R p . 12.8 Maximum entropy characteristic functions . We ask for the maximum entropy density f ( x ), 0 ≤ x ≤ a , satisfying a constraint on the characteristic function e iux f ( x ) dx . The answers need be given only in parametric form. (a) Find the maximum entropy f satisfying f ( x ) cos( u 0 x ) dx = α, at a specified point u 0 . (b) Find the maximum entropy f satisfying f ( x ) sin( u 0 x ) dx = β. (c) Find the maximum entropy density f ( x ), 0 ≤ x ≤ a , having a given value of the characteristic function ψ( u 0 ) at a specified point u 0 . (d) What problem is encountered if a = ∞? 12.9 Maximum entropy processes (a) Find the maximum entropy rate binary stochastic process , satisfying Pr{ X i = X i +1 } = for all i . (b) What is the resulting entropy rate? 12.10 Maximum entropy of sums . Let Y = X 1 + X 2 . Find the maximum entropy density for Y under the constraint = p 2 : (a) If X 1 and X 2 are independent. (b) If X 1 and X 2 are allowed to be dependent. (c) Prove part (a). 12.11 Maximum entropy Markov chain . Let { X i } be a stationary Markov chain with X i {1, 2, 3}. Let I ( X n , X n +2 ) = 0 for all n . (a) What is the maximum entropy rate process satisfying this constraint? (b) What if I ( X n ; X n +2 ) = α for all n for some given value of α, 0 ≤ α ≤ log 3? 12.12 Entropy bound on prediction error . Let { X n } be an arbitrary real valued stochastic process. Let n +1 = E { X n +1 | X n }. Thus the conditional mean n +1 is a random variable depending on the n -past X n . Here n +1 is the minimum mean squared error prediction of X n +1 given the past. (a) Find a lower bound on the conditional variance E { E {( X n +1 − n +1 ) 2 | X n }} in terms of the conditional differential entropy h ( X n +1 | X n ) (b) Is equality achieved when { X n } is a Gaussian stochastic process? 12.13 Maximum entropy rate . What is the maximum entropy rate stochastic process { X i } over the symbol set {0, 1} for which the probability that 00 occurs in a sequence is zero? 12.14 Maximum entropy (a) What is the parametric-form maximum entropy density f ( x ) satisfying the two conditions (b) What is the maximum entropy density satisfying the condition (c) Which entropy is higher? 12.15 Maximum entropy . Find the parametric form of the maximum entropy density f satisfying the Laplace transform condition and give the constraints on the parameter. 12.16 Maximum entropy processes . Consider the set of all stochastic processes with { X i }, X i R ., with Find the maximum entropy rate. 12.17 Binary maximum entropy . Consider a binary process { X i }, X i {– 1, +1}, with R 0 = EX 2 i = 1 and R 1 = EX i X i +1 = . (a) Find the maximum entropy process with these constraints. (b) What is the entropy rate? (c) Is there a Bernoulli process satisfying these constraints? 12.18 Maximum entropy . Maximize h ( Z , V x , V y , V z ) subject to the energy constraint E ( m || V || 2 + mg Z ) = E 0 . Show that the resulting distribution yields Thus, of the energy is stored in the potential field, regardless of its strength g . 12.19 Maximum entropy discrete processes (a) Find the maximum entropy rate binary stochastic process , X i {0, 1}, satisfying Pr{ X i = X i +1 } = for all i . (b) What is the resulting entropy rate? 12.20 Maximum entropy of sums . Let Y = X 1 + X 2 . Find the maximum entropy of Y under the constraint EX 2 1 = p 1 , EX 2 2 = p 2 : (a) If X 1 and X 2 are independent. (b) If X 1 and X 2 are allowed to be dependent. 12.21 Entropy rate (a) Find the maximum entropy rate stochastic process { X i } with , EX i X i +2 = α, i = 1, 2,…. Be careful. (b) What is the maximum entropy rate? (c) What is EX i X i +1 for this process? 12.22 Minimum expected value (a) Find the minimum value of EX over all probability density functions f ( x ) satisfying the following three constraints: (i) f ( x ) = 0 for x ≤ 0. (ii) , f ( x ) dx = 1. (iii) h ( f ) = h . (b) Solve the same problem if (i) is replaced by (i′) f ( x ) = 0 for x ≤ a . HISTORICAL NOTES The maximum entropy principle arose in statistical mechanics in the nineteenth century and has been advocated for use in a broader context by Jaynes [294]. It was applied to spectral estimation by Burg [80]. The information-theoretic proof of Burg’s theorem is from Choi and Cover [98].

Chapter 13: Universal Source Coding CHAPTER 13 UNIVERSAL SOURCE CODING Here we develop the basics of universal source coding. Minimax regret data compression is defined, and the descriptive cost of universality is shown to be the information radius of the relative entropy ball containing all the source distributions. The minimax theorem shows this radius to be the channel capacity for the associated channel given by the source distribution. Arithmetic coding enables the use of a source distribution that is learned on the fly. Finally, individual sequence compression is defined and achieved by a succession of Lempel–Ziv parsing algorithms. In Chapter 5 we introduced the problem of finding the shortest representation of a source, and showed that the entropy is the fundamental lower limit on the expected length of any uniquely decodable representation. We also showed that if we know the probability distribution for the source, we can use the Huffman algorithm to construct the optimal (minimal expected length) code for that distribution. For many practical situations, however, the probability distribution underlying the source may be unknown, and we cannot apply the methods of Chapter 5 directly. Instead, all we know is a class of distributions. One possible approach is to wait until we have seen all the data, estimate the distribution from the data, use this distribution to construct the best code, and then go back to the beginning and compress the data using this code. This two-pass procedure is used in some applications where there is a fairly small amount of data to be compressed. But there are many situations in which it is not feasible to make two passes over the data, and it is desirable to have a one-pass (or online) algorithm to compress the data that “learns” the probability distribution of the data and uses it to compress the incoming symbols. We show the existence of such algorithms that do well for any distribution within a class of distributions. In yet other cases, there is no probability distribution underlying the data—all we are given is an individual sequence of outcomes. Examples of such data sources include text and music. We can then ask the question: How well can we compress the sequence? If we do not put any restrictions on the class of algorithms, we get a meaningless answer—there always exists a function that compresses a particular sequence to one bit while leaving every other sequence uncompressed. This function is clearly “overfitted” to the data. However, if we compare our performance to that achievable by optimal word assignments with respect to Bernoulli distributions or k th-order Markov processes, we obtain more interesting answers that are in many ways analogous to the results for the probabilistic or average case analysis. The ultimate answer for compressibility for an individual sequence is the Kolmogorov complexity of the sequence, which we discuss in Chapter 14. We begin the chapter by considering the problem of source coding as a game in which the coder chooses a code that attempts to minimize the average length of the representation and nature chooses a distribution on the source sequence. We show that this game has a value that is related to the capacity of a channel with rows of its transition matrix that are the possible distributions on the source sequence. We then consider algorithms for encoding the source sequence given a known or “estimated” distribution on the sequence. In particular, we describe arithmetic coding, which is an extension of the Shannon–Fano–Elias code of Section 5.9 that permits incremental encoding and decoding of sequences of source symbols. We then describe two basic versions of the class of adaptive dictionary compression algorithms called Lempel–Ziv, based on the papers by Ziv and Lempel [603, 604]. We provide a proof of asymptotic optimality for these algorithms, showing that in the limit they achieve the entropy rate for any stationary ergodic source. In Chapter 16 we extend the notion of Universality to investment in the stock market and describe online portfolio selection procedures that are analogous to the universal methods for data compression. 13.1 UNIVERSAL CODES AND CHANNEL CAPACITY Assume that we have a random variable X drawn according to a distribution from the family { p θ }, where the parameter θ {1, 2,…, m } is unknown. We wish to find an efficient code for this source. From the results of Chapter 5, if we know θ, we can construct a code with codeword lengths , achieving an average codeword length equal to the entropy H θ ( x ) = − ∑ x p θ ( x ) log p θ ( x ), and this is the best that we can do. For the purposes of this section, we will ignore the integer constraints on l ( x ), knowing that applying the integer constraint will cost at most one bit in expected length. Thus, (13.1) What happens if we do not know the true distribution p θ , yet wish to code as efficiently as possible? In this case, using a code with codeword lengths l ( x ) and implied probability q ( x ) = 2 −l( x ) , we define the redundancy of the code as the difference between the expected length of the code and the lower limit for the expected length: (13.2) (13.3) (13.4) (13.5) (13.6) where q ( x ) = 2 −1( x ) is the distribution that corresponds to the codeword lengths l ( x ). We wish to find a code that does well irrespective of the true distribution p θ , and thus we define the minimax redundancy as (13.7) This minimax redundancy is achieved by a distribution q that is at the “center” of the information ball containing the distributions p θ , that is, the distribution q whose maximum distance from any of the distributions P θ is minimized ( Figure 13.1 ). FIGURE 13.1. Minimum radius information ball containing all the p θ ’s To find the distribution q that is as close as possible to all the possible p θ in relative entropy, consider the following channel: (13.8) This is a channel {θ, p θ ( x ), χ} with the rows of the transition matrix equal to the different p θ ’s, the possible distributions of the source. We will show that the minimax redundancy R * is equal to the capacity of this channel, and the corresponding optimal coding distribution is the output distribution of this channel induced by the capacity-achieving input distribution. The capacity of this channel is given by (13.9) where (13.10) The equivalence of R * and C is expressed in the following theorem: Theorem 13.1.1 ( Gallager [229], Ryabko [450]) The capacity of a channel p ( x |θ) with rows p 1 , p 2 ,…, p m is given by (13.11) The distribution q that achieves the minimum in (13.11) is the output distribution q * ( x ) induced be the capacity-achieving input distribution π*(θ): (13.12) Proof: Let π(θ) be an input distribution on θ {1, 2,…, m } and let the induced output distribution be q π : (13.13) where P ij = p θ ( x ) for θ = i , x = j . Then for any distribution q on the output, we have (13.14) (13.15) (13.16) (13.17) (13.18) (13.19) (13.20) (13.21) for all q , with equality iff q = q π Thus, for all q , (13.22) and therefore (13.23) is achieved when q = q π . Thus, the output distribution that minimizes the average distance to all the rows of the transition matrix is the the output distribution induced by the channel (Lemma 10.8.1). The channel capacity can now be written as (13.24) (13.25) We can now apply a fundamental theorem of game theory, which states that for a continuous function f ( x , y ), x χ, y y , if f ( x , y ) is convex in x and concave in y , and χ, y ) are compact convex sets, then (13.26) The proof of this minimax theorem can be found in [305, 392]. By convexity of relative entropy (Theorem 2.7.2), ∑ i π i D ( p i || q ) is convex in q and concave in π, and therefore (13.27) (13.28) (13.29) where the last equality follows from the fact that the maximum is achieved by putting all the weight on the index i maximizing D ( p i || q ) in (13.28) . It also follows that q * = q π *. This completes the proof. Thus, the channel capacity of the channel from θ to X is the minimax expected redundancy in source coding. Example 13.1.1 Consider the case when χ = {1, 2, 3} and θ takes only two values, 1 and 2, and the corresponding distributions are p 1 = (1 − α, α, 0) and p 2 = (0, α, 1 − α). We would like to encode a single symbol χ without knowing whether the distribution is p 1 or p 2 . The arguments above indicate that the worst-case optimal code uses the corresponding to the distribution that has a minimal relative entropy distance from both distributions, in this case, the midpoint of the two distributions. Using this distribution, , we achieve a redundancy of (13.30) The channel with transition matrix rows equal to p 1 and p 2 is equivalent to the erasure channel (Section 7.1.5), and the capacity of this channel can easily be calculated to be (1 − α), achieved with a uniform distribution on the inputs. The output distribution corresponding to the capacity-achieving input distribution is equal to (i.e., the same as the distribution q above). Thus, if we don’t know the distribution for this class of sources, we code using the distribution q rather than p 1 or p 2 , and incur an additional cost of 1 − α bits above the ideal entropy bound. 13.2 UNIVERSAL CODING FOR BINARY SEQUENCES Now we consider an important special case of encoding a binary sequence x n {0, 1} n . We do not make any assumptions about the probability distribution for x 1 , x 2 ,…, x n . We begin with bounds on the size of , taken from Wozencraft and Reiffen [567] proved in Lemma 17.5.1: For k ≠ 0 or n , (13.31) We first describe an offline algorithm to describe the sequence; we count the number of 1’s in the sequence, and after we have seen the entire sequence, we send a two-stage description of the sequence. The first stage is a count of the number of 1’s in the sequence [i.e., k = ∑ i x i (using [log( n + 1)1 bits)], and the second stage is the index of this sequence among all sequences that have k 1’s (using bits). This two-stage description requires total length (13.32) (13.33) (13.34) Thus, the cost of describing the sequence is approximately log n bits above the optimal cost with the Shannon code for a Bernoulli distribution corresponding to k / n . The last term is unbounded at k = 0 or k = n , so the bound is not useful for these cases (the actual description length is log( n + 1) bits, whereas the entropy H ( k / n ) = 0 when k = 0 or k = n ). This counting approach requires the compressor to wait until he has seen the entire sequence. We now describe a different approach using a mixture distribution that achieves the same result on the fly. We choose the coding distribution q ( x 1 , x 2 ,…, x n ) = 2 −1( x 1 , x 2 ,…, x n ) to be a uniform mixture of all Bernoulli(θ) distributions on x 1 , x 2 ,…, x n . We will analyze the performance of a code using this distribution and show that such codes perform well for all input sequences. We construct this distribution by assuming that θ, the parameter of the Bernoulli distribution is drawn according to a uniform distribution on [0, 1]. The probability of a sequence x 1 , x 2 ,…, x n with k ones is θ k (1 − θ) n-k under the Bernoulli(θ) distribution. Thus, the mixture probability of the sequence is (13.35) Integrating by parts, setting u = (1 − θ) n−k and dv = θ k d θ, we have (13.36) or (13.37) Now A ( n , n ) = θ n d θ , and we can easily verify from the recursion that (13.38) The codeword length with respect to the mixture distribution is (13.39) which is within one bit of the length of the two-stage description above. Thus, we have a similar bound on the codeword length (13.40) for all sequences x 1 , x 2 ,…, x n . This mixture distribution achieves a codeword length within log n bits of the optimal code length nH ( k / n ) that would be required if the source were really Bernoulli( k / n ), without any assumptions about the distribution of the source. This mixture distribution yields a nice expression for the conditional probability of the next symbol given the previous symbols of x 1 , x 2 ,…, x n . Let k i be the number of l’s in the first i symbols of x 1 , x 2 ,…, x n . Using (13.38) , we have (13.41) (13.42) (13.43) (13.44) This is the Bayesian posterior probability of 1 given the uniform prior on θ, and is called the Laplace estimate for the probability of the next symbol. We can use this posterior probability as the probability of the next symbol for arithmetic coding, and achieve the codeword length log in a sequential manner with finite-precision arithmetic. This is a horizon-free result, in that the procedure does not depend on the length of the sequence. One issue with the uniform mixture approach or the two-stage approach is that the bound does not apply for k = 0 or k = n . The only uniform bound that we can give on the extra redundancy is log n , which we can obtain by using the bounds of (11.40). The problem is that we are not assigning enough probability to sequences with k = 0 or k = n . If instead of using a uniform distribution on θ, we used the Dirichlet distribution, also called the Beta distribution, the probability of a sequence x 1 , x 2 ,…, x n becomes (13.45) and it can be shown that this achieves a description length (13.46) for all x n {0, 1} n , achieving a uniform bound on the redundancy of the universal mixture code. As in the ease of the uniform prior, we can calculate the conditional distribution of the next symbol, given the previous observations, as (13.47) which can be used with arithmetic coding to provide an online algorithm to encode the sequence. We will analyze the performance of the mixture algorithm in greater detail when we analyze universal portfolios in Section 16.7. 13.3 ARITHMETIC CODING The Huffman coding procedure described in Chapter 5 is optimal for encoding a random variable with a known distribution that has to be encoded symbol by symbol. However, due to the fact that the codeword lengths for a Huffman code were restricted to be integral, there could be a loss of up to 1 bit per symbol in coding efficiency. We could alleviate this loss by using blocks of input symbols—however, the complexity of this approach increases exponentially with block length. We now describe a method of encoding without this inefficiency. In arithmetic coding, instead of using a sequence of bits to represent a symbol, we represent it by a subinterval of the unit interval. The code for a sequence of symbols is an interval whose length decreases as we add more symbols to the sequence. This property allows us to have a coding scheme that is incremental (the code for an extension to a sequence can be calculated simply from the code for the original sequence) and for which the codeword lengths are not restricted to be integral. The motivation for arithmetic coding is based on Shannon–Fano–Elias coding (Section 5.9) and the following lemma: Lemma 13.3.1 Let Y be a random variable with continuous probability distribution function F ( y ). Let U = F ( Y ) (i.e., U is a function of Y defined by its distribution function). Then U is uniformly distributed on [0, 1]. Proof: Since F ( y ) [0, 1], the range of U is [0, 1]. Also, for u [0, 1], (13.48) (13.49) (13.50) (13.51) (13.52) which proves that U has a uniform distribution in [0, 1]. Now consider an infinite sequence of random variables X 1 , X 2 ,… from a finite alphabet χ = 0, 1, 2,… m . For any sequence x 1 , x 2 ,…, from this alphabet, we can place 0. in front of the sequence and consider it as a real number (base m + 1) between 0 and 1. Let X be the real-valued random variable X = 0. X 1 X 2 …. Then X has the following distribution function: (13.53) (13.54) (13.55) Now let U = F X ( X ) = F X (0. X 1 X 2 …) = 0. F 1 F 2 …. If the distribution on infinite sequences X ∞ has no atoms, then, by the lemma above, U has a uniform distribution on [0, 1], and therefore the bits F 1 F 2 . in the binary expansion of U are Bernoulli( ) (i.e., they are independent and uniformly distributed on {0, 1}). These bits are therefore incompressible, and form a compressed representation of the sequence 0. X 1 X 2 …. For Bernoulli or Markov models, it is easy to calculate the cumulative distribution function, as illustrated in the following example. Example 13.3.1 Let X 1 , X 2 ,…, X n be Bernoulli( p ). Then the sequence x n = 110101 maps into (13.56) (13.57) (13.58) Note that each term is easily computed from the previous terms. In general, for an arbitrary binary process { X i }, (13.59) The probability transform thus forms an invertible mapping from infinite source sequences to incompressible infinite binary sequences. We now consider the compression achieved by this transformation on finite sequences. Let X 1 , X 2 ,…, X n be a sequence of binary random variables of length n , and let x 1 , x 2 ,…, x n be a particular outcome. We can treat this sequence as representing an interval [0. x 1 x 2 … x n 000…, 0. x 1 x 2 … x n 1111…), or equivalently, [0. x 1 x 2 … x n , 0. x 1 x 2 … x n ( ) n ). This is the set of infinite sequences that start with 0. x 1 x 2 … x n . Under the probability transform, this interval gets mapped into another interval, [ F Y (0. x 1 x 2 ,…, x n ), F Y (0. x 1 x 2 … x n + ( ) n )), whose length is equal to P X ( x 1 , x 2 ,…, x n ), the sum of the probabilities of all infinite sequences that start with 0. x 1 x 2 … x n . Under the probability inverse transform, any real number u within this interval maps into a sequence that starts with x 1 , x 2 ,…, x n , and therefore given u and n , we can reconstruct x 1 , x 2 ,…, x n . The Shannon–Fano–Elias coding scheme described earlier allows one to construct a prefix-free code of length log + 2 bits, and therefore it is possible to encode the sequence x 1 , x 2 ,…, x n with this length. Note that log is the ideal codeword length for x n . The process of encoding the sequence with the cumulative distribution function described above assumes arbitrary accuracy for the computation. In practice, though, we have to implement all numbers with finite precision, and we describe such an implementation. The key is to consider not infinite-precision points for the cumulative distribution function but intervals in the unit interval. Any finite-length sequence of symbols can be said to correspond to a subinterval of the unit interval. The objective of the arithmetic coding algorithm is to represent a sequence of random variables by a subinterval in [0, 1]. As the algorithm observes more input symbols, the length of the subinterval corresponding to the input sequence decreases. As the top end of the interval and the bottom end of the interval get closer, they begin to agree in the first few bits. These will be first few bits of the output sequence. As soon as the two ends of the interval agree, we can output the corresponding bits. We can therefore shift these bits out of the calculation and effectively scale the remaining intervals so that entire calculation can be done with finite precision. We will not go into the details here—there is a very good description of the algorithm and performance considerations in Bell et al. [41] Example 13.3.2 ( Arithmetic coding for a ternary input alphabet ) Consider a random variable X with a ternary alphabet { A , B , C ), which are assumed to have probabilities 0.4, 0.4, and 0.2, respectively. Let the sequence to be encoded by ACAA. Thus, F l (·) = (0, 0.4, 0.8) and F h (·) = (0.4, 0.8, 1.0). Initially, the input sequence is empty, and the corresponding interval is [0, 1). The cumulative distribution function after the first input symbol is shown in Figure 13.2 . It is easy to calculate that the interval in the algorithm without scaling after the first symbol A is [0, 0.4); after the second symbol, C, it is [0.32, 0.4) ( Figure 13.3 ); after the third symbol A, it is [0.32,0.352); and after the fourth symbol A, it is [0.32, 0.3328). Since the probability of this sequence is 0.0128, we will use log(1/0.0128) + 2 (i.e., 9 bits) to encode the midpoint of the interval sequence using Shannon–Fano–Elias coding (0.3264, which is 0.010100111 binary). FIGURE 13.2. Cumulative distribution function after the first symbol. FIGURE 13.3. Cumulative distribution function after the second symbol. In summary, the arithmetic coding procedure, given any length n and probability mass function q ( x 1 x 2 … x n ), enables one to encode the sequence x 1 x 2 … x n in a code of length log + 2 bits. If the source is i.i.d. and the assumed distribution q is equal to the true distribution p of the data, this procedure achieves an average length for the block that is within 2 bits of the entropy. Although this is not necessarily optimal for any fixed block length (a Huffman code designed for the distribution could have a lower average codeword length), the procedure is incremental and can be used for any blocklength. 13.4 LEMPEL–ZIV CODING In Section 13.3 we discussed the basic ideas of arithmetic coding and mentioned some results on worst-case redundancy for coding a sequence from an unknown distribution. We now discuss a popular class of techniques for source coding that are universally optimal (their asymptotic compression rate approaches the entropy rate of the source for any stationary ergodic source) and simple to implement. This class of algorithms is termed Lempel–Ziv, named after the authors of two seminal papers [603, 604] that describe the two basic algorithms that underlie this class. The algorithms could also be described as adaptive dictionary compression algorithms. The notion of using dictionaries for compression dates back to the invention of the telegraph. At the time, companies were charged by the number of letters used, and many large companies produced codebooks for the frequently used phrases and used the codewords for their telegraphic communication. Another example is the notion of greetings telegrams that are popular in India—there is a set of standard greetings such as “25:Merry Christmas” and “26:May Heaven’s choicest blessings be showered on the newly married couple.” A person wishing to send a greeting only needs to specify the number, which is used to generate the actual greeting at the destination. The idea of adaptive dictionary-based schemes was not explored until Ziv and Lempel wrote their papers in 1977 and 1978. The two papers describe two distinct versions of the algorithm. We refer to these versions as LZ77 or sliding window Lempel–Ziv and LZ78 or tree-structured Lempel–Ziv. (They are sometimes called LZ1 and LZ2, respectively.) We first describe the basic algorithms in the two cases and describe some simple variations. We later prove their optimality, and end with some practical issues. The key idea of the Lempel–Ziv algorithm is to parse the string into phrases and to replace phrases by pointers to where the same string has occurred in the past. The differences between the algorithms is based on differences in the set of possible match locations (and match lengths) the algorithm allows. 13.4.1 Sliding Window Lempel–Ziv Algorithm The algorithm described in the 1977 paper encodes a string by finding the longest match anywhere within a window of past symbols and represents the string by a pointer to location of the match within the window and the length of the match. There are many variations of this basic algorithm, and we describe one due to Storer and Szymanski [507]. We assume that we have a string x 1 , x 2 ,… to be compressed from a finite alphabet. A parsing S of a string x 1 x 2 … x n is a division of the string into phrases, separated by commas. Let W be the length of the window. Then the algorithm can be described as follows: Assume that we have compressed the string until time i − 1. Then to find the next phrase, find the largest k such that for some j , i − 1 − W ≤ j ≤ i − 1, the string of length k starting at x j is equal to the string (of length k) starting at x i (i.e., x i … x j +l = x i+l for all 0 ≤ l < k ). The next phrase is then of length k (i.e., x i … x i+k −1 ) and is represented by the pair ( P, L ), where P is the location of the beginning of the match and L is the length of the match. If a match is not found in the window, the next character is sent uncompressed. To distinguish between these two cases, a flag bit is needed, and hence the phrases are of two types: ( F , P , L ) or ( F , C ), where C represents an uncompressed character. Note that the target of a (pointer, length) pair could extend beyond the window, so that it overlaps with the new phrase. In theory, this match could be arbitrarily long; in practice, though, the maximum phrase length is restricted to be less than some parameter. For example, if W = 4 and the string is ABBABBABBBAABABA and the initial window is empty, the string will be parsed as follows: A,B,B,ABBABB,BA,A,BA,BA, which is represented by the sequence of “pointers”: (0,A),(0,B),(1,1,1),(1,3,6),(1,4,2),(1,1,1),(1,3,2),(1,2,2), where the flag bit is 0 if there is no match and 1 if there is a match, and the location of the match is measured backward from the end of the window. [In the example, we have represented every match within the window using the ( P , L ) pair; however, it might be more efficient to represent short matches as uncompressed characters. See Problem 13.8 for details.] We can view this algorithm as using a dictionary that consists of all substrings of the string in the window and of all single characters. The algorithm finds the longest match within the dictionary and sends a pointer to that match. We later show that a simple variation on this version of LZ77 is asymptotically optimal. Most practical implementations of LZ77, such as gzip and pkzip, are also based on this version of LZ77. 13.4.2 Tree-Structured Lempel–Ziv Algorithms In the 1978 paper, Ziv and Lempel described an algorithm that parses a string into phrases, where each phrase is the shortest phrase not seen earlier. This algorithm can be viewed as building a dictionary in the form of a tree, where the nodes correspond to phrases seen so far. The algorithm is particularly simple to implement and has become popular as one of the early standard algorithms for file compression on computers because of its speed and efficiency. It is also used for data compression in high-speed modems. The source sequence is sequentially parsed into strings that have not appeared so far. For example, if the string is ABBABBABBBAABABAA…, we parse it as A,B,BA,BB,AB,BBA,ABA,BAA…. After every comma, we look along the input sequence until we come to the shortest string that has not been marked off before. Since this is the shortest such string, all its prefixes must have occurred earlier. (Thus, we can build up a tree of these phrases.) In particular, the string consisting of all but the last bit of this string must have occurred earlier. We code this phrase by giving the location of the prefix and the value of the last symbol. Thus, the string above would be represented as (0,A),(0,B),(2,A),(2,B),(1,B),(4,A),(5,A), (3,A),…. Sending an uncompressed character in each phrase results in a loss of efficiency. It is possible to get around this by considering the extension character (the last character of the current phrase) as part of the next phrase. This variation, due to Welch [554], is the basis of most practical implementations of LZ78, such as compress on Unix, in compression in modems, and in the image files in the GIF format. 13.5 OPTIMALITY OF LEMPEL–ZIV ALGORITHMS 13.5.1 Sliding Window Lempel–Ziv Algorithms In the original paper of Ziv and Lempel [603], the authors described the basic LZ77 algorithm and proved that it compressed any string as well as any finite-state compressor acting on that string. However, they did not prove that this algorithm achieved asymptotic optimality (i.e., that the compression ratio converged to the entropy for an ergodic source). This result was proved by Wyner and Ziv [591]. The proof relies on a simple lemma due to Kac: the average length of time that you need to wait to see a particular symbol is the reciprocal of the probability of a symbol. Thus, we are likely to see the high-probability strings within the window and encode these strings efficiently. The strings that we do not find within the window have low probability, so that asymptotically, they do not influence the compression achieved. Instead of proving the optimality of the practical version of LZ77, we will present a simpler proof for a different version of the algorithm, which, though not practical, captures some of the basic ideas. This algorithm assumes that both the sender and receiver have access to the infinite past of the string, and represents a string of length n by pointing to the last time it occurred in the past. We assume that we have a stationary and ergodic process defined for time from − ∞ to ∞, and that both the encoder and decoder have access to …, X −2 , X −1 , the infinite past of the sequence. Then to encode X 0 , X 1 ,…, X n −1 (a block of length n ), we find the last time we have seen these n symbols in the past. Let (13.60) Then to represent X 0 ,…, X n −1 , we need only to send R n to the receiver, who can then look back R n bits into the past and recover X 0 ,…, X n −1 . Thus, the cost of the encoding is the cost of representing R n . We will show that this cost is approximately log R n and that asymptotically E log R n → H (χ), thus proving the asymptotic optimality of this algorithm. We will need the following lemmas. Lemma 13.5.1 There exists a prefix free code for the integers such that the length of the codeword for integer k is log k + 2 log log k + O (1). Proof: If we knew that k ≤ m , we could encode k with log m bits. However, since we don’t have an upper limit for k , we need to tell the receiver the length of the encoding of k (i.e., we need to specify log k ). Consider the following encoding for the integer k: We first represent in unary, followed by the binary representation of k : (13.61) It is easy to see that the length of this representation is 2 + 1 ≤ 2 log k + 3. This is more than the length we are looking for since we are using the very inefficient unary code to send log k . However, if we use C 1 to represent log k , it is now easy to see that this representation has a length less than log k + 2 log log k + 4, which proves the lemma. A similar method is presented in the discussion following Theorem 14.2.3. The key result that underlies the proof of the optimality of LZ77 is Kac’s lemma, which relates the average recurrence time to the probability of a symbol for any stationary ergodic process. For example, if X 1 , X 2 ,…, X n , is an i.i.d. process, we ask what is the expected waiting time to see the symbol a again, conditioned on the fact that X 1 = a . In this case, the waiting time has a geometric distribution with parameter p = p ( X 0 = a ), and thus the expected waiting time is 1/ p ( X 0 = a ). The somewhat surprising result is that the same is true even if the process is not i.i.d., but stationary and ergodic. A simple intuitive reason for this is that in a long sample of length n, we would expect to see a about np ( a ) times, and the average distance between these occurrences of a is n /( np ( a )) (i.e., 1/ p ( a )). Lemma 13.5.2 ( Kac ) Let …, U 2 , U 1 , U 0 , U 1 ,… be a stationary ergodic process on a countable alphabet. For any u such that p ( u ) > 0 and for i = 1, 2,…, let (13.62) [i.e., Q u ( i ) is the conditional probability that the most recent previous occurrence of the symbol u is i, given that U 0 = u]. Then (13.63) Thus, the conditional expected waiting time to see the symbol u again, looking backward from zero, is 1/ p ( u ). Note the amusing fact that the expected recurrence time (13.64) where m is the alphabet size. Proof: Let U 0 = u . Define the events for j = 1, 2,… and k = 0, 1, 2, (13.65) Event A jk corresponds to the event where the last time before zero at which the process is equal to u is at − j , the first time after zero at which the process equals u is k . These events are disjoint, and by ergodicity, the probability Pr{∪ j, k A jk } = 1. Thus, (13.66) (13.67) (13.68) (13.69) (13.70) (13.71) (13.72) where (a) follows from the fact that the A jk are disjoint, (b) follows from the definition of Q u (·), (c) follows from stationarity, and (d) follows from the fact that there are i pairs ( j, k ) such that j + k = i in the sum. Kac’s lemma follows directly from this equation. Corollary Let …, X −1 , X 1 , X 0 ,… be a stationary ergodic process and let R n ( X 0 ,…, X n −1 ) be the recurrence time looking backward as defined in (13.60) . Then (13.73) Proof: Define a new process with U i = ( X i , X i +1 ,…, X i+n −1 ). The U process is also stationary and ergodic, and thus by Kac’s lemma the average recurrence time for U conditioned on U 0 = u is 1/ p ( u ). Translating this to the X process proves the corollary. We are now in a position to prove the main result, which shows that the compression ratio for the simple version of Lempel–Ziv using recurrence time approaches the entropy. The algorithm describes by describing , which by Lemma 13.5.1 can be done with log R n + 2 log log R n , + 4 bits. We now prove the following theorem. Theorem 13.5.1 Let = log R n + 2 log log R n , + O (1) be the description length for in the simple algorithm described above. Then (13.74) as n → ∞, where H (χ) is the entropy rate of the process ( X i ). Proof: We will prove upper and lower bounds for EL n . The lower bound follows directly from standard source coding results (i.e., EL n ≥ nH for any prefix-free code). To prove the upper bound, we first show that (13.75) and later bound the other terms in the expression for L n . To prove the bound for E log R n , we expand the expectation by conditioning on the value of and then applying Jensen’s inequality. Thus, (13.76) (13.77) (13.78) (13.79) (13.80) The second term in the expression for L n is log log R n , and we wish to show that (13.81) Again, we use Jensen’s inequality, (13.82) (13.83) where the last inequality follows from (13.79) . For any > 0, for large enough n , H(X 0 n −1 ) < n ( H + ), and therefore log log R n < log n + log( H + ) → 0. This completes the proof of the theorem. Thus, a compression scheme that represents a string by encoding the last time it was seen in the past is asymptotically optimal. Of course, this scheme is not practical, since it assumes that both sender and receiver have access to the infinite past of a sequence. For longer strings, one would have to look further and further back into the past to find a match. For example, if the entropy rate is and the string has length 200 bits, one would have to look an average of 2 100 ≈ 10 30 bits into the past to find a match. Although this is not feasible, the algorithm illustrates the basic idea that -matching the past is asymptotically optimal. The proof of the optimality of the practical version of LZ77 with a finite window is based on similar ideas. We will not present the details here, but refer the reader to the original proof in [591]. 13.5.2 Optimality of Tree-Structured Lempel–Ziv Compression We now consider the tree-structured version of Lempel–Ziv, where the input sequence is parsed into phrases, each phrase being the shortest string that has not been seen so far. The proof of the optimality of this algorithm has a very different flavor from the proof for LZ77; the essence of the proof is a counting argument that shows that the number of phrases cannot be too large if they are all distinct, and the probability of any sequence of symbols can be bounded by a function of the number of distinct phrases in the parsing of the sequence. The algorithm described in Section 13.4.2 requires two passes over the string—in the first pass, we parse the string and calculate c(n) , the number of phrases in the parsed string. We then use that to decide how many bits [log c(n)] to allot to the pointers in the algorithm. In the second pass, we calculate the pointers and produce the coded string as indicated above. The algorithm can be modified so that it requires only one pass over the string and also uses fewer bits for the initial pointers. These modifications do not affect the asymptotic efficiency of the algorithm. Some of the implementation details are discussed by Welch [554] and Bell et al. [41]. We will show that like the sliding window version of Lempel–Ziv, this algorithm asymptotically achieves the entropy rate for the unknown ergodic source. We first define a parsing of the string to be a decomposition into phrases. Definition A parsing S of a binary string x 1 x 2 x n is a division of the string into phrases, separated by commas. A distinct parsing is a parsing such that no two phrases are identical. For example, 0,111,1 is a distinct parsing of 01111, but 0,11,11 is a parsing that is not distinct. The LZ78 algorithm described above gives a distinct parsing of the source sequence. Let c(n) denote the number of phrases in the LZ78 parsing of a sequence of length n . Of course, c(n) depends on the sequence X n . The compressed sequence (after applying the Lempel–Ziv algorithm) consists of a list of c(n) pairs of numbers, each pair consisting of a pointer to the previous occurrence of the prefix of the phrase and the last bit of the phrase. Each pointer requires log c(n) bits, and hence the total length of the compressed sequence is c(n) [log c(n) + 1] bits. We now show that for a stationary ergodic sequence X 1 , X 2 , … X n . Our proof is based on the simple proof of asymptotic optimality of LZ78 coding due to Wyner and Ziv [575]. Before we proceed to the details of the proof, we provide an outline of the main ideas. The first lemma shows that the number of phrases in a distinct parsing of a sequence is less than n/ log n; the main argument in the proof is based on the fact that there are not enough distinct short phrases. This bound holds for any distinct parsing of the sequence, not just the LZ78 parsing. The second key idea is a bound on the probability of a sequence based on the number of distinct phrases. To illustrate this, consider an i.i.d. sequence of random variables X 1 , X 2 , X 3 , X 4 that take on four possible values, {A, B, C, D} , with probabilities PA, PB, PC , and PD , respectively. Now consider the probability of a sequence P(D, A, B, C) = PD PA PB PC . Since PA + PB + PC + PD = 1, the product p D p A p B p C is maximized when the probabilities are equal (i.e., the maximum value of the probability of a sequence of four distinct symbols is 1/256). On the other hand, if we consider a sequence A, B, A, B , the probability of this sequence is maximized if p A = p B = , p C = p D = 0, and the maximum probability for A, B, A, B is 1/16. A sequence of the form A, A, A, A could have a probability of 1. All these examples illustrate a basic point—sequences with a large number of distinct symbols (or phrases) cannot have a large probability. Ziv’s inequality (Lemma 13.5.5) is the extension of this idea to the Markov case, where the distinct symbols are the phrases of the distinct parsing of the source sequence. Since the description length of a sequence after the parsing grows as clog c , the sequences that have very few distinct phrases can be compressed efficiently and correspond to strings that could have a high probability. On the other hand, strings that have a large number of distinct phrases do not compress as well; but the probability of these sequences could not be too large by Ziv’s inequality. Thus, Ziv’s inequality enables us to connect the logarithm of the probability of the sequence with the number of phrases in its parsing, and this is finally used to show that the tree-structured Lempel-Ziv algorithm is asymptotically optimal. We first prove a few lemmas that we need for the proof of the theorem. The first is a bound on the number of phrases possible in a distinct parsing of a binary sequence of length n . Lemma 13.5.3 (Lempel and Ziv [604]) The number of phrases c(n) in a distinct parsing of a binary sequence X 1, X 2,…, X n satisfies (13.84) where as n → ∞ Proof: Let (13.85) be the sum of the lengths of all distinct strings of length less than or equal to k . The number of phrases c in a distinct parsing of a sequence of length n is maximized when all the phrases are as short as possible. If n = n k , this occurs when all the phrases are of length < k , and thus (13.86) If n k ≤ n < n k +1 , we write n = n k + Δ, where Δ < ( k + 1)2 k +1 . Then the parsing into shortest phrases has each of the phrases of length ≤ k and Δ/( k + 1) phrases of length k + 1. Thus, (13.87) We now bound the size of k for a given n . Let n k ≤ n < n k +1 . Then (13.88) and therefore (13.89) Moreover, (13.90) by (13.89) , and therefore (13.91) or for all n ≤ 4, (13.92) (13.93) (13.94) (13.95) (13.96) Note that . Combining (13.96) with (13.87) , we obtain the lemma. We will need a simple result on maximum entropy in the proof of the main theorem. Lemma 13.5.4 Let Z be a nonnegative integer-valued random variable with mean μ . Then the entropy H(Z) is bounded by (13.97) Proof: The lemma follows directly from the results of Theorem 12.1.1, which show that the geometric distribution maximizes the entropy of a nonnegative integer-valued random variable subject to a mean constraint. Let be a binary stationary ergodic process with probability mass function P ( x 1 , x 2 ,…, x n ). (Ergodic processes are discussed in greater detail in Section 16.8.) For a fixed integer k , define the k th-order Markov approximation to P as (13.98) where ( x i , x i +1 ,…, x j ), i ≤ j , and the initial state x 0 −( k −1) will be part of the specification of Q k . Since P(X n | X n −1 n−k ) is itself an ergodic process, we have (13.99) (13.100) (13.101) We will bound the rate of the LZ78 code by the entropy rate of the k th-order Markov approximation for all k . The entropy rate of the Markov approximation converges to the entropy rate of the process as k → ∞, and this will prove the result. Suppose that , and suppose that x n 1 is parsed into c distinct phrases, y 1 , y 2 ,…, y c . Let v i be the index of the start of the i th phrase (i.e., ). For each i = 1, 2,…, c , define . Thus, s i is the k bits of x preceding y i . Of course, . Let C l s be the number of phrases y i with length l and preceding state s i = s for l = 1, 2, … and s χ k . We then have (13.102) and (13.103) We now prove a surprising upper bound on the probability of a string based on the parsing of the string. Lemma 13.5.5 (Ziv’s inequality) For any distinct parsing (in particular, the LZ78 parsing) of the string x 1 x 2 ··· x n , we have (13.104) Note that the right-hand side does not depend on Q k . Proof: We write (13.105) (13.106) or (13.107) (13.108) (13.109) (13.110) where the inequality follows from Jensen’s inequality and the concavity of the logarithm. Now since the y i are distinct, we have . Thus, (13.111) proving the lemma. We can now prove the main theorem. Theorem 13.5.2 Let { X n } be a binary stationary ergodic process with entropy rate H(χ), and let c(n) be the number of phrases in a distinct parsing of a sample of length n from this process. Then (13.112) with probability 1 . Proof: We begin with Ziv’s inequality, which we rewrite as (13.113) (13.114) Writing , we have (13.115) from (13.102) and (13.103) . We now define random variables U, V such that (13.116) Thus, EU = and (13.117) or (13.118) Now (13.119) and H(V) ≤ log |χ| k = k . By Lemma 13.5.4, we have (13.120) (13.121) (13.122) Thus, (13.123) For a given n , the maximum of is attained for the maximum value of c (for ). But from Lemma 13.5.3, . Thus, (13.124) and therefore H (U, V) → 0 as n → ∞. Therefore, (13.125) where k ( n ) → 0 as n → ∞. Hence, with probability 1, (13.126) (13.127) (13.128) We now prove that LZ78 coding is asymptotically optimal. Theorem 13.5.3 Let . be a binary stationary ergodic stochastic process. Let l( X 1 , X 2 ,…, X n ) be the LZ78 codeword length associated with X 1 , X 2 ,…, X n . Then (13.129) where H(χ) is the entropy rate of the process . Proof: We have shown that l ( X 1 , X 2 ,…, X n ) = c(n) (log c(n) + 1), where c(n) is the number of phrases in the LZ78 parsing of the string X 1 , X 2 ,…, X n . By Lemma 13.5.3, lien sup c(n)/n = 0, and thus Theorem 13.5.2 establishes that (13.130) Thus, the length per source symbol of the LZ78 encoding of an ergodic source is asymptotically no greater than the entropy rate of the source. There are some interesting features of the proof of the optimality of LZ78 that are worth noting. The bounds on the number of distinct phrases and Ziv’s inequality apply to any distinct parsing of the string, not just the incremental parsing version used in the algorithm. The proof can be extended in many ways with variations on the parsing algorithm; for example, it is possible to use multiple trees that are context or state dependent [218, 426]. Ziv’s inequality (Lemma 13.5.5) remains particularly intriguing since it relates a probability on one side with a purely deterministic function of the parsing of a sequence on the other. The Lempel-Ziv codes are simple examples of a universal code (i.e., a code that does not depend on the distribution of the source). This code can be used without knowledge of the source distribution and yet will achieve an asymptotic compression equal to the entropy rate of the source. SUMMARY Ideal word length (13.131) Average description length (13.132) Estimated probability distribution . If , then (13.133) Average redundancy (13.134) Minimax redundancy. For X ~ p θ (x) , θ θ, (13.135) Minimax theorem. D * = C , where C is the capacity of the channel {θ, p θ (x) , χ}, Bernoulli sequences. For X n ~Bernoulli(θ), the redundancy is (13.136) Arithmetic coding. nH bits of F(x n ) reveal approximately n bits of x n . Lempel–Ziv coding (recurrence time coding) . Let R n (X n ) be the last time in the past that we have seen a block of n symbols X n . Then log R n → H (χ) and encoding by describing the recurrence time is asymptotically optimal. Lempel–Ziv coding (sequence parsing). If a sequence is parsed into the shortest phrases not seen before (e.g., 011011101 is parsed to 0,1,10,11,101,…) and l(x n ) is the description length of the parsed sequence, then (13.137) for every stationary ergodic process { X i }. PROBLEMS 13.1 Minimax regret data compression and channel capacity . First consider universal data compression with respect to two source distributions. Let the alphabet V = {1, e , 0) and let p 1 (v) put mass 1 − α on v = 1 and mass α on v = e . Let p 2 (v) put mass 1 − α on 0 and mass α on v = e . We assign word lengths to V according to l(v) = log , the ideal codeword length with respect to a cleverly chosen probability mass function p(v) . The worst-case excess description length (above the entropy of the true distribution) is max E (13.138) Thus, the minimax regret is D * = min p max i D(p i || p ). (a) Find D *. (b) Find the p(v) achieving D *. (c) Compare D * to the capacity of the binary erasure channel and comment. 13.2 Universal data compression . Consider three possible source distributions on χ, (a) Find the minimum incremental cost of compression the associated mass function P = ( p 1 , p 2 , p 3 ), and ideal codeword lengths l i = log(l/ p i ). (b) What is the channel capacity of a channel matrix with rows P a , P b , P c ? 13.3 Arithmetic coding . Let { X i } ∞ i =0 be a stationary binary Markov chain with transition matrix (13.139) Calculate the first 3 bits of F(X ∞ ) = 0. F 1 F 2 … when X ∞ = 1010111 …. How many bits of X ∞ does this specify? 13.4 Arithmetic coding . Let X i be binary stationary Markov with transition matrix (a) Find F (01110) = Pr{. X 1 X 2 X 3 X 4 X 5 < .01110}. (b) How many bits. F 1 F 2 … can be known for sure if it is not known how X = 01110 continues? 13.5 Lempel–Ziv . Give the LZ78 parsing and encoding of 00000011010100000110101. 13.6 Compression of constant sequence . We are given the constant sequence x n = 11111…. (a) Give the LZ78 parsing for this sequence. (b) Argue that the number of encoding bits per symbol for this sequence goes to zero as n → ∞. 13.7 Another idealized version of Lempel–Ziv coding . An idealized version of LZ was shown to be optimal: The encoder and decoder both have available to them the “infinite past” generated by the process,…, X −1 , X 0 , and the encoder describes the string ( X 1 , X 2 ,…, X n ) by telling the decoder the position R n in the past of the first recurrence of that string. This takes roughly log R n + 2 log log R n , bits. Now consider the following variant: Instead of describing R n , the encoder describes R n −1 plus the last symbol, X n . From these two the decoder can reconstruct the string ( X 1 , X 2 ,…, X n ). (a) What is the number of bits per symbol used in this case to encode ( X 1 , X 2 ,…, X n )?) (b) Modify the proof given in the text to show that this version is also asymptotically optimal: namely, that the expected number of bits per symbol converges to the entropy rate. 13.8 Length of pointers in LZ77. In the version of LZ77 due to Storer and Szymanski [507] described in Section 13.4.1, a short match can be represented by either ( F, P, L ) (flag, pointer, length) or by ( F, C ) (flag, character). Assume that the window length is W , and assume that the maximum match length is M. (a) How many bits are required to represent P ? To represent L ? (b) Assume that C , the representation of a character, is 8 bits long. If the representation of P plus L is longer than 8 bits, it would be better to represent a single character match as an uncompressed character rather than as a match within the dictionary. As a function of W and M , what is the shortest match that one should represent as a match rather than as uncompressed characters? (c) Let W = 4096 and M = 256. What is the shortest match that one would represent as a match rather than uncompressed characters? 13.9 Lempel–Ziv 78. (a) Continue the Lempel–Ziv parsing of the sequence 0,00,001,00000011010111. (b) Give a sequence for which the number of phrases in the LZ parsing grows as fast as possible. (c) Give a sequence for which the number of phrases in the LZ parsing grows as slowly as possible. 13.10 Two versions of fixed-database Lempel–Ziv. Consider a source ( A, P ). For simplicity assume that the alphabet is finite | A | = A < ∞ and the symbols are i.i.d. ~ P. A fixed database D is given and is revealed to the decoder. The encoder parses the target sequence x n 1 into blocks of length l , and subsequently encodes them by giving the binary description of their last appearance in the database. If a match is not found, the entire block is sent uncompressed, requiring l log A bits. A flag is used to tell the decoder whether a match location is being described or the sequence itself. Parts (a) and (b) give some preliminaries you will need in showing the optimality of fixed-database LZ in part (c). (a) Let x l be a δ-typical sequence of length l starting at 0, and let R l ( x l ) be the corresponding recurrence index in the infinite past …, X −2 , X −1 . Show that where H is the entropy rate of the source. (b) Prove that for any > 0, Pr( R l ( X l ) > 2 l ( H+ ) ) → 0 as l → ∞. ( Hint: Expand the probability by conditioning on strings x l , and break things up into typical and nontypical. Markov’s inequality and the AEP should prove handy as well.) (c) Consider the following two fixed databases: (i) D 1 is formed by taking all δ-typical l -vectors; and (ii) D 2 formed by taking the most recent = 2 l ( H +δ) symbols in the infinite past (i.e., ,…, X −1 ). Argue that the algorithm described above is asymptotically optimal: namely, that the expected number of bits per symbol converges to the entropy rate when used in conjunction with either database D 1 or D 2 . 13.11 Tunstall coding. The normal setting for source coding maps a symbol (or a block of symbols) from a finite alphabet onto a variable-length string. An example of such a code is the Huffman code, which is the optimal (minimal expected length) mapping from a set of symbols to a prefix-free set of codewords. Now consider the dual problem of variable-to-fixed length codes, where we map a variable-length sequence of source symbols into a fixed-length binary (or D -ary) representation. A variable-to-fixed length code for an i.i.d. sequence of random variables X 1 , X 2 ,… X n , X i ~ p ( x ), x X = {0, 1,…, m − 1}, is defined by a prefix-free set of phrases A D ⊂ χ*, where χ* is the set of finite-length strings of symbols of χ, and |A| = D. Given any sequence X 1 , X 2 ,…, X n , the string is parsed into phrases from A D (unique because of the prefix-free property of A D ) and represented by a sequence of symbols from a D -ary alphabet. Define the efficiency of this coding scheme by (13.140) where EL ( A D ) is the expected length of a phrase from A D . (a) Prove that R ( A D ) ≥ H ( X ). (b) The process of constructing A D can be considered as a process of constructing an m -ary tree whose leaves are the phrases in A D . Assume that D = 1 + k ( m − 1) for some integer k ≥ 1. Consider the following algorithm due to Tunstall: (i) Start with A = {0, 1,…, m − 1} with probabilities p 0 , p 1 ,…, P m-1. This corresponds to a complete m -ary tree of depth 1. (ii) Expand the node with the highest probability. For example, if p 0 is the node with the highest probability, the new set is A = {00, 01,…, 0( m − 1), 1,…, ( m − 1)}. (iii) Repeat step 2 until the number of leaves (number of phrases) reaches the required value. Show that the Tunstall algorithm is optimal in the sense that it constructs a variable to a fixed code with the best R ( A D ) for a given D [i.e., the largest value of EL ( A D ) for a given D ]. (c) Show that there exists a D such that R ( A * D ) < H ( X ) + 1. HISTORICAL NOTES The problem of encoding a source with an unknown distribution was analyzed by Fitingof [211] and Davisson [159], who showed that there were classes of sources for which the universal coding procedure was asymptotically optimal. The result relating the average redundancy of a universal code and channel capacity is due to Gallager [229] and Ryabko [450]. Our proof follows that of Csiszár. This result was extended to show that the channel capacity was the lower bound for the redundancy for “most” sources in the class by Merhav and Feder [387], extending the results obtained by Rissanen [444, 448] for the parametric case. The arithmetic coding procedure has its roots in the Shannon–Fano code developed by Elias (unpublished), which was analyzed by Jelinek [297]. The procedure for the construction of a prefix-free code described in the text is due to Gilbert and Moore [249]. Arithmetic coding itself was developed by Rissanen [441] and Pasco [414]; it was generalized by Langdon and Rissanen [343]. See also the enumerative methods in Cover [120]. Tutorial introductions to arithmetic coding can be found in Langdon [342] and Witten et al. [564]. Arithmetic coding combined with the context-tree weighting algorithm due to Willems et al. [560, 561] achieve the Rissanen lower bound [444] and therefore have the optimal rate of convergence to the entropy for tree sources with unknown parameters. The class of Lempel–Ziv algorithms was first described in the seminal papers of Lempel and Ziv [603, 604]. The original results were theoretically interesting, but people implementing compression algorithms did not take notice until the publication of a simple efficient version of the algorithm due to Welch [554]. Since then, multiple versions of the algorithms have been described, many of them patented. Versions of this algorithm are now used in many compression products, including GIF files for image compression and the CCITT standard for compression in modems. The optimality of the sliding window version of Lempel–Ziv (LZ77) is due to Wyner and Ziv [575]. An extension of the proof of the optimality of LZ78 [426] shows that the redundancy of LZ78 is on the order of 1/log( n ), as opposed to the lower bounds of log( n )/ n. Thus even though LZ78 is asymptotically optimal for all stationary ergodic sources, it converges to the entropy rate very slowly compared to the lower bounds for finite-state Markov sources. However, for the class of all ergodic sources, lower bounds on the redundancy of a universal code do not exist, as shown by examples due to Shields [492] and Shields and Weiss [494]. A lossless block compression algorithm based on sorting the blocks and using simple run-length encoding due to Burrows and Wheeler [81] has been analyzed by Effros et al. [181]. Universal methods for prediction are discussed in Feder, Merhav and Gutman [204, 386, 388].

Chapter 14: Kolmogorov Complexity CHAPTER 14 KOLMOGOROV COMPLEXITY The great mathematician Kolmogorov culminated a lifetime of research in mathematics, complexity, and information theory with his definition in 1965 of the intrinsic descriptive complexity of an object. In our treatment so far, the object X has been a random variable drawn according to a probability mass function p ( x ). If X is random, there is a sense in which the descriptive complexity of the event X = x is log , because [log ] is the number of bits required to describe x by a Shannon code. One notes immediately that the descriptive complexity of such an object depends on the probability distribution. Kolmogorov went further. He defined the algorithmic (descriptive) complexity of an object to be the length of the shortest binary computer program that describes the object. (Apparently, a computer, the most general form of data decompressor, will after a finite amount of computation, use this description to exhibit the object described.) Thus, the Kolmogorov complexity of an object dispenses with the probability distribution. Kolmogorov made the crucial observation that the definition of complexity is essentially computer independent. It is an amazing fact that the expected length of the shortest binary computer description of a random variable is approximately equal to its entropy. Thus, the shortest computer description acts as a universal code which is uniformly good for all probability distributions. In this sense, algorithmic complexity is a conceptual precursor to entropy. Perhaps a good point of view of the role of this chapter is to consider Kolmogorov complexity as a way to think. One does not use the shortest computer program in practice because it may take infinitely long to find such a minimal program. But one can use very short, not necessarily minimal programs in practice; and the idea of finding such short programs leads to universal codes, a good basis for inductive inference, a formalization of Occam’s razor (“The simplest explanation is best”) and to fundamental understanding in physics, computer science, and communication theory. Before formalizing the notion of Kolmogorov complexity, let us give three strings as examples: 1. 0101010101010101010101010101010101010101010101010101010101010101 2. 0110101000001001111001100110011111110011101111001100100100001000 3. 1101111001110101111101101111101110101101111000101110010100111011 What are the shortest binary computer programs for each of these sequences? The first sequence is definitely simple. It consists of thirty-two 01’s. The second sequence looks random and passes most tests for randomness, but it is in fact the initial segment of the binary expansion of Again, this is a simple sequence. The third again looks random, except that the proportion of 1’s is not near . We shall assume that it is otherwise random. It turns out that by describing the number k of 1’s in the sequence, then giving the index of the sequence in a lexicographic ordering of those with this number of 1’s one can give a description of the sequence in roughly log bits. This again is substantially fewer than the n bits in the sequence. Again, we conclude that the sequence, random though it is, is simple. In this case, however, it is not as simple as the other two sequences, which have constant-length programs. In fact, its complexity is proportional to n. Finally, we can imagine a truly random sequence generated by pure coin flips. There are 2 n such sequences and they are all equally probable. It is highly likely that such a random sequence cannot be compressed (i.e., there is no better program for such a sequence than simply saying “Print the following: 0101100111010…0”). The reason for this is that there are not enough short programs to go around. Thus, the descriptive complexity of a truly random binary sequence is as long as the sequence itself. These are the basic ideas. It will remain to be shown that this notion of intrinsic complexity is computer independent (i.e., that the length of the shortest program does not depend on the computer). At first, this seems like nonsense. But it turns out to be true, up to an additive constant. And for long sequences of high complexity, this additive constant (which is the length of the preprogram that allows one computer to mimic the other) is negligible. 14.1 MODELS OF COMPUTATION To formalize the notions of algorithmic complexity, we first discuss acceptable models for computers. All but the most trivial computers are universal, in the sense that they can mimic the actions of other computers. We touch briefly on a certain canonical universal computer, the universal Turing machine , the conceptually simplest universal computer. In 1936, Turing was obsessed with the question of whether the thoughts in a living brain could be held equally well by a collection of inanimate parts. In short, could a machine think? By analyzing the human computational process, he posited some constraints on such a computer. Apparently, a human thinks, writes, thinks some more, writes, and so on. Consider a computer as a finite-state machine operating on a finite symbol set. (The symbols in an infinite symbol set cannot be distinguished in finite space.) A program tape, on which a binary program is written, is fed left to right into this finite-state machine. At each unit of time, the machine inspects the program tape, writes some symbols on a work tape, changes its state according to its transition table, and calls for more program. The operations of such a machine can be described by a finite list of transitions. Turing argued that this machine could mimic the computational ability of a human being. After Turing’s work, it turned out that every new computational system could be reduced to a Turing machine, and conversely. In particular, the familiar digital computer with its CPU, memory, and input output devices could be simulated by and could simulate a Turing machine. This led Church to state what is now known as Church’s thesis , which states that all (sufficiently complex) computational models are equivalent in the sense that they can compute the same family of functions. The class of functions they can compute agrees with our intuitive notion of effectively computable functions, that is, functions for which there is a finite prescription or program that will lead in a finite number of mechanically specified computational steps to the desired computational result. We shall have in mind throughout this chapter the computer illustrated in Figure 14.1 . At each step of the computation, the computer reads a symbol from the input tape, changes state according to its state transition table, possibly writes something on the work tape or output tape, and moves the program read head to the next cell of the program read tape. This machine reads the program from right to left only, never going back, and therefore the programs form a prefix-free set. No program leading to a halting computation can be the prefix of another such program. The restriction to prefix-free programs leads immediately to a theory of Kolmogorov complexity which is formally analogous to information theory. FIGURE 14.1. A Turing machine. We can view the Turing machine as a map from a set of finite-length binary strings to the set of finite- or infinite-length binary strings. In some cases, the computation does not halt, and in such cases the value of the function is said to be undefined. The set of functions f : {0, 1}* → {0, 1}* ∪ {0, 1} ∞ computable by Turing machines is called the set of partial recursive functions. 14.2 KOLMOGOROV COMPLEXITY: DEFINITIONS AND EXAMPLES Let x be a finite-length binary string and let u be a universal computer. Let l ( x ) denote the length of the string x. Let u ( p ) denote the output of the computer u when presented with a program p. We define the Kolmogorov (or algorithmic) complexity of a string x as the minimal description length of x. Definition The Kolmogorov complexity K u ( x ) of a string x with respect to a universal computer U is defined as (14.1) the minimum length over all programs that print x and halt. Thus, K u ( x ) is the shortest description length of x over all descriptions interpreted by computer u. A useful technique for thinking about Kolmogorov complexity is the following—if one person can describe a sequence to another person in such a manner as to lead unambiguously to a computation of that sequence in a finite amount of time, the number of bits in that communication is an upper bound on the Kolmogorov complexity. For example, one can say “Print out the first 1,239,875,981,825,931 bits of the square root of e. ” Allowing 8 bits per character (ASCII), we see that the unambiguous 73-symbol program above demonstrates that the Kolmogorov complexity of this huge number is no greater than (8)(73) = 584 bits. Most numbers of this length (more than a quadrillion bits) have a Kolmogorov complexity of nearly 1,239,875,981,825,931 bits. The fact that there is a simple algorithm to calculate the square root of e provides the saving in descriptive complexity. In the definition above, we have not mentioned anything about the length of x. If we assume that the computer already knows the length of x , we can define the conditional Kolmogorov complexity knowing l ( x ) as (14.2) This is the shortest description length if the computer U has the length of x made available to it. It should be noted that K u ( x|y ) is usually defined as K u ( x|y, y* ), where y* is the shortest program for y. This is to avoid certain slight asymmetries, but we will not use this definition here. We first prove some of the basic properties of Kolmogorov complexity and then consider various examples. Theorem 14.2.1 ( Universality of Kolmogorov complexity ) If U is a universal computer, for any other computer A there exists a constant c A such that (14.3) for all strings x {0, 1}*, and the constant c A does not depend on x . Proof: Assume that we have a program p A for computer A to print x . Thus, A ( p A ) = x . We can precede this program by a simulation program s A which tells computer u how to simulate computer A . Computer u will then interpret the instructions in the program for A , perform the corresponding calculations and print out x . The program for u is p = s A p A and its length is (14.4) where c A is the length of the simulation program. Hence, (14.5) for all strings x . The constant c A in the theorem may be very large. For example, A may be a large computer with a large number of functions built into the system. The computer u can be a simple microprocessor. The simulation program will, contain the details of the implementation of all these functions, in fact, all the software available on the large computer. The crucial point is that the length of this simulation program is independent of the length of x , the string to be compressed. For sufficiently long x , the length of this simulation program can be neglected, and we can discuss Kolmogorov complexity without talking about the constants. If A and u are both universal, we have (14.6) for all x . Hence, we will drop all mention of u in all further definitions. We will assume that the unspecified computer u is a fixed universal computer. Theorem 14.2.2 ( Conditional complexity is less than the length of the sequence ) (14.7) Proof: A program for printing x is Note that no bits are required to describe l since l is given. The program is self-delimiting because l ( x ) is provided and the end of the program is thus clearly defined. The length of this program is l ( x ) + c . Without knowledge of the length of the string, we will need an additional stop symbol or we can use a self-punctuating scheme like the one described in the proof of the next theorem. Theorem 14.2.3 ( Upper bound on Kolmogorov complexity ) (14.8) Proof: If the computer does not know l ( x ), the method of Theorem 14.2.2 does not apply. We must have some way of informing the computer when it has come to the end of the string of bits that describes the sequence. We describe a simple but inefficient method that uses a sequence 01 as a “comma.” Suppose that l ( x ) = n . To describe l ( x ), repeat every bit of the binary expansion of n twice; then end the description with a 01 so that the computer knows that it has come to the end of the description of n . For example, the number 5 (binary 101) will be described as 11001101. This description requires 2 log n + 2 bits. Thus, inclusion of the binary representation of l ( x ) does not add more than 2 log l ( x ) c bits to the length of the program, and we have the bound in the theorem. A more efficient method for describing n is to do so recursively. We first specify the number (log n ) of bits in the binary representation of n and then specify the actual bits of n . To specify log n , the length of the binary representation of n , we can use the inefficient method (2 log log n ) or the efficient method (log log n + · · ·). If we use the efficient method at each level, until we have a small number to specify, we can describe n in log n + log log n + log log log n · · · bits, where we continue the sum until the last positive term. This sum of iterated logarithms is sometimes written log* n . Thus, Theorem 14.2.3 can be improved to (14.9) We now prove that there are very few sequences with low complexity. Theorem 14.2.4 ( Lower bound on Kolmogorov complexity). The number of strings x with complexity K ( x ) < k satisfies (14.10) Proof: There are not very many short programs. If we list all the programs of length < k , we have (14.11) and the total number of such programs is (14.12) Since each program can produce only one possible output sequence, the number of sequences with complexity < k is less than 2 k . To avoid confusion and to facilitate exposition in the rest of this chapter, we shall need to introduce a special notation for the binary entropy function (14.13) Thus, when we write we will mean log − (1 − ) log (1 − n ) and not the entropy of random variable n . When there is no confusion, we shall simply write H ( p ) for H 0 ( p ). Now let us consider various examples of Kolmogorov complexity. The complexity will depend on the computer, but only up to an additive constant. To be specific, we consider a computer that can accept unambiguous commands in English (with numbers given in binary notation). We will use the inequality (14.14) which is proved in Lemma 17.5.1. Example 14.2.1 ( A sequence of n zeros ) If we assume that the computer knows n , a short program to print this string is Print the specified number of zeros. The length of this program is a constant number of bits. This program length does not depend on n . Hence, the Kolmogorov complexity of this sequence is c , and (14.15) Example 14.2.2 ( Kolmogorov complexity of π ) The first n bits of π can be calculated using a simple series expression. This program has a small constant length if the computer already knows n . Hence, (14.16) Example 14.2.3 ( Gotham weather ) Suppose that we want the computer to print out the weather in Gotham for n days. We can write a program that contains the entire sequence x = x 1 x 2 · · · x n , where x i = 1 indicates rain on day i . But this is inefficient, since the weather is quite dependent. We can devise various coding schemes for the sequence to take the dependence into account. A simple one is to find a Markov model to approximate the sequence (using the empirical transition probabilities) and then code the sequence using the Shannon code for this probability distribution. We can describe the empirical Markov transitions in O (log n ) bits and then use log bits to describe x , where p is the specified Markov probability. Assuming that the entropy of the weather is bit per day, we can describe the weather for n days using about n /5 bits, and hence (14.17) Example 14.2.4 ( Repeating sequence of the form 01010101…01 ) A short program suffices. Simply print the specified number of 01 pairs. Hence, (14.18) Example 14.2.5 ( Fractal ) A fractal is part of the Mandelbrot set and is generated by a simple computer program. For different points c in the complex plane, one calculates the number of iterations of the map Z n +1 = Z 2 n + c (starting with z 0 = 0) needed for | Z | to cross a particular threshold. The point c is then colored according to the number of iterations needed. Thus, the fractal is an example of an object that looks very complex but is essentially very simple. Its Kolmogorov complexity is essentially zero. Example 14.2.6 ( Mona Lisa ) We can make use of the many structures and dependencies in the painting. We can probably compress the image by a factor of 3 or so by using some existing easily described image compression algorithm. Hence, if n is the number of pixels in the image of the Mona Lisa, (14.19) Example 14.2.7 ( Integer n ) If the computer knows the number of bits in the binary representation of the integer, we need only provide the values of these bits. This program will have length c + log n . In general, the computer will not know the length of the binary representation of the integer. So we must inform the computer in some way when the description ends. Using the method to describe integers used to derive (14.9) , we see that the Kolmogorov complexity of an integer is bounded by (14.20) Example 14.2.8 ( Sequence of n bits with k ones ) Can we compress a sequence of n bits with k ones? Our first guess is no, since we have a series of bits that must be reproduced exactly. But consider the following program: Generate, in lexicographic order, all sequences with k ones; Of these sequences, print the i th sequence. This program will print out the required sequence. The only variables in the program are k (with known range {0, 1,…, n }) and i (with conditional range {1, 2, … }). The total length of this program is (14.21) (14.22) since by (14.14) for p = k/n and q = 1 − p and k ≠ 0 and k ≠ n . We have used log n bits to represent k . Thus, if , then (14.23) We can summarize Example 14.2.8 in the following theorem. Theorem 14.2.5 The Kolmogorov complexity of a binary string x is bounded by (14.24) Proof: Use the program described in Example 14.2.8. Remark Let x {0, 1}* be the data that we wish to compress, and consider the program p to be the compressed data. We will have succeeded in compressing the data only if l ( p ) < l ( x ), or (14.25) In general, when the length l ( x ) of the sequence x is small, the constants that appear in the expressions for the Kolmogorov complexity will over-whelm the contributions due to l ( x ). Hence, the theory is useful primarily when l ( x ) is very large. In such cases we can safely neglect the terms that do not depend on l ( x ). 14.3 KOLMOGOROV COMPLEXITY AND ENTROPY We now consider the relationship between the Kolmogorov complexity of a sequence of random variables and its entropy. In general, we show that the expected value of the Kolmogorov complexity of a random sequence is close to the Shannon entropy. First, we prove that the program lengths satisfy the Kraft inequality. Lemma 14.3.1 For any computer u , (14.26) Proof: If the computer halts on any program, it does not look any further for input. Hence, there cannot be any other halting program with this program as a prefix. Thus, the halting programs form a prefix-free set, and their lengths satisfy the Kraft inequality (Theorem 5.2.1). We now show that ≈ H ( X ) for i.i.d. processes with a finite alphabet. Theorem 14.3.1 ( Relationship of Kolmogorov complexity and entropy ) Let the stochastic process { X i } be drawn i.i.d. according to the probability mass function f ( x ), x X, where X is a finite alphabet. Let f ( x n ) = . Then there exists a constant c such that (14.27) for all n. Consequently , (14.28) Proof: Consider the lower bound. The allowed programs satisfy the prefix property, and thus their lengths satisfy the Kraft inequality. We assign to each x n the length of the shortest program p such that U ( p, n ) = x n . These shortest programs also satisfy the Kraft inequality. We know from the theory of source coding that the expected codeword length must be greater than the entropy. Hence, (14.29) We first prove the upper bound when χ is binary (i.e., X 1 , X 2 , … X n are i.i.d. ~ Bernoulli( θ )). Using the method of Theorem 14.2.5, we can bound the complexity of a binary string by (14.30) Hence, (14.31) (14.32) (14.33) where (a) follows from Jensen’s inequality and the concavity of the entropy. Thus, we have proved the upper bound in the theorem for binary processes. We can use the same technique for the case of a nonbinary finite alphabet. We first describe the type of the sequence (the empirical frequency of occurrence of each of the alphabet symbols as defined in Section 11.1) using (| X | − 1) log n bits (the frequency of the last symbol can be calculated from the frequencies of the rest). Then we describe the index of the sequence within the set of all sequences having the same type. The type class has less than 2 nH ( Px n ) elements (where Px n is the type of the sequence x n ) as shown in Chapter 11, and therefore the two-stage description of a string x n has length (14.34) Again, taking the expectation and applying Jensen’s inequality as in the binary case, we obtain (14.35) Dividing this by n yields the upper bound of the theorem. Removing the conditioning on the length of the sequence is straight-forward. By similar arguments, we can show that (14.36) for all n . The lower bound follows from the fact that K ( x n ) is also a prefix-free code for the source, and the upper bound can be derived from the fact that K ( x n ) ≤ K ( x n |n ) + 2 log n + c . Thus, (14.37) and the compressibility achieved by the computer goes to the entropy limit. 14.4 KOLMOGOROV COMPLEXITY OF INTEGERS In Section 14.3 we defined the Kolmogorov complexity of a binary string as the length of the shortest program for a universal computer that prints out that string. We can extend that definition to define the Kolmogorov complexity of an integer to be the Kolmogorov complexity of the corresponding binary string. Definition The Kolmogorov complexity of an integer n is defined as (14.38) The properties of the Kolmogorov complexity of integers are very similar to those of the Kolmogorov complexity of bit strings. The following properties are immediate consequences of the corresponding properties for strings. Theorem 14.4.1 For universal computers A and u , (14.39) Also, since any number can be specified by its binary expansion, we have the following theorem. Theorem 14.4.2 (14.40) Theorem 14.4.3 There are an infinite number of integers n such that K ( n ) > log n . Proof: We know from Lemma 14.3.1 that (14.41) and (14.42) But if K ( n ) < log n for all n > n 0 , then (14.43) which is a contradiction. 14.5 ALGORITHMICALLY RANDOM AND INCOMPRESSIBLE SEQUENCES From the examples in Section 14.2, it is clear that there are some long sequences that are simple to describe, like the first million bits of π . By the same token, there are also large integers that are simple to describe, such as or (100!)!. We now show that although there are some simple sequences, most sequences do not have simple descriptions. Similarly, most integers are not simple. Hence, if we draw a sequence at random, we are likely to draw a complex sequence. The next theorem shows that the probability that a sequence can be compressed by more than k bits is no greater than 2 − k . Theorem 14.5.1 Let X 1 , X 2 ,…, X n be drawn according to a Bernoulli ( ) process. Then (14.44) Proof: (14.45) (14.46) (14.47) (14.48) Thus, most sequences have a complexity close to their length. For example, the fraction of sequences of length n that have complexity less than n − 5 is less than 1/32. This motivates the following definition: Definition A sequence x 1 , x 2 ,…, x n is said to be algorithmically random if (14.49) Note that by the counting argument, there exists, for each n , at least one sequence x n such that (14.50) Definition We call an infinite string x incompressible if (14.51) Theorem 14.5.2 ( Strong law of large numbers for incompressible sequences ) If a string x 1 , x 2 … is incompressible, it satisfies the law of large numbers in the sense that (14.52) Hence the proportions of 0’s and 1’s in any incompressible string are almost equal. Proof: Let denote the proportion of 1’s in x 1 x 2 ,… x n . Then using the method of Example 14.2, one can write a program of length nH 0 ( θ n ) + 2 log ( nθ n ) + c to print x n . Thus, (14.53) By the incompressibility assumption, we also have the lower bound for large enough n , (14.54) Thus, (14.55) Inspection of the graph of H 0 ( p ) ( Figure 14.2 ) shows that θ n is close to for large n . Specifically, the inequality above implies that FIGURE 14.2. H 0 ( p ) vs. p . (14.56) where δ n is chosen so that (14.57) which implies that δ n → 0 as n → ∞. Thus, as n → ∞. We have now proved that incompressible sequences look random in the sense that the proportion of 0’s and 1’s are almost equal. In general, we can show that if a sequence is incompressible, it will satisfy all computable statistical tests for randomness. (Otherwise, identification of the test that x fails will reduce the descriptive complexity of x , yielding a contradiction.) In this sense, the algorithmic test for randomness is the ultimate test, including within it all other computable tests for randomness. We now prove a related law of large numbers for the Kolmogorov complexity of Bernoulli( θ ) sequences. The Kolmogorov complexity of a sequence of binary random variables drawn i.i.d. according to a Bernoulli( θ ) process is close to the entropy H 0 ( θ ). In Theorem 14.3.1 we proved that the expected value of the Kolmogorov complexity of a random Bernoulli sequence converges to the entropy [i.e., ( X 1 X 2 … X n | n ) → H 0 ( θ )]. Now we remove the expectation. Theorem 14.5.3 Let X 1 , X 2 ,…, X n be drawn i.i.d. ~ Bernoulli ( θ ). Then (14.58) Proof: Let be the proportion of 1’s in X 1 , X 2 ,…, X n . Then using the method described in (14.23) , we have (14.59) and since by the weak law of large numbers, n → θ in probability, we have (14.60) Conversely, we can bound the number of sequences with complexity significantly lower than the entropy. From the AEP, we can divide the set of sequences into the typical set and the nontypical set. There are at least sequences in the typical set. At most of these typical sequences can have a complexity less than n ( H 0 ( θ ) − c ). The probability that the complexity of the random sequence is less than n ( H 0 ( θ ) − c ) is (14.61) (14.62) (14.63) (14.64) which is arbitrarily small for appropriate choice of , n and c . Hence with high probability, the Kolmogorov complexity of the random sequence is close to the entropy, and we have (14.65) 14.6 UNIVERSAL PROBABILITY Suppose that a computer is fed a random program. Imagine a monkey sitting at a keyboard and typing the keys at random. Equivalently, feed a series of fair coin flips into a universal Turing machine. In either case, most strings will not make sense to the computer. If a person sits at a terminal and types keys at random, he will probably get an error message (i.e., the computer will print the null string and halts). But with a certain probability she will hit on something that makes sense. The computer will then print out something meaningful. Will this output sequence look random? From our earlier discussions, it is clear that most sequences of length n have complexity close to n . Since the probability of an input program p is 2 − l ( p ) , shorter programs are much more probable than longer ones; and when they produce long strings, shorter programs do not produce random strings; they produce strings with simply described structure. The probability distribution on the output strings is far from uniform. Under the computer-induced distribution, simple strings are more likely than complicated strings of the same length. This motivates us to define a universal probability distribution on strings as follows: Definition The universal probability of a string x is (14.66) which is the probability that a program randomly drawn as a sequence of fair coin flips p 1 , p 2 , … will print out the string x . This probability is universal in many senses. We can consider it as the probability of observing such a string in nature; the implicit belief is that simpler strings are more likely than complicated strings. For example, if we wish to describe the laws of physics, we might consider the simplest string describing the laws as the most likely. This principle, known as Occam’s Razor, has been a general principle guiding scientific research for centuries: If there are many explanations consistent with the observed data, choose the simplest. In our framework, Occam’s Razor is equivalent to choosing the shortest program that produces a given string. This probability mass function is called universal because of the following theorem. Theorem 14.6.1 For every computer A , (14.67) for every string x {0, 1}*, where the constant c′ A depends only on U and A. Proof: From the discussion of Section 14.2, we recall that for every program p ’ for A that prints x , there exists a program p for U of length not more than l ( p ’) + c A produced by prefixing a simulation program for A . Hence, (14.68) Any sequence drawn according to a computable probability mass function on binary strings can be considered to be produced by some computer A acting on a random input (via the probability inverse transformation acting on a random input). Hence, the universal probability distribution includes a mixture of all computable probability distributions. Remark ( Bounded likelihood ratio ). In particular, Theorem 14.6.1 guarantees that a likelihood ratio test of the hypothesis that X is drawn according to P u versus the hypothesis that it is drawn according to P A will have bounded likelihood ratio. If U and A are universal, the P u ( x )/ P A ( x ) is bounded away from 0 and infinity for all x . This is in contrast to other simple hypothesis-testing problems (like Bernoulli( θ ) versus Bernoulli( θ 2 )), where the likelihood ratio goes to 0 or ∞ as the sample size goes to infinity. Apparently, P u , which is a mixture of all computable distributions, can never be rejected completely as the true distribution of any data drawn according to some computable probability distribution. In that sense we cannot reject the possibility that the universe is the output of monkeys typing at a computer. However, we can reject the hypothesis that the universe is random (monkeys with no computer). In Section 14.11 we prove that (14.69) thus showing that K ( x ) and log have equal status as universal algorithmic complexity measures. This is especially interesting since log is the ideal codeword length (the Shannon codeword length) with respect to the universal probability distribution P u ( x ). We conclude this section with an example of a monkey at a typewriter vs. a monkey at a computer keyboard. If the monkey types at random on a typewriter, the probability that it types out all the works of Shakespeare (assuming that the text is 1 million bits long) is 2 −1,000,000 . If the monkey sits at a computer terminal, however, the probability that it types out Shakespeare is now 2 − K (Shakespeare) ≈ 2 −250,000 , which although extremely small is still exponentially more likely than when the monkey sits at a dumb typewriter. The example indicates that a random input to a computer is much more likely to produce “interesting” outputs than a random input to a typewriter. We all know that a computer is an intelligence amplifier. Apparently, it creates sense from nonsense as well. 14.7 THE HALTING PROBLEM AND THE NONCOMPUTABILITY OF KOLMOGOROV COMPLEXITY Consider the following paradoxical statement: This statement is false. This paradox is sometimes stated in a two-statement form: The next statement is false. The preceding statement is true. These paradoxes are versions of what is called the Epimenides liar paradox , and it illustrates the pitfalls involved in self-reference. In 1931, Gödel used this idea of self-reference to show that any interesting system of mathematics is not complete; there are statements in the system that are true but that cannot be proved within the system. To accomplish this, he translated theorems and proofs into integers and constructed a statement of the above form, which can therefore not be proved true or false. The halting problem in computer science is very closely connected with Gödel’s incompleteness theorem. In essence, it states that for any computational model, there is no general algorithm to decide whether a program will halt or not (go on forever). Note that it is not a statement about any specific program. Quite clearly, there are many programs that can easily be shown to halt or go on forever. The halting problem says that we cannot answer this question for all programs. The reason for this is again the idea of self-reference. To a practical person, the halting problem may not be of any immediate significance, but it has great theoretical importance as the dividing line between things that can be done on a computer (given unbounded memory and time) and things that cannot be done at all (such as proving all true statements in number theory). Gödel’s incompleteness theorem is one of the most important mathematical results of the twentieth century, and its consequences are still being explored. The halting problem is an essential example of Gödel’s incompleteness theorem. One of the consequences of the nonexistence of an algorithm for the halting problem is the noncomputability of Kolmogorov complexity. The only way to find the shortest program in general is to try all short programs and see which of them can do the job. However, at any time some of the short programs may not have halted and there is no effective (finite mechanical) way to tell whether or not they will halt and what they will print out. Hence, there is no effective way to find the shortest program to print a given string. The noncomputability of Kolmogorov complexity is an example of the Berry paradox . The Berry paradox asks for the shortest number not nameable in under 10 words. A number like 1,101,121 cannot be a solution since the defining expression itself is less than 10 words long. This illustrates the problems with the terms nameable and describable; they are too powerful to be used without a strict meaning. If we restrict ourselves to the meaning “can be described for printing out on a computer,” we can resolve Berry’s paradox by saying that the smallest number not describable in less than 10 words exists but is not computable. This “description” is not a program for computing the number. E. F. Beckenbach pointed out a similar problem in the classification of numbers as dull or interesting; the smallest dull number must be interesting. As stated at the beginning of the chapter, one does not really anticipate that practitioners will find the shortest computer program for a given string. The shortest program is not computable, although as more and more programs are shown to produce the string, the estimates from above of the Kolmogorov complexity converge to the true Kolmogorov complexity. (The problem, of course, is that one may have found the shortest program and never know that no shorter program exists.) Even though Kolmogorov complexity is not computable, it provides a framework within which to consider questions of randomness and inference. 14.8 Ω In this section we introduce Chaitin’s mystical, magical number, Ω, which has some extremely interesting properties. Definition (14.70) Note that Ω = Pr( U ( p ) halts), the probability that the given universal computer halts when the input to the computer is a binary string drawn according to a Bernoulli( ) process. Since the programs that halt are prefix-free, their lengths satisfy the Kraft inequality, and hence the sum above is always between 0 and 1. Let Ω n = . ω 1 ω 2 … ω n denote the first n bits of Ω. The properties of Ω are as follows: 1. Ω is noncomputable . There is no effective (finite, mechanical) way to check whether arbitrary programs halt (the halting problem), so there is no effective way to compute Ω. 2. Ω is a “philosopher’s stone” . Knowing Ω to an accuracy of n bits will enable us to decide the truth of any provable or finitely refutable mathematical theorem that can be written in less than n bits. Actually, all that this means is that given n bits of Ω, there is an effective procedure to decide the truth of n -bit theorems; the procedure may take an arbitrarily long (but finite) time. Of course, without knowing Ω it is not possible to check the truth or falsity of every theorem by an effective procedure (Gödel’s incompleteness theorem). The basic idea of the procedure using n bits of Ω is simple: We run all programs until the sum of the masses 2 − l ( p ) contributed by programs that halt equals or exceeds Ω n = 0. ω 1 ω 2 … ω n , the truncated version of Ω that we are given. Then, since (14.71) we know that the sum of all further contributions of the form 2 − l ( p ) to Ω from programs that halt must also be less than 2 − n . This implies that no program of length ≤ n that has not yet halted will ever halt, which enables us to decide the halting or nonhalting of all programs of length ≤ n . To complete the proof, we must show that it is possible for a computer to run all possible programs in “parallel” in such a way that any program that halts will eventually be found to halt. First, list all possible programs, starting with the null program, Λ: (14.72) Then let the computer execute one clock cycle of Λ for the first cycle. In the next cycle, let the computer execute two clock cycles of Λ and two clock cycles of the program 0. In the third cycle, let it execute three clock cycles of each of the first three programs, and so on. In this way, the computer will eventually run all possible programs and run them for longer and longer times, so that if any program halts, it will eventually be discovered to halt. The computer keeps track of which program is being executed and the cycle number so that it can produce a list of all the programs that halt. Thus, we will ultimately know whether or not any program of less than n bits will halt. This enables the computer to find any proof of the theorem or a counterexample to the theorem if the theorem can be stated in less than n bits. Knowledge of Ω turns previously unprovable theorems into provable theorems. Here Ω acts as an oracle. Although Ω seems magical in this respect, there are other numbers that carry the same information. For example, if we take the list of programs and construct a real number in which the i th bit indicates whether program i halts, this number can also be used to decide any finitely refutable question in mathematics. This number is very dilute (in information content) because one needs approximately 2 n bits of this indicator function to decide whether or not an n -bit program halts. Given 2 n bits, one can tell immediately without any computation whether or not any program of length less than n halts. However, Ω is the most compact representation of this information since it is algorithmically random and incompressible. What are some of the questions that we can resolve using Ω? Many of the interesting problems in number theory can be stated as a search for a counterexample. For example, it is straightforward to write a program that searches over the integers x, y, z , and n and halts only if it finds a counterexample to Fermat’s last theorem, which states that (14.73) has no solution in integers for n ≥ 3. Another example is Goldbach’s conjecture , which states that any even number is a sum of two primes. Our program would search through all the even numbers starting with 2, check all prime numbers less than it and find a decomposition as a sum of two primes. It will halt if it comes across an even number that does not have such a decomposition. Knowing whether this program halts is equivalent to knowing the truth of Goldbach’s conjecture. We can also design a program that searches through all proofs and halts only when it finds a proof of the theorem required. This program will eventually halt if the theorem has a finite proof. Hence knowing n bits of Ω, we can find the truth or falsity of all theorems that have a finite proof or are finitely refutable and which can be stated in less than n bits. 3. Ω is algorithmically random. Theorem 14.8.1 Ω cannot be compressed by more than a constant; that is, there exists a constant c such that (14.74) Proof: We know that if we are given n bits of Ω, we can determine whether or not any program of length ≤ n halts. Using K ( ω 1 ω 2 … ω n ) bits, we can calculate n bits of Ω, and then we can generate a list of all programs of length ≤ n that halt, together with their corresponding outputs. We find the first string x 0 that is not on this list. The string x 0 is then the shortest string with Kolmogorov complexity K ( x 0 ) > n . The complexity of this program to print x 0 is K (Ω n ) + c which must be at least as long as the shortest program for x 0 . Consequently, (14.75) for all n . Thus, K ( ω 1 ω 2 … ω n ) > n − c , and Ω cannot be compressed by more than a constant. 14.9 UNIVERSAL GAMBLING Suppose that a gambler is asked to gamble sequentially on sequences x {0, 1}*. He has no idea of the origin of the sequence. He is given fair odds (2-for-1) on each bit. How should he gamble? If he knew the distribution of the elements of the string, he might use proportional betting because of its optimal growth-rate properties, as shown in Chapter 6. If he believes that the string occurred naturally, it seems intuitive that simpler strings are more likely than complex ones. Hence, if he were to extend the idea of proportional betting, he might bet according to the universal probability of the string. For reference, note that if the gambler knows the string x in advance, he can increase his wealth by a factor of 2 l ( x ) simply by betting all his wealth each time on the next symbol of x . Let the wealth S ( x ) associated with betting scheme b ( x ), ∑ b ( x ) = 1, be given by (14.76) Suppose that the gambler bets b ( x ) = 2 − K ( x ) on a string x . This betting strategy can be called universal gambling. We note that the sum of the bets (14.77) and he will not have used all his money. For simplicity, let us assume that he throws the rest away. For example, the amount of wealth resulting from a bet b (0110) on a sequence x = 0110 is 2 l ( x ) b ( x ) = 2 4 b (0110) plus the amount won on all bets b (0110…) on sequences that extend x . Then we have the following theorem: Theorem 14.9.1 The logarithm of the wealth a gambler achieves on a sequence using universal gambling plus the complexity of the sequence is no smaller than the length of the sequence, or (14.78) Remark This is the counterpart of the gambling conservation theorem W * + H = log m from Chapter 6. Proof: The proof follows directly from the universal gambling scheme, b ( x ) = 2 − K ( x ) , since (14.79) where means that x is a prefix of x’ . Taking logarithms establishes the theorem. The result can be understood in many ways. For infinite sequences x with finite Kolmogorov complexity, (14.80) for all l . Since 2 l is the most that can be won in l gambles at fair odds, this scheme does asymptotically as well as the scheme based on knowing the sequence in advance. For example, if x = π 1 π 2 … π n …, the digits in the expansion of π , the wealth at time n will be S n = S ( x n ) ≥ 2 n−c for all n . If the string is actually generated by a Bernoulli process with parameter p , then (14.81) which is the same to first order as the rate achieved when the gambler knows the distribution in advance, as in Chapter 6. From the examples we see that the universal gambling scheme on a random sequence does asymptotically as well as a scheme that uses prior knowledge of the true distribution. 14.10 OCCAM’S RAZOR In many areas of scientific research, it is important to choose among various explanations of data observed. After choosing the explanation, we wish to assign a confidence level to the predictions that ensue from the laws that have been deduced. For example, Laplace considered the probability that the sun will rise again tomorrow given that it has risen every day in recorded history. Laplace’s solution was to assume that the rising of the sun was a Bernoulli( θ ) process with unknown parameter θ . He assumed that θ was uniformly distributed on the unit interval. Using the observed data, he calculated the posterior probability that the sun will rise again tomorrow and found that it was (14.82) (14.83) which he put forward as the probability that the sun will rise on day n + 1 given that it has risen on days 1 through n . Using the ideas of Kolmogorov complexity and universal probability, we can provide an alternative approach to the problem. Under the universal probability, let us calculate the probability of seeing a 1 next after having observed n 1’s in the sequence so far. The conditional probability that the next symbol is a 1 is the ratio of the probability of all sequences with initial segment 1 n and next bit equal to 1 to the probability of all sequences with initial segment 1 n . The simplest programs carry most of the probability; hence we can approximate the probability that the next bit is a 1 with the probability of the program that says “Print 1’s forever.” Thus, (14.84) Estimating the probability that the next bit is 0 is more difficult. Since any program that prints 1 n 0 … yields a description of n , its length should at least be K ( n ), which for most n is about log n + 0 (log log n ), and hence ignoring second-order terms, we have (14.85) Hence, the conditional probability of observing a 0 next is (14.86) which is similar to the result p (0|1 n ) = 1/( n + 1) derived by Laplace. This type of argument is a special case of Occam’s Razor, a general principle governing scientific research, weighting possible explanations by their complexity. William of Occam said “Nunquam ponenda est pluralitas sine necesitate”: Explanations should not be multiplied beyond necessity [516]. In the end, we choose the simplest explanation that is consistent with the data observed. For example, it is easier to accept the general theory of relativity than it is to accept a correction factor of c / r 3 to the gravitational law to explain the precession of the perihelion of Mercury, since the general theory explains more with fewer assumptions than does a “patched” Newtonian theory. 14.11 KOLMOGOROV COMPLEXITY AND UNIVERSAL PROBABILITY We now prove an equivalence between Kolmogorov complexity and universal probability. We begin by repeating the basic definitions. (14.87) (14.88) Theorem 14.11.1 ( Equivalence of K ( x ) and log .) There exists a constant c, independent of x, such that (14.89) for all strings x. Thus, the universal probability of a string x is determined essentially by its Kolmogorov complexity . Remark This implies that K ( x ) and log have equal status as universal complexity measures, since (14.90) Recall that the complexity defined with respect to two different computers K u and K u′ are essentially complexity measures if | K u ( x ) − K u′ ( x )| is bounded. Theorem 14.11.1 shows that K u ( x ) and log are essentially equivalent complexity measures. Notice the striking similarity between the relationship of K ( x ) and log in Kolmogorov complexity and the relationship of H ( X ) and log in information theory. The ideal Shannon code length assignment l ( x ) = log achieves an average description length H ( X ), while in Kolmogorov complexity theory, the ideal description length log is almost equal to K ( X ). Thus, log is the natural notion of descriptive complexity of x in algorithmic as well as probabilistic settings. The upper bound in (14.90) is obvious from the definitions, but the lower bound is more difficult to prove. The result is very surprising, since there are an infinite number of programs that print x . From any program it is possible to produce longer programs by padding the program with irrelevant instructions. The theorem proves that although there are an infinite number of such programs, the universal probability is essentially determined by the largest term, which is 2 − K ( x ) . If P u ( x ) is large, K ( x ) is small, and vice versa. However, there is another way to look at the upper bound that makes it less surprising. Consider any computable probability mass function on strings p ( x ). Using this mass function, we can construct a Shannon-Fano code (Section 5.9) for the source and then describe each string by the corresponding codeword, which will have length log Hence, for any computable distribution, we can construct a description of a string using not more than log bits, which is an upper bound on the Kolmogorov complexity K ( x ). Even though P u ( x ) is not a computable probability mass function, we are able to finesse the problem using the rather involved tree construction procedure described below. Proof: ( of Theorem 14.11.1 ). The first inequality is simple. Let p * be the shortest program for x . Then (14.91) as we wished to show. We can rewrite the second inequality as (14.92) Our objective in the proof is to find a short program to describe the strings that have high P u ( x ). An obvious idea is some kind of Huffman coding based on P u ( x ), but P u ( x ) cannot be calculated effectively, hence a procedure using Huffman coding is not implementable on a computer. Similarly, the process using the Shannon–Fano code also cannot be implemented. However, if we have the Shannon-Fano code tree, we can reconstruct the string by looking for the corresponding node in the tree. This is the basis for the following tree construction procedure. To overcome the problem of noncomputability of P u ( x ), we use a modified approach, trying to construct a code tree directly. Unlike Huffman coding, this approach is not optimal in terms of minimum expected codeword length. However, it is good enough for us to derive a code for which each codeword for x has a length that is within a constant of log Before we get into the details of the proof, let us outline our approach. We want to construct a code tree in such a way that strings with high probability have low depth. Since we cannot calculate the probability of a string, we do not know a priori the depth of the string on the tree. Instead, we assign x successively to the nodes of the tree, assigning x to nodes closer and closer to the root as our estimate of P u ( x ) improves. We want the computer to be able to recreate the tree and use the lowest depth node corresponding to the string x to reconstruct the string. We now consider the set of programs and their corresponding outputs {( p, x )}. We try to assign these pairs to the tree. But we immediately come across a problem—there are an infinite number of programs for a given string, and we do not have enough nodes of low depth. However, as we shall show, if we trim the list of program-output pairs, we will be able to define a more manageable list that can be assigned to the tree. Next, we demonstrate the existence of programs for x of length log . Tree construction procedure: For the universal computer u , we simulate all programs using the technique explained in Section 14.8. We list all binary programs: (14.93) Then let the computer execute one clock cycle of Λ for the first stage. In the next stage, let the computer execute two clock cycles of Λ and two clock cycles of the program 0. In the third stage, let the computer execute three clock cycles of each of the first three programs, and so on. In this way, the computer will eventually run all possible programs and run them for longer and longer times, so that if any program halts, it will be discovered to halt eventually. We use this method to produce a list of all programs that halt in the order in which they halt, together with their associated outputs. For each program and its corresponding output, ( P k , x k ), we calculate n k , which is chosen so that it corresponds to the current estimate of P u ( x ). Specifically, (14.94) where (14.95) Note that u ( x k ) ↑ P u ( x ) on the subsequence of times k such that x k = x . We are now ready to construct a tree. As we add to the list of triplets, ( p k , x k , n k ), of programs that halt, we map some of them onto nodes of a binary tree. For purposes of the construction, we must ensure that all the n i ’s corresponding to a particular x k are distinct. To ensure this, we remove from the list all triplets that have the same x and n as a previous triplet. This will ensure that there is at most one node at each level of the tree that corresponds to a given x . Let {( p′ i , x′ i , n′ i ) : i = 1, 2, 3, …} denote the new list. On the winnowed list, we assign the triplet ( p′ k , x′ k , n′ k ) to the first available node at level n′ k + 1. As soon as a node is assigned, all of its descendants become unavailable for assignment. (This keeps the assignment prefix-free.) We illustrate this by means of an example: (14.96) We note that the string x = (1110) appears in positions 1, 3 and 5 in the list, but n 3 = n 5 . The estimate of the probability u (1110) has not jumped sufficiently for ( p 5 , x 5 , n 5 ) to survive the cut. Thus the winnowed list becomes (14.97) The assignment of the winnowed list to nodes of the tree is illustrated in Figure 14.3 . FIGURE 14.3. Assignment of nodes. In the example, we are able to find nodes at level n k + 1 to which we can assign the triplets. Now we shall prove that there are always enough nodes so that the assignment can be completed. We can perform the assignment of triplets to nodes if and only if the Kraft inequality is satisfied. We now drop the primes and deal only with the winnowed list illustrated in (14.97) . We start with the infinite sum in the Kraft inequality and split it according to the output strings: (14.98) We then write the inner sum as (14.99) (14.100) (14.101) (14.102) (14.103) where (14.100) is true because there is at most one node at each level that prints out a particular x . More precisely, the n k ’s on the winnowed list for a particular output string x are all different integers. Hence, (14.104) and we can construct a tree with the nodes labeled by the triplets. If we are given the tree constructed above, it is easy to identify a given x by the path to the lowest depth node that prints x . Call this node (By construction, To use this tree in a program to print x , we specify and ask the computer to execute the foregoing simulation of all programs. Then the computer will construct the tree as described above and wait for the particular node to be assigned. Since the computer executes the same construction as the sender, eventually the node will be assigned. At this point, the computer will halt and print out the x assigned to that node. This is an effective (finite, mechanical) procedure for the computer to reconstruct x . However, there is no effective procedure to find the lowest depth node corresponding to x . All that we have proved is that there is an (infinite) tree with a node corresponding to x at level . But this accomplishes our purpose. With reference to the example, the description of x = 1110 is the path to the node ( p 3 , x 3 , n 3 ) (i.e., 01), and the description of x = 111.1 is the path 00001. If we wish to describe the string 1110, we ask the computer to perform the (simulation) tree construction until node 01 is assigned. Then we ask the computer to execute the program corresponding to node 01 (i.e., p 3 ). The output of this program is the desired string, x = 1110. The length of the program to reconstruct x is essentially the length of the description of the position of the lowest depth node corresponding to x in the tree. The length of this program for x is l ( ) + c , where (14.105) and hence the complexity of x satisfies (14.106) 14.12 KOLMOGOROV SUFFICIENT STATISTIC Suppose that we are given a sample sequence from a Bernoulli( θ ) process. What are the regularities or deviations from randomness in this sequence? One way to address the question is to find the Kolmogorov complexity K ( x n | n ), which we discover to be roughly nH 0 ( θ ) + log n + c . Since, for θ ≠ , this is much less than n , we conclude that x n has structure and is not randomly drawn Bernoulli( ). But what is the structure? The first attempt to find the structure is to investigate the shortest program p * for x n . But the shortest description of p * is about as long as p * itself; otherwise, we could further compress the description of x n , contradicting the minimality of p *. So this attempt is fruitless. A hint at a good approach comes from an examination of the way in which p * describes x n . The program “The sequence has k 1’s; of such sequences, it is the i th” is optimal to first order for Bernoulli( θ ) sequences. We note that it is a two-stage description, and all of the structure of the sequence is captured in the first stage. Moreover, x n is maximally complex given the first stage of the description. The first stage, the description of k , requires log( n + 1) bits and defines a set S = { x {0, 1} n : ∑ x i = k }. The second stage requires log bits and reveals nothing extraordinary about x n . We mimic this process for general sequences by looking for a simple set S that contains x n . We then follow it with a brute-force description of x n in S using log | S | bits. We begin with a definition of the smallest set containing x n that is describable in no more than k bits. Definition The Kolmogorov structure function K k ( x n | n ) of a binary string x {0, 1} n is defined as (14.107) The set S is the smallest set that can be described with no more than k bits and which includes x n . By U ( p, n ) = S , we mean that running the program p with data n on the universal computer U will print out the indicator function of the set S . Definition For a given small constant c , let k * be the least k such that (14.108) Let S ** be the corresponding set and let p ** be the program that prints out the indicator function of S **. Then we shall say that p ** is a Kolmogorov minimal sufficient statistic for x n . Consider the programs p * describing sets S * such that (14.109) All the programs p * are “sufficient statistics” in that the complexity of x n given S * is maximal. But the minimal sufficient statistic is the shortest “sufficient statistic.” The equality in the definition above is up to a large constant depending on the computer U . Then k * corresponds to the least k for which the two-stage description of x n is as good as the best single-stage description of x n . The second stage of the description merely provides the index of x n within the set S **; this takes K k ( x n \ n ) bits if x n is conditionally maximally complex given the set S **. Hence the set S ** captures all the structure within x n . The remaining description of x n within S ** is essentially the description of the randomness within the string. Hence S ** or p ** is called the Kolmogorov sufficient statistic for x n . This is parallel to the definition of a sufficient statistic in mathematical statistics. A statistic T is said to be sufficient for a parameter θ if the distribution of the sample given the sufficient statistic is independent of the parameter; that is, (14.110) forms a Markov chain in that order. For the Kolmogorov sufficient statistic, the program p ** is sufficient for the “structure” of the string x n , the remainder of the description of x n is essentially independent of the “structure” of x n . In particular, x n is maximally complex given S **. A typical graph of the structure function is illustrated in Figure 14.4 . When k = 0, the only set that can be described is the entire set {0, 1} n , so that the corresponding log set size is n . As we increase k , the size of the set drops rapidly until FIGURE 14.4. Kolmogorov sufficient statistic. (14.111) After this, each additional bit of k reduces the set by half, and we proceed along the line of slope − 1 until k = K ( x n | n ). For k ≥ K ( x n | n ), the smallest set that can be described that includes x n is the singleton { x n }, and hence K k ( x n | n ) = 0. We will now illustrate the concept with a few examples. 1. Bernoulli(θ) sequence. Consider a sample of length n from a Bernoulli sequence with an unknown parameter θ . As discussed in Example 14.2, we can describle this sequence with nH bits using a two stage description where we describe k in the first stage (using log n bits) and then describe the sequence within all sequences with k ones (using log bits). However, we can use an even shorter first stage description. Instead of describing k exactly, we divide the range of k into bins and describe k only to an accuracy of using log n bits. Then we describe the actual sequence among all sequences whose type is in the same bin as k . The size of the set of all sequences with l ones, is by Stirling’s formula, so the total description length is still but the description length of the Kolmogorov sufficient statistics is k * ≈ log n . FIGURE 14.5. Kolmogorov sufficient statistic for a Bernoulli sequence. 2. Sample from a Markov chain. In the same vein as the preceding example, consider a sample from a first-order binary Markov chain. In this case again, p ** will correspond to describing the Markov type of the sequence (the number of occurrences of 00’s, 01’s, 10’s, and 11’s in the sequence); this conveys all the structure in the sequence. The remainder of the description will be the index of the sequence in the set of all sequences of this Markov type. Hence, in this case, k * ≈ 2 ( log n ) = log n , corresponding to describing two elements of the conditional joint type to appropriate accuracy. (The other elements of the conditional joint type can be determined from these two.) 3. Mona Lisa. Consider an image that consists of a gray circle on a white background. The circle is not uniformly gray but Bernoulli with parameter θ . This is illustrated in Figure 14.6 . In this case, the best two-stage description is first to describe the size and position of the circle and its average gray level and then to describe the index of the circle among all the circles with the same gray level. Assuming an n -pixel image (of size by , there are about n + 1 possible gray levels, and there are about 3 distinguishable circles. Hence, k * ≈ log n in this case. FIGURE 14.6. Mona Lisa. 14.13 MINIMUM DESCRIPTION LENGTH PRINCIPLE A natural extension of Occam’s razor occurs when we need to describe data drawn from an unknown distribution. Let X 1 , X 2 ,…, X n be drawn i.i.d. according to probability mass function p ( x ). We assume that we do not know p ( x ), but know that p ( x ) , a class of probability mass functions. Given the data, we can estimate the probability mass function in that best fits the data. For simple classes (e.g., if has only finitely many distributions), the problem is straightforward, and the maximum likelihood procedure [i.e., find that maximizes ( X 1 , X 2 ,…, X n )] works well. However, if the class is rich enough, there is a problem of overfitting the data. For example, if X 1 , X 2 ,…, X n , are continuous random variables, and if is the set of all probability distributions, the maximum likelihood estimator given X 1 , X 2 ,…, X n is a distribution that places a single mass point of weight at each observed value. Clearly, this estimate is too closely tied to actual observed data and does not capture any of the structure of the underlying distribution. To get around this problem, various methods have been applied. In the simplest case, the data are assumed to come from some parametric distribution (e.g., the normal distribution), and the parameters of the distribution are estimated from the data. To validate this method, the data should be tested to check whether the distribution “looks” normal, and if the data pass the test, we could use this description of the data. A more general procedure is to take the maximum likelihood estimate and smooth it out to obtain a smooth density. With enough data, and appropriate smoothness conditions, it is possible to make good estimates of the original density. This process is called kernel density estimation. However, the theory of Kolmogorov complexity (or the Kolmogorov sufficient statistic) suggests a different procedure: Find the p that minimizes (14.112) This is the length of a two-stage description of the data, where we first describe the distribution p and then, given the distribution, construct the Shannon code and describe the data using bits. This procedure is a special case of what is termed the minimum description length (MDL) principle: Given data and a choice of models, choose the model such that the description of the model plus the conditional description of the data is as short as possible. SUMMARY Definition . The Kolmogorov complexity K ( x ) of a string x is (14.113) (14.114) Universality of Kolmogorov complexity. There exists a universal computer u such that for any other computer A , (14.115) for any string x , where the constant c A does not depend on x . If u and A are universal, | K u ( x ) − K A ( x )| ≤ c for all x . Upper bound on Kolmogorov complexity (14.116) (14.117) Kolmogorov complexity and entropy. If X 1 , X 2 , … are i.i.d. integer-valued random variables with entropy H , there exists a constant c such that for all n , (14.118) Lower bound on Kolmogorov complexity. There are no more than 2 k strings x with complexity K ( x ) < k . If X 1 , X 2 ,…, X n are drawn according to a Bernoulli( ) process, (14.119) Definition A sequence x is said to be incompressible if K ( x 1 x 2 … x n | n )/ n → 1. Strong law of large numbers for incompressible sequences (14.120) Definition The universal probability of a string x is (14.121) Universality of P u ( x ). For every computer A , (14.122) for every string x {0, 1}*, where the constant c A depends only on U and A . Definition Ω = Σ p:u ( p ) halts 2 − l ( p ) = Pr( u ( p ) halts) is the probability that the computer halts when the input p to the computer is a binary string drawn according to a Bernoulli( ) process. Properties of Ω 1. Ω is not computable . 2. Ω is a “philosopher’s stone” . 3. Ω is algorithmically random (incompressible) . Equivalence of K(x) and log . There exists a constant c independent of x such that (14.123) for all strings x . Thus, the universal probability of a string x is essentially determined by its Kolmogorov complexity. Definition The Kolmogorov structure function K k ( x n | n ) of a binary string x n {0, 1} n is defined as (14.124) Definition Let k * be the least k such that (14.125) Let S ** be the corresponding set and let p ** be the program that prints out the indicator function of S **. Then p ** is the Kolmogorov minimal sufficient statistic for x . PROBLEMS 14.1 Kolmogorov complexity of two sequences . Let x, y {0, 1}*. Argue that K ( x, y ) ≤ K ( x ) + K ( y ) + c . 14.2 Complexity of the sum (a) Argue that K ( n ) ≤ log n + 2 log log n + c . (b) Argue that K ( n 1 + n 2 ) ≤ K ( n 1 ) + K ( n 2 ) + c . (c) Give an example in which n 1 and n 2 are complex but the sum is relatively simple. 14.3 Images . Consider an n × n array x of 0’s and 1’s. Thus, x has n 2 bits. Find the Kolmogorov complexity K ( x | n ) (to first order) if: (a) x is a horizontal line. (b) x is a square. (c) x is the union of two lines, each line being vertical or horizontal. 14.4 Do computers reduce entropy? Feed a random program P into an universal computer. What is the entropy of the corresponding output? Specifically, let X = u ( P ), where P is a Bernoulli( ) sequence. Here the binary sequence X is either undefined or is in {0, 1}*. Let H ( X ) be the Shannon entropy of X . Argue that H ( X ) = ∞. Thus, although the computer turns nonsense into sense, the output entropy is still infinite. 14.5 Monkeys on a computer . Suppose that a random program is typed into a computer. Give a rough estimate of the probability that the computer prints the following sequence: (a) 0 n followed by any arbitrary sequence. (b) π 1 π 2 … π n , followed by any arbitrary sequence, where π i is the i th bit in the expansion of π . (c) 0 n 1 followed by any arbitrary sequence. (d) ω 2 ω 2 … ω n followed by any arbitrary sequence. (e) A proof of the four-color theorem. 14.6 Kolmogorov complexity and ternary programs . Suppose that the input programs for a universal computer u are sequences in {0, 1, 2}* (ternary inputs). Also, suppose that u prints ternary outputs. Let K ( x | l ( x )) = min u ( p, l ( x ))= x l ( p ). Show that: (a) K ( x n | n ) ≤ n + c . (b) | x n {0, 1}* : K ( x n | n ) < k | < 3 k . 14.7 Law of large numbers . Using ternary inputs and outputs as in Problem 14.14.6, outline an argument demonstrating that if a sequence x is algorithmically random [i.e., if K ( x | l ( x )) ≈ l ( x )], the proportion of 0’s, 1’s, and 2’s in x must each be near 1/3. It may be helpful to use Stirling’s approximation n ! ≈ ( n / e ) n . 14.8 Image complexity . Consider two binary subsets A and B (of an n × n grid): for example, Find general upper and lower bounds, in terms of K ( A | n ) and K ( B | n ), for: (a) K ( A c | n ). (b) K ( A ∪ B | n ). (c) K ( A ∩ B | n ). 14.9 Random program . Suppose that a random program (symbols i.i.d. uniform over the symbol set) is fed into the nearest available computer. To our surprise the first n bits of the binary expansion of are printed out. Roughly what would you say the probability is that the next output bit will agree with the corresponding bit in the expansion of ? 14.10 Face–vase illusion (a) What is an upper bound on the complexity of a pattern on an m × m grid that has mirror-image symmetry about a vertical axis through the center of the grid and consists of horizontal line segments? (b) What is the complexity K if the image differs in one cell from the pattern described above? 14.11 Kolmogorov complexity . Assume that n is very large and known. Let all rectangles be parallel to the frame. (a) What is the (maximal) Kolmogorov complexity of the union of two rectangles on an n × n grid? (b) What if the rectangles intersect at a corner? (c) What if they have the same (unknown) shape? (d) What if they have the same (unknown) area? (e) What is the minimum Kolmogorov complexity of the union of two rectangles? That is, what is the simplest union? (f) What is the (maximal) Kolmogorov complexity over all images (not necessarily rectangles) on an n × n grid? 14.12 Encrypted text . Suppose that English text x n is encrypted into y n by a substitution cypher: a 1-to-1 reassignment of each of the 27 letters of the alphabet (A–Z, including the space character) to itself. Suppose that the Kolmogorov complexity of the text x n is K ( x n ) = (This is about right for English text. We’re now assuming a 27-symbol programming language, instead of a binary symbol-set for the programming language. So, the length of the shortest program, using a 27-ary programming language, that prints out a particular string of English text of length n, is approximately n /4.) (a) What is the Kolmogorov complexity of the encryption map? (b) Estimate the Kolmogorov complexity of the encrypted text y n . (c) How high must n be before you would expect to be able to decode y n ? 14.13 Kolmogorov complexity . Consider the Kolmogorov complexity K ( n ) over the integers n . If a specific integer n 1 has a low Kolmogorov complexity K ( n 1 ), by how much can the Kolmogorov complexity K ( n 1 + k ) for the integer n 1 + k vary from K ( n 1 )? 14.14 Complexity of large numbers . Let A ( n ) be the set of positive integers x for which a terminating program p of length less than or equal to n bits exists that outputs x . Let B ( n ) be the complement of A ( n ) [i.e., B ( n ) is the set of integers x for which no program of length less than or equal to n outputs x ]. Let M ( n ) be the maximum integer in A ( n ), and let S ( n ) be the minimum integer in B ( n ). What is the Kolmogorov complexity K ( M ( n )) (approximately)? What is K ( S ( n )) (approximately)? Which is larger ( M ( n ) or S ( n ))? Give a reasonable lower bound on M ( n ) and a reasonable upper bound on S ( n ). HISTORICAL NOTES The original ideas of Kolmogorov complexity were put forth independently and almost simultaneously by Kolmogorov [321, 322], Solomonoff [504], and Chaitin [89]. These ideas were developed further by students of Kolmogorov such as Martin-Löf [374], who defined the notion of algorithmically random sequences and algorithmic tests for randomness, and by Levin and Zvonkin [353], who explored the ideas of universal probability and its relationship to complexity. A series of papers by Chaitin [90]–[92] developed the relationship between algorithmic complexity and mathematical proofs. C. P. Schnorr studied the universal notion of randomness and related it to gambling in [466]–[468]. The concept of the Kolmogorov structure function was defined by Kolmogorov at a talk at the Tallin conference in 1973, but these results were not published. V’yugin pursues this in [549], where he shows that there are some very strange sequences x n that reveal their structure arbitrarily slowly in the sense that K k ( x n | n ) = n − k, k < K ( x n | n ). Zurek [606]–[608] addresses the fundamental questions of Maxwell’s demon and the second law of thermodynamics by establishing the physical consequences of Kolmogorov complexity. Rissanen’s minimum description length (MDL) principle is very close in spirit to the Kolmogorov sufficient statistic. Rissanen [445, 446] finds a low-complexity model that yields a high likelihood of the data. Barron and Cover [32] argue that the density minimizing yields consistent density estimation. A nontechnical introduction to the various measures of complexity can be found in a thought-provoking book by Pagels [412]. Additional references to work in the area can be found in a paper by Cover et al. [114] on Kolmogorov’s contributions to information theory and algorithmic complexity. A comprehensive introduction to the field, including applications of the theory to analysis of algorithms and automata, may be found in the book by Li and Vitanyi [354]. Additional coverage may be found in the books by Chaitin [86, 93].

Chapter 15: Network Information Theory CHAPTER 15 NETWORK INFORMATION THEORY A system with many senders and receivers contains many new elements in the communication problem: interference, cooperation, and feedback. These are the issues that are the domain of network information theory. The general problem is easy to state. Given many senders and receivers and a channel transition matrix that describes the effects of the interference and the noise in the network, decide whether or not the sources can be transmitted over the channel. This problem involves distributed source coding (data compression) as well as distributed communication (finding the capacity region of the network). This general problem has not yet been solved, so we consider various special cases in this chapter. Examples of large communication networks include computer networks, satellite networks, and the phone system. Even within a single computer, there are various components that talk to each other. A complete theory of network information would have wide implications for the design of communication and computer networks. Suppose that m stations wish to communicate with a common satellite over a common channel, as shown in Figure 15.1 . This is known as a multiple-access channel . How do the various senders cooperate with each other to send information to the receiver? What rates of communication are achievable simultaneously? What limitations does interference among the senders put on the total rate of communication? This is the best understood multiuser channel, and the above questions have satisfying answers. FIGURE 15.1. Multiple-access channel. In contrast, we can reverse the network and consider one TV station sending information to m TV receivers, as in Figure 15.2 . How does the sender encode information meant for different receivers in a common signal? What are the rates at which information can be sent to the different receivers? For this channel, the answers are known only in special cases. FIGURE 15.2. Broadcast channel. There are other channels, such as the relay channel (where there is one source and one destination, but one or more intermediate sender-receiver pairs that act as relays to facilitate the communication between the source and the destination), the interference channel (two senders and two receivers with crosstalk), and the two-way channel (two sender-receiver pairs sending information to each other). For all these channels, we have only some of the answers to questions about achievable communication rates and the appropriate coding strategies. All these channels can be considered special cases of a general communication network that consists of m nodes trying to communicate with each other, as shown in Figure 15.3 . At each instant of time, the i th node sends a symbol x i that depends on the messages that it wants to send and on past received symbols at the node. The simultaneous transmission of the symbols ( x 1 , x 2 ,…, x m ) results in random received symbols ( Y 1 , Y 2 ,…, Y m ) drawn according to the conditional probability distribution p ( y (1) , y (2) , …, y ( m ) | x (1) , x (2) ,…, x ( m ) ). Here p (·|·) expresses the effects of the noise and interference present in the network. If p (·|·) takes on only the values 0 and 1, the network is deterministic. FIGURE 15.3. Communication network. Associated with some of the nodes in the network are stochastic data sources, which are to be communicated to some of the other nodes in the network. If the sources are independent, the messages sent by the nodes are also independent. However, for full generality, we must allow the sources to be dependent. How does one take advantage of the dependence to reduce the amount of information transmitted? Given the probability distribution of the sources and the channel transition function, can one transmit these sources over the channel and recover the sources at the destinations with the appropriate distortion? We consider various special cases of network communication. We consider the problem of source coding when the channels are noiseless and without interference. In such cases, the problem reduces to finding the set of rates associated with each source such that the required sources can be decoded at the destination with a low probability of error (or appropriate distortion). The simplest case for distributed source coding is the Slepian–Wolf source coding problem, where we have two sources that must be encoded separately, but decoded together at a common node. We consider extensions to this theory when only one of the two sources needs to be recovered at the destination. The theory of flow in networks has satisfying answers in such domains as circuit theory and the flow of water in pipes. For example, for the single-source single-sink network of pipes shown in Figure 15.4 , the maximum flow from A to B can be computed easily from the Ford-Fulkerson theorem. Assume that the edges have capacities C i as shown. Clearly, the maximum flow across any cut set cannot be greater than the sum of the capacities of the cut edges. Thus, minimizing the maximum flow across cut sets yields an upper bound on the capacity of the network. The Ford–Fulkerson theorem [214] shows that this capacity can be achieved. FIGURE 15.4. Network of water pipes. The theory of information flow in networks does not have the same simple answers as the theory of flow of water in pipes. Although we prove an upper bound on the rate of information flow across any cut set, these bounds are not achievable in general. However, it is gratifying that some problems, such as the relay channel and the cascade channel, admit a simple max-flow min-cut interpretation. Another subtle problem in the search for a general theory is the absence of a source–channel separation theorem, which we touch on briefly in Section 15.10. A complete theory combining distributed source coding and network channel coding is still a distant goal. In the next section we consider Gaussian examples of some of the basic channels of network information theory. The physically motivated Gaussian channel lends itself to concrete and easily interpreted answers. Later we prove some of the basic results about joint typicality that we use to prove the theorems of multiuser information theory. We then consider various problems in detail: the multiple-access channel, the coding of correlated sources (Slepian–Wolf data compression), the broadcast channel, the relay channel, the coding of a random variable with side information, and the rate distortion problem with side information. We end with an introduction to the general theory of information flow in networks. There are a number of open problems in the area, and there does not yet exist a comprehensive theory of information networks. Even if such a theory is found, it may be too complex for easy implementation. But the theory will be able to tell communication designers how close they are to optimality and perhaps suggest some means of improving the communication rates. 15.1 GAUSSIAN MULTIPLE-USER CHANNELS Gaussian multiple-user channels illustrate some of the important features of network information theory. The intuition gained in Chapter 9 on the Gaussian channel should make this section a useful introduction. Here the key ideas for establishing the capacity regions of the Gaussian multiple-access, broadcast, relay, and two-way channels will be given without proof. The proofs of the coding theorems for the discrete memoryless counterparts to these theorems are given in later sections of the chapter. The basic discrete-time additive white Gaussian noise channel with input power P and noise variance N is modeled by (15.1) where the Z i are i.i.d. Gaussian random variables with mean 0 and variance N . The signal X = ( X 1 , X 2 ,…, X n ) has a power constraint (15.2) The Shannon capacity C is obtained by maximizing I ( X ; Y ) over all random variables X such that EX 2 ≤ P and is given (Chapter 9) by (15.3) In this chapter we restrict our attention to discrete-time memoryless channels; the results can be extended to continuous-time Gaussian channels. 15.1.1 Single-User Gaussian Channel We first review the single-user Gaussian channel studied in Chapter 9. Here Y = X + Z . Choose a rate R < log(1 + ). Fix a good (2 nR , n ) codebook of power P . Choose an index w in the set 2 nR . Send the w th codeword X ( w ) from the codebook generated above. The receiver observes Y = X ( w ) + Z and then finds the index of the codeword closest to Y . If n is sufficiently large, the probability of error Pr( w ≠ ) will be arbitrarily small. As can be seen from the definition of joint typicality, this minimum-distance decoding scheme is essentially equivalent to finding the codeword in the codebook that is jointly typical with the received vector Y . 15.1.2 Gaussian Multiple-Access Channel with m Users We consider m transmitters, each with a power P . Let (15.4) Let (15.5) denote the capacity of a single-user Gaussian channel with signal-to-noise ratio P / N . The achievable rate region for the Gaussian channel takes on the simple form given in the following equations: (15.6) (15.7) (15.8) (15.9) (15.10) Note that when all the rates are the same, the last inequality dominates the others. Here we need m codebooks, the i th codebook having 2 nR i codewords of power P . Transmission is simple. Each of the independent transmitters chooses an arbitrary codeword from its own codebook. The users send these vectors simultaneously. The receiver sees these codewords added together with the Gaussian noise Z . Optimal decoding consists of looking for the m codewords, one from each codebook, such that the vector sum is closest to Y in Euclidean distance. If ( R 1 , R 2 ,…, R m ) is in the capacity region given above, the probability of error goes to 0 as n tends to infinity. Remarks It is exciting to see in this problem that the sum of the rates of the users C ( mP / N ) goes to infinity with m . Thus, in a cocktail party with m celebrants of power P in the presence of ambient noise N , the intended listener receives an unbounded amount of information as the number of people grows to infinity. A similar conclusion holds, of course, for ground communications to a satellite. Apparently, the increasing interference as the number of senders m → ∞ does not limit the total received information. It is also interesting to note that the optimal transmission scheme here does not involve time-division multiplexing. In fact, each of the transmitters uses all of the bandwidth all of the time. 15.1.3 Gaussian Broadcast Channel Here we assume that we have a sender of power P and two distant receivers, one with Gaussian noise power N 1 and the other with Gaussian noise power N 2 . Without loss of generality, assume that N 1 < N 2 . Thus, receiver Y 1 is less noisy than receiver Y 2 . The model for the channel is Y 1 = X + Z 1 and Y 2 = X + Z 2 , where Z 1 and Z 2 are arbitrarily correlated Gaussian random variables with variances N 1 and N 2 , respectively. The sender wishes to send independent messages at rates R 1 and R 2 to receivers Y 1 and Y 2 , respectively. Fortunately, all scalar Gaussian broadcast channels belong to the class of degraded broadcast channels discussed in Section 15.6.2. Specializing that work, we find that the capacity region of the Gaussian broadcast channel is (15.11) (15.12) where α may be arbitrarily chosen (0 ≤ α ≤ 1) to trade off rate R 1 for rate R 2 as the transmitter wishes. To encode the messages, the transmitter generates two codebooks, one with power αP at rate R 1 , and another codebook with power P at rate R 2 , where R 1 and R 2 lie in the capacity region above. Then to send an index w 1 {1, 2,…, 2 nR 1 } and w 2 {1, 2,…, 2 nR 2 } to Y 1 and Y 2 , respectively, the transmitter takes the codeword X ( w 1 ) from the first codebook and codeword X ( w 2 ) from the second codebook and computes the sum. He sends the sum over the channel. The receivers must now decode the messages. First consider the bad receiver Y 2 . He merely looks through the second codebook to find the closest codeword to the received vector Y 2 . His effective signal-to-noise ratio is P /( αP + N 2 ), since Y 1 ’s message acts as noise to Y 2 . (This can be proved.) The good receiver Y 1 first decodes Y 2 ’s codeword, which he can accomplish because of his lower noise N 1 . He subtracts this codeword 2 from Y 1 . He then looks for the codeword in the first codebook closest to Y 1 – 2 . The resulting probability of error can be made as low as desired. A nice dividend of optimal encoding for degraded broadcast channels is that the better receiver Y 1 always knows the message intended for receiver Y 2 in addition to the message intended for himself. 15.1.4 Gaussian Relay Channel For the relay channel, we have a sender X and an ultimate intended receiver Y . Also present is the relay channel, intended solely to help the receiver. The Gaussian relay channel ( Figure 15.31 in Section 15.7) is given by (15.13) (15.14) where Z 1 and Z 2 are independent zero-mean Gaussian random variables with variance N 1 and N 2 , respectively. The encoding allowed by the relay is the causal sequence (15.15) Sender X has power P and sender X 1 has power p 1 . The capacity is (15.16) where = 1 – α . Note that if (15.17) it can be seen that C = C ( P / N 1 ), which is achieved by α = 1. The channel appears to be noise-free after the relay, and the capacity C ( P / N 1 ) from X to the relay can be achieved. Thus, the rate C ( P /( N 1 + N 2 )) without the relay is increased by the presence of the relay to C ( P / N 1 ). For large N 2 and for p 1 / N 2 ≥ P / N 1 , we see that the increment in rate is from C ( P /( N 1 + N 2 )) ≈ 0 to C ( P / N 1 ). Let R 1 < C ( αP / N 1 ). Two codebooks are needed. The first codebook has 2n R 1 words of power αP . The second has 2 nR 0 codewords of power P . We shall use codewords from these codebooks successively to create the opportunity for cooperation by the relay. We start by sending a codeword from the first codebook. The relay now knows the index of this codeword since R 1 < C ( αP / N 1 ), but the intended receiver has a list of possible codewords of size 2 n ( R 1 − C ( αP /( N 1 + N 2 ))) . This list calculation involves a result on list codes. In the next block, the transmitter and the relay wish to cooperate to resolve the receiver’s uncertainty about the codeword sent previously that is on the receiver’s list. Unfortunately, they cannot be sure what this list is because they do not know the received signal Y . Thus, they randomly partition the first codebook into 2 nR 0 cells with an equal number of code-words in each cell. The relay, the receiver, and the transmitter agree on this partition. The relay and the transmitter find the cell of the partition in which the codeword from the first codebook lies and cooperatively send the codeword from the second codebook with that index. That is, X and X 1 send the same designated codeword. The relay, of course, must scale this codeword so that it meets his power constraint p 1 . They now transmit their codewords simultaneously. An important point to note here is that the cooperative information sent by the relay and the transmitter is sent coherently. So the power of the sum as seen by the receiver Y is . However, this does not exhaust what the transmitter does in the second block. He also chooses a fresh codeword from the first codebook, adds it “on paper” to the cooperative codeword from the second codebook, and sends the sum over the channel. The reception by the ultimate receiver Y in the second block involves first finding the cooperative index from the second codebook by looking for the closest codeword in the second codebook. He subtracts the code-word from the received sequence and then calculates a list of indices of size 2 nR 0 corresponding to all codewords of the first codebook that might have been sent in the second block. Now it is time for the intended receiver to complete computing the codeword from the first codebook sent in the first block. He takes his list of possible codewords that might have been sent in the first block and intersects it with the cell of the partition that he has learned from the cooperative relay transmission in the second block. The rates and powers have been chosen so that it is highly probable that there is only one codeword in the intersection. This is Y ’s guess about the information sent in the first block. We are now in steady state. In each new block, the transmitter and the relay cooperate to resolve the list uncertainty from the previous block. In addition, the transmitter superimposes some fresh information from his first codebook to this transmission from the second codebook and transmits the sum. The receiver is always one block behind, but for sufficiently many blocks, this does not affect his overall rate of reception. 15.1.5 Gaussian Interference Channel The interference channel has two senders and two receivers. Sender 1 wishes to send information to receiver 1. He does not care what receiver 2 receives or understands; similarly with sender 2 and receiver 2. Each channel interferes with the other. This channel is illustrated in Figure 15.5 . It is not quite a broadcast channel since there is only one intended receiver for each sender, nor is it a multiple access channel because each receiver is only interested in what is being sent by the corresponding transmitter. For symmetric interference, we have FIGURE 15.5. Gaussian interference channel. (15.18) (15.19) where Z 1 , Z 2 are independent N (0, N ) random variables. This channel has not been solved in general even in the Gaussian case. But remarkably, in the case of high interference, it can be shown that the capacity region of this channel is the same as if there were no interference whatsoever. To achieve this, generate two codebooks, each with power P and rate C ( P / N ). Each sender independently chooses a word from his book and sends it. Now, if the interference a satisfies C ( a 2 P /( P + N )) > C ( P / N ), the first transmitter understands perfectly the index of the second transmitter. He finds it by the usual technique of looking for the closest codeword to his received signal. Once he finds this signal, he subtracts it from his waveform received. Now there is a clean channel between him and his sender. He then searches the sender’s codebook to find the closest codeword and declares that codeword to be the one sent. 15.1.6 Gaussian Two-Way Channel The two-way channel is very similar to the interference channel, with the additional provision that sender 1 is attached to receiver 2 and sender 2 is attached to receiver 1, as shown in Figure 15.6 . Hence, sender 1 can use information from previous received symbols of receiver 2 to decide what to send next. This channel introduces another fundamental aspect of network information theory: namely, feedback. Feedback enables the senders to use the partial information that each has about the other’s message to cooperate with each other. The capacity region of the two-way channel is not known in general. This channel was first considered by Shannon [486], who derived upper and lower bounds on the region (see Problem 15.15). For Gaussian channels, these two bounds coincide and the capacity region is known; in fact, the Gaussian two-way channel decomposes into two independent channels. Let p 1 and p 2 be the powers of transmitters 1 and 2, respectively, and let N 1 and N 2 be the noise variances of the two channels. Then the rates R 1 < C ( p 1 / N 1 ) and R 2 < C ( p 2 / N 2 ) can be achieved by the techniques described for the interference channel. In this case, we generate two codebooks of rates R 1 and R 2 . Sender 1 sends a codeword from the first codebook. Receiver 2 receives the sum of the codewords sent by the two senders plus some noise. He simply subtracts out the codeword of sender 2 and he has a clean channel from sender 1 (with only the noise of variance N 1 ). Hence, the two-way Gaussian channel decomposes into two independent Gaussian channels. But this is not the case for the general two-way channel; in general, there is a trade-off between the two senders so that both of them cannot send at the optimal rate at the same time. FIGURE 15.6. Two-way channel. 15.2 JOINTLY TYPICAL SEQUENCES We have previewed the capacity results for networks by considering. multiuser Gaussian channels. We begin a more detailed analysis in this section, where we extend the joint AEP proved in Chapter 7 to a form that we will use to prove the theorems of network information theory. The joint AEP will enable us to calculate the probability of error for jointly typical decoding for the various coding schemes considered in this chapter. Let ( X 1 , X 2 ,…, X k ) denote a finite collection of discrete random variables with some fixed joint distribution, p ( x (1) , x (2) , …, x ( k ) ), ( x (1) , x (2) ,…, X ( k ) ) χ 1 × χ 2 × … × χ k . Let S denote an ordered subset of these random variables and consider n independent copies of S . Thus, (15.20) For example, if S = ( X j , X l ), then (15.21) (15.22) To be explicit, we will sometimes use X ( S ) for S . By the law of large numbers, for any subset S of random variables, (15.23) where the convergence takes place with probability 1 for all 2 k subsets, S ⊆ { X (1) , X (2) ,…, X ( k ) }. Definition The set of -typical n -sequences ( x 1 , x 2 ,…, x k ) is defined by (15.24) Let ( S ) denote the restriction of to the coordinates of S . Thus, if S = ( X 1 , X 2 ), we have (15.25) Definition We will use the notation to mean that (15.26) for n sufficiently large. Theorem 15.2.1 For any > 0, for sufficiently large n , (15.27) (15.28) (15.29) (15.30) Proof 1. This follows from the law of large numbers for the random variables in the definition of ( S ). 2. This follows directly from the definition of ( S ). 3. This follows from (15.31) (15.32) (15.33) If n is sufficiently large, we can argue that (15.34) (15.35) (15.36) Combining (15.33) and (15.36) , we have for sufficiently large n . 4. For ( s 1 , s 2 ) ( S 1 , S 2 ), we have p ( s 1 ) = and . Hence, (15.37) The next theorem bounds the number of conditionally typical sequences for a given typical sequence. Theorem 15.2.2 Let S 1 , S 2 be two subsets of X (1) , X (2) ,…, X ( k ) . For any > 0, define A ( n ) ( S 1 | s 2 ) to be the set of s 1 sequences that are jointly -typical with a particular s 2 sequence. If s 2 ( S 2 ), then for sufficiently large n, we have (15.38) and (15.39) Proof: As in part 3 of Theorem 15.2.1, we have (15.40) (15.41) (15.42) If n is sufficiently large, we can argue from (15.27) that (15.43) (15.44) (15.45) To calculate the probability of decoding error, we need to know the probability that conditionally independent sequences are jointly typical. Let S 1 , S 2 , and S 3 be three subsets of { X (1) , X (2) , X ( k ) }. If S′ 1 and S′ 2 are conditionally independent given S′ 3 but otherwise share the same pairwise marginals of ( S 1 , S 2 , S 3 ), we have the following probability of joint typicality. Theorem 15.2.3 Let denote the typical set for the probability mass function p ( s 1 , s 2 , s 3 ), and let (15.46) Then (15.47) Proof: We use the = notation from (15.26) to avoid calculating the upper and lower bounds separately. We have (15.48) (15.49) (15.50) (15.51) We will specialize this theorem to particular choices of S 1 , S 2 , and S 3 for the various achievability proofs in this chapter. 15.3 MULTIPLE-ACCESS CHANNEL The first channel that we examine in detail is the multiple-access channel, in which two (or more) senders send information to a common receiver. The channel is illustrated in Figure 15.7 . A common example of this channel is a satellite receiver with many independent ground stations, or a set of cell phones communicating with a base station. We see that the senders must contend not only with the receiver noise but with interference from each other as well. FIGURE 15.7. Multiple-access channel. Definition A discrete memoryless multiple-access channel consists of three alphabets, χ 1 , χ 2 , and , and a probability transition matrix P ( y | x 1 , x 2 ). Definition A ((2 nR 1 , 2 nR 2 ), n ) code for the multiple-access channel consists of two sets of integers W 1 = {1, 2,…, 2 nR 1 } and W 2 = {1, 2,…, 2 nR 2 }, called the message sets , two encoding functions , (15.52) and (15.53) and a decoding function , (15.54) There are two senders and one receiver for this channel. Sender 1 chooses an index W 1 uniformly from the set {1, 2,…, 2 nR 1 } and sends the corresponding codeword over the channel. Sender 2 does likewise. Assuming that the distribution of messages over the product set W 1 × W 2 is uniform (i.e., the messages are independent and equally likely), we define the average probability of error for the ((2 nR 1 , 2 nR 2 ), n ) code as follows: (15.55) Definition A rate pair ( R 1 , R 2 ) is said to be achievable for the multiple-access channel if there exists a sequence of ((2 nR 1 , 2 nR 2 ), n ) codes with . Definition The capacity region of the multiple-access channel is the closure of the set of achievable ( R 1 , R 2 ) rate pairs. An example of the capacity region for a multiple-access channel is illustrated in Figure 15.8 . We first state the capacity region in the form of a theorem. FIGURE 15.8. Capacity region for a multiple-access channel. Theorem 15.3.1 ( Multiple-access channel capacity ) The capacity of a multiple-access channel ( χ 1 × χ 2 , P ( y | x 1 , x 2 ), ) is the closure of the convex hull of all ( R 1 , R 2 ) satisfying (15.56) (15.57) (15.58) for some product distribution p 1 ( x 1 ) p 2 ( x 2 ) on χ 1 × χ 2 . Before we prove that this is the capacity region of the multiple-access channel, let us consider a few examples of multiple-access channels: Example 15.3.1 ( Independent binary symmetric channels ) Assume that we have two independent binary symmetric channels, one from sender 1 and the other from sender 2, as shown in Figure 15.9 . In this case, it is obvious from the results of Chapter 7 that we can send at rate 1 − H ( p 1 ) over the first channel and at rate 1 − H ( p 2 ) over the second channel. FIGURE 15.9. Independent binary symmetric channels. Since the channels are independent, there is no interference between the senders. The capacity region in this case is shown in Figure 15.10 . FIGURE 15.10. Capacity region for independent BSCs. Example 15.3.2 ( Binary multiplier channel ) Consider a multiple-access channel with binary inputs and output (15.59) Such a channel is called a binary multiplier channel . It is easy to see that by setting X 2 = 1, we can send at a rate of 1 bit per transmission from sender 1 to the receiver. Similarly, setting X 1 = 1, we can achieve R 2 = 1. Clearly, since the output is binary, the combined rates R 1 + R 2 of sender 1 and sender 2 cannot be more than 1 bit. By timesharing, we can achieve any combination of rates such that R 1 + R 2 = 1. Hence the capacity region is as shown in Figure 15.11 . FIGURE 15.11. Capacity region for binary multiplier channel. Example 15.3.3 ( Binary erasure multiple-access channel ) This multiple-access channel has binary inputs, X 1 = X 2 = {0, 1}, and a ternary output, Y = X 1 + X 2 . There is no ambiguity in ( X 1 , X 2 ) if Y = 0 or Y = 2 is received; but Y = 1 can result from either (0,1) or (1,0). We now examine the achievable rates on the axes. Setting X 2 = 0, we can send at a rate of 1 bit per transmission from sender 1. Similarly, setting X 1 = 0, we can send at a rate R 2 = 1. This gives us two extreme points of the capacity region. Can we do better? Let us assume that R 1 = 1, so that the codewords of X 1 must include all possible binary sequences; X 1 would look like a Bernoulli( ) process. This acts like noise for the transmission from X 2 . For X 2 , the channel looks like the channel in Figure 15.12 . This is the binary erasure channel of Chapter 7. Recalling the results, the capacity of this channel is bit per transmission. Hence when sending at maximum rate 1 for sender 1, we can send an additional bit from sender 2. Later, after deriving the capacity region, we can verify that these rates are the best that can be achieved. The capacity region for a binary erasure channel is illustrated in Figure 15.13 . FIGURE 15.12. Equivalent single-user channel for user 2 of a binary erasure multiple-access channel. FIGURE 15.13. Capacity region for binary erasure multiple-access channel. 15.3.1 Achievability of the Capacity Region for the Multiple-Access Channel We now prove the achievability of the rate region in Theorem 15.3.1; the proof of the converse will be left until the next section. The proof of achievability is very similar to the proof for the single-user channel. We therefore only emphasize the points at which the proof differs from the single-user case. We begin by proving the achievability of rate pairs that satisfy (15.58) for some fixed product distribution p ( x 1 ) p ( x 2 ). In Section 15.3.3 we extend this to prove that all points in the convex hull of (15.58) are achievable. Proof: (Achievability in Theorem 15.3.1 ). Fix p ( x 1 , x 2 ) = p 1 ( x 1 ) p 2 ( X 2 ). Codebook generation: Generate 2 nR 1 independent codewords X 1 ( i ), i {1, 2,…, 2 nR 1 }, of length n , generating each element i.i.d. ~ . Similarly, generate 2 nR 2 independent codewords X 2 ( j ), j {1, 2,…, 2 nR 2 }, generating each element i.i.d. ~ . These codewords form the codebook, which is revealed to the senders and the receiver. Encoding: To send index i , sender 1 sends the codeword X 1 ( i ). Similarly, to send j , sender 2 sends X 2 ( j ). Decoding: Let denote the set of typical ( x 1 , x 2 , y ) sequences. The receiver Y n chooses the pair ( i, j ) such that (15.60) if such a pair ( i, j ) exists and is unique; otherwise, an error is declared. Analysis of the probability of error: By the symmetry of the random code construction, the conditional probability of error does not depend on which pair of indices is sent. Thus, the conditional probability of error is the same as the unconditional probability of error. So, without loss of generality, we can assume that ( i, j ) = (1, 1) was sent. We have an error if either the correct codewords are not typical with the received sequence or there is a pair of incorrect codewords that are typical with the received sequence. Define the events (15.61) Then by the union of events bound, (15.62) (15.63) where P is the conditional probability given that (1, 1) was sent. From the AEP, P ( E c 11 ) → 0. By Theorems 15.2.1 and 15.2.3, for i ≠ 1, we have (15.64) (15.65) (15.66) (15.67) (15.68) (15.69) where the equivalence of (15.68) and (15.69) follows from the independence of X 1 and X 2 , and the consequent I ( X 1 ; X 2 , Y ) = I ( X 1 ; X 2 ) + I ( X 1 ; Y | X 2 ) = I ( X 1 ; Y | X 2 ). Similarly, for j ≠ 1, (15.70) and for i ≠ 1, j ≠ 1, (15.71) It follows that (15.72) Since > 0 is arbitrary, the conditions of the theorem imply that each term tends to 0 as n → ∞. Thus, the probability of error, conditioned on a particular codeword being sent, goes to zero if the conditions of the theorem are met. The above bound shows that the average probability of error, which by symmetry is equal to the probability for an individual codeword, averaged over all choices of codebooks in the random code construction, is arbitrarily small. Hence, there exists at least one code C * with arbitrarily small probability of error. This completes the proof of achievability of the region in (15.58) for a fixed input distribution. Later, in Section 15.3.3, we show that timesharing allows any ( R 1 , R 2 ) in the convex hull to be achieved, completing the proof of the forward part of the theorem. 15.3.2 Comments on the Capacity Region for the Multiple-Access Channel We have now proved the achievability of the capacity region of the multiple-access channel, which is the closure of the convex hull of the set of points ( R 1 , R 2 ) satisfying (15.73) (15.74) (15.75) for some distribution p 1 ( x 1 ) p 2 ( x 2 ) on χ 1 × χ 2 . For a particular p 1 ( x 1 ) p 2 ( x 2 ), the region is illustrated in Figure 15.14 . FIGURE 15.14. Achievable region of multiple-access channel for a fixed input distribution. Let us now interpret the corner points in the region. Point A corresponds to the maximum rate achievable from sender 1 to the receiver when sender 2 is not sending any information. This is (15.76) Now for any distribution p 1 ( x 1 ) p 2 ( x 2 ), (15.77) (15.78) since the average is less than the maximum. Therefore, the maximum in (15.76) is attained when we set X 2 = x 2 , where x 2 is the value that maximizes the conditional mutual information between X 1 and Y . The distribution of X 1 is chosen to maximize this mutual information. Thus, X 2 must facilitate the transmission of X 1 by setting X 2 = x 2 . The point B corresponds to the maximum rate at which sender 2 can send as long as sender 1 sends at his maximum rate. This is the rate that is obtained if X 1 is considered as noise for the channel from X 2 to Y . In this case, using the results from single-user channels, X 2 can send at a rate I ( X 2 ; Y ). The receiver now knows which X 2 codeword was used and can “subtract” its effect from the channel. We can consider the channel now to be an indexed set of single-user channels, where the index is the X 2 symbol used. The X 1 rate achieved in this case is the average mutual information, where the average is over these channels, and each channel occurs as many times as the corresponding X 2 symbol appears in the codewords. Hence, the rate achieved is (15.79) Points C and D correspond to B and A, respectively, with the roles of the senders reversed. The noncorner points can be achieved by time-sharing. Thus, we have given a single-user interpretation and justification for the capacity region of a multiple-access channel. The idea of considering other signals as part of the noise, decoding one signal, and then “subtracting” it from the received signal is a very useful one. We will come across the same concept again in the capacity calculations for the degraded broadcast channel. 5.3.3 Convexity of the Capacity Region of the Multiple-Access Channel We now recast the capacity region of the multiple-access channel in order to take into account the operation of taking the convex hull by introducing a new random variable. We begin by proving that the capacity region is convex. Theorem 15.3.2 The capacity region C of a multiple-access channel is convex [i.e., if ( R 1 , R 2 ) C and ( R′ 1 R′ 2 C, then ( λ R 1 + (1 − λ ) R′ 1 , λ R 2 + (1 − λ ) R′ 2 C for 0 ≤ λ ≤ 1]. Proof: The idea is time-sharing. Given two sequences of codes at different rates R = ( R 1 , R 2 ) and R′ = ( R′ 1 , R′ 2 ), we can construct a third codebook at a rate λ R + (1 − λ) R′ by using the first codebook for the first λn symbols and using the second codebook for the last (1 − λ) n symbols. The number of X 1 codewords in the new code is (15.80) and hence the rate of the new code is λ R + (1 − λ) R′ . Since the overall probability of error is less than the sum of the probabilities of error for each of the segments, the probability of error of the new code goes to 0 and the rate is achievable. We can now recast the statement of the capacity region for the multiple-access channel using a time-sharing random variable Q . Before we prove this result, we need to prove a property of convex sets defined by linear inequalities like those of the capacity region of the multiple-access channel. In particular, we would like to show that the convex hull of two such regions defined by linear constraints is the region defined by the convex combination of the constraints. Initially, the equality of these two sets seems obvious, but on closer examination, there is a subtle difficulty due to the fact that some of the constraints might not be active. This is best illustrated by an example. Consider the following two sets defined by linear inequalities: (15.81) (15.82) In this case, the ( , ) convex combination of the constraints defines the region (15.83) It is not difficult to see that any point in C 1 or C 2 has x + y < 20, so any point in the convex hull of the union of C 1 and C 2 satisfies this property. Thus, the point (15,15), which is in C , is not in the convex hull of ( C 1 ∪ C 2 ). This example also hints at the cause of the problem—in the definition for C 1 , the constraint x + y ≤ 100 is not active. If this constraint were replaced by a constraint x + y ≤ a , where a ≤ 20, the above result of the equality of the two regions would be true, as we now prove. We restrict ourselves to the pentagonal regions that occur as components of the capacity region of a two-user multiple-access channel. In this case, the capacity region for a fixed p ( x 1 ) p ( x 2 ) is defined by three mutual informations, I ( X 1 ; Y | X 2 ), I ( X 2 ; Y | X 1 ), and I ( X 1 , X 2 ; Y ), which we shall call I 1 , I 2 , and I 3 , respectively. For each p ( x 1 ) p ( x 2 ), there is a corresponding vector, I = ( I 1 , I 2 , I 3 ), and a rate region defined by (15.84) Also, since for any distribution p ( x 1 ) p ( x 2 ), we have I ( X 2 ; Y | X 1 = H ( X 2 | X 1 ) − H ( X 2 | Y , X 1 ) = H ( X 2 ) − H ( X 2 | Y , X 1 ) = I ( X 2 ; Y , X 1 ) = I ( X 2 ; Y ) + I ( X 2 ; X 1 | Y ) ≥ I ( X 2 ; Y ), and therefore, I ( X 1 ; Y | X 2 ) + I ( X 2 ; Y | X 1 ) ≥ I ( X 1 ; Y | X 2 ) + I ( X 2 ; Y ) = I ( X 1 , X 2 ; Y ), we have for all vectors I that I 1 + I 2 ≥ I 3 . This property will turn out to be critical for the theorem. Lemma 15.3.1 Let I 1 , I 2 R 3 be two vectors of mutual informations that define rate regions C I 1 and C I 2 , respectively, as given in (15.84) . For 0 ≤ λ ≤ 1, define I λ = λ I 1 + (1 − λ ) I 2 , and let C I λ be the rate region defined by I λ . Then (15.85) Proof: We shall prove this theorem in two parts. We first show that any point in the ( λ , 1 − λ ) mix of the sets C I 1 and C I 2 satisfies the constraints I λ . But this is straightforward, since any point in C I 1 satisfies the inequalities for I 1 and a point in C I 2 satisfies the inequalities for I 2 , so the ( λ , 1 − λ ) mix of these points will satisfy the ( λ , 1 − λ ) mix of the constraints. Thus, it follows that (15.86) To prove the reverse inclusion, we consider the extreme points of the pentagonal regions. It is not difficult to see that the rate regions defined in (15.84) are always in the form of a pentagon, or in the extreme case when I 3 = I 1 + I 2 , in the form of a rectangle. Thus, the capacity region C I can be also defined as a convex hull of five points: (15.87) Consider the region defined by I λ ; it, too, is defined by five points. Take any one of the points, say . This point can be written as the ( λ , 1 − λ ) mix of the points and , and therefore lies in the convex mixture of C I 1 and C I 2 . Thus, all extreme points of the pentagon C I λ lie in the convex hull of C I 1 and C I 2 , or (15.88) Combining the two parts, we have the theorem. In the proof of the theorem, we have implicitly used the fact that all the rate regions are defined by five extreme points (at worst, some of the points are equal). All five points defined by the I vector were within the rate region. If the condition I 3 ≤ I 1 + I 2 , is not satisfied, some of the points in (15.87) may be outside the rate region and the proof collapses. As an immediate consequence of the above lemma, we have the following theorem: Theorem 15.3.3 The convex hull of the union of the rate regions defined by individual I vectors is equal to the rate region defined by the convex hull of the I vectors . These arguments on the equivalence of the convex hull operation on the rate regions with the convex combinations of the mutual informations can be extended to the general m -user multiple-access channel. A proof along these lines using the theory of polymatroids is developed in Han [271]. Theorem 15.3.4 The set of achievable rates of a discrete memoryless multiple-access channel is given by the closure of the set of all ( R 1 , R 2 ) pairs satisfying (15.89) for some choice of the joint distribution p ( q ) p ( x 1 | q ) p ( x 2 | q ) p ( y | x 1 , x 2 ) with | ≤ 4. Proof: We will show that every rate pair lying in the region defined in (15.89) is achievable (i.e., it lies in the convex closure of the rate pairs satisfying Theorem 15.3.1). We also show that every point in the convex closure of the region in Theorem 15.3.1 is also in the region defined in (15.89) . Consider a rate point R satisfying the inequalities (15.89) of the theorem. We can rewrite the right-hand side of the first inequality as (15.90) (15.91) where m is the cardinality of the support set of Q . We can expand the other mutual informations similarly. For simplicity in notation, we consider a rate pair as a vector and denote a pair satisfying the inequalities in (15.58) for a specific input product distribution p 1 q ( x 1 ) p 2 q ( x 2 ) as R q . Specifically, let R q = ( R 1 q , R 2 q ) be a rate pair satisfying (15.92) (15.93) (15.94) Then by Theorem 15.3.1, R q = ( R 1 q , R 2 q ) is achievable. Then since R satisfies (15.89) and we can expand the right-hand sides as in (15.91) , there exists a set of pairs R q satisfying (15.94) such that (15.95) Since a convex combination of achievable rates is achievable, so is R. Hence, we have proven the achievability of the region in the theorem. The same argument can be used to show that every point in the convex closure of the region in (15.58) can be written as the mixture of points satisfying (15.94) and hence can be written in the form (15.89) . The converse is proved in the next section. The converse shows that all achievable rate pairs are of the form (15.89) , and hence establishes that this is the capacity region of the multiple-access channel. The cardinality bound on the time-sharing random variable Q is a consequence of Carathéodory’s theorem on convex sets. See the discussion below. The proof of the convexity of the capacity region shows that any convex combination of achievable rate pairs is also achievable. We can continue this process, taking convex combinations of more points. Do we need to use an arbitrary number of points? Will the capacity region be increased? The following theorem says no. Theorem 15.3.5 ( Carathéodory ) Any point in the convex closure of a compact set A in a d-dimensional Euclidean space can be represented as a convex combination of d + 1 or fewer points in the original set A . Proof: The proof may be found in Eggleston [183] and Grünbaum [263]. This theorem allows us to restrict attention to a certain finite convex combination when calculating the capacity region. This is an important property because without it, we would not be able to compute the capacity region in (15.89) , since we would never know whether using a larger alphabet would increase the region. In the multiple-access channel, the bounds define a connected compact set in three dimensions. Therefore, all points in its closure can be defined as the convex combination of at most four points. Hence, we can restrict the cardinality of Q to at most 4 in the above definition of the capacity region. Remark Many of the cardinality bounds may be slightly improved by introducing other considerations. For example, if we are only interested in the boundary of the convex hull of A as we are in capacity theorems, a point on the boundary can be expressed as a mixture of d points of A , since a point on the boundary lies in the intersection of A with a ( d − 1)-dimensional support hyperplane. 15.3.4 Converse for the Multiple-Access Channel We have so far proved the achievability of the capacity region. In this section we prove the converse. Proof: ( Converse to Theorems 15.3.1 and 15.3.4 ). We must show that given any sequence of ((2 nR 1 , 2 nR 2 ), n ) codes with , the rates must satisfy (15.96) for some choice of random variable Q defined on {1, 2, 3, 4) and joint distribution p ( q ) p ( x 1 | q ) p ( x 2 | q ) p ( y | x 1 , x 2 ). Fix n. Consider the given code of block length n. The joint distribution on is well defined. The only randomness is due to the random uniform choice of indices W 1 and W 2 and the randomness induced by the channel. The joint distribution is (15.97) where p ( x n 1 | w 1 ) is either 1 or 0, depending on whether x n 1 = x 1 ( w 1 ), the codeword corresponding to w 1 , or not, and similarly, p ( x n 2 | w 2 ) = 1 or 0, according to whether x n 2 = x 2 ( w 2 ) or not. The mutual informations that follow are calculated with respect to this distribution. By the code construction, it is possible to estimate ( W 1 , W 2 ) from the received sequence Y n with a low probability of error. Hence, the conditional entropy of ( W 1 , W 2 ) given Y n must be small. By Fano’s inequality, (15.98) It is clear that n → 0 as P ( n ) e → 0. Then we have (15.99) (15.100) We can now bound the rate R 1 as (15.101) (15.102) (15.103) (15.104) (15.105) (15.106) (15.107) (15.108) (15.109) (15.110) (15.111) (15.112) (15.113) where (a) follows from Fano’s inequality (b) follows from the data-processing inequality (c) follows from the fact that since W 1 and W 2 are independent, so are X n 1 ( W 1 ) and X n 2 ( W 2 ), and hence H ( X n 1 ( W 1 )| X n 2 ( W 2 )) = H ( X n 1 ( W 1 )), and H ( X n 1 ( W 1 )| Y n , X n 2 ( W 2 )) ≤ H ( X n 1 ( W 1 )| Y n ) by conditioning (d) follows from the chain rule (e) follows from the fact that Y i depends only on X 1 i and X 2 i by the memoryless property of the channel (f) follows from the chain rule and removing conditioning (g) follows from removing conditioning Hence, we have (15.114) Similarly, we have (15.115) To bound the sum of the rates, we have (15.116) (15.117) (15.118) (15.119) (15.120) (15.121) (15.122) (15.123) (15.124) where (a) follows from Fano’s inequality (b) follows from the data-processing inequality (c) follows from the chain rule (d) follows from the fact that Y i depends only on X 1 i and X 2 i and is conditionally independent of everything else (e) follows from the chain rule and removing conditioning Hence, we have (15.125) The expressions in (15.114) , (15.115) , and (15.125) are the averages of the mutual informations calculated at the empirical distributions in column i of the codebook. We can rewrite these equations with the new variable Q , where Q = i {1, 2,…, n } with probability 1/ n . The equations become (15.126) (15.127) (15.128) (15.129) where , and are new random variables whose distributions depend on Q in the same way as the distributions of X 1 i , X 2 i and Y i depend on i. Since W 1 and W 2 are independent, so are X 1 i ( W 1 ) and X 2 i ( W 2 ), and hence (15.130) Hence, taking the limit as , we have the following converse: (15.131) for some choice of joint distribution p ( q ) p ( x 1 | q ) p ( x 2 | q ) p ( y | x 1 , x 2 ). As in Section 15.3.3, the region is unchanged if we limit the cardinality of to 4. This completes the proof of the converse. Thus, the achievability of the region of Theorem 15.3.1 was proved in Section 15.3.1. In Section 15.3.3 we showed that every point in the region defined by (15.96) was also achievable. In the converse, we showed that the region in (15.96) was the best we can do, establishing that this is indeed the capacity region of the channel. Thus, the region in (15.58) cannot be any larger than the region in (15.96) , and this is the capacity region of the multiple-access channel. 15.3.5 m -User Multiple-Access Channels We will now generalize the result derived for two senders to m senders, m ≥ 2. The multiple-access channel in this case is shown in Figure 15.15 . FIGURE 15.15. m -user multiple-access channel. We send independent indices w 1 , w 2 ,…, w n over the channel from the senders 1, 2,…, m , respectively. The codes, rates, and achievability are all defined in exactly the same way as in the two-sender case. Let S ⊆ {1, 2,…, m }. Let S c denote the complement of S. Let R ( S ) = , and let X ( S ) = { X i : i S }. Then we have the following theorem. Theorem 15.3.6 The capacity region of the m-user multiple-access channel is the closure of the convex hull of the rate vectors satisfying (15.132) for some product distribution p 1 ( x 1 ) p 2 ( x 2 ) … p m ( x m ). Proof: The proof contains no new ideas. There are now 2 m − 1 terms in the probability of error in the achievability proof and an equal number of inequalities in the proof of the converse. Details are left to the reader. In general, the region in (15.132) is a beveled box. 15.3.6 Gaussian Multiple-Access Channels We now discuss the Gaussian multiple-access channel of Section 15.1.2 in somewhat more detail. Two senders, X 1 and X 2 , communicate to the single receiver, Y . The received signal at time i is (15.133) where { Z i } is a sequence of independent, identically distributed, zero-mean Gaussian random variables with variance N ( Figure 15.16 ). We assume that there is a power constraint P j on sender j ; that is, for each sender, for all messages, we must have FIGURE 15.16. Gaussian multiple-access channel. (15.134) Just as the proof of achievability of channel capacity for the discrete case (Chapter 7) was extended to the Gaussian channel (Chapter 9), we can extend the proof for the discrete multiple-access channel to the Gaussian multiple-access channel. The converse can also be extended similarly, so we expect the capacity region to be the convex hull of the set of rate pairs satisfying (15.135) (15.136) (15.137) for some input distribution f 1 ( x 1 ) f 2 ( x 2 ) satisfying EX 2 1 ≤ p 1 and EX 2 2 ≤ p 2 . Now, we can expand the mutual information in terms of relative entropy, and thus (15.138) (15.139) (15.140) (15.141) (15.142) (15.143) (15.144) (15.145) where (15.141) follows from the fact that Z is independent of X 1 and X 2 , (15.142) from the independence of X 1 and X 2 , and (15.144) from the fact that the normal maximizes entropy for a given second moment. Thus, the maximizing distribution is X 1 ~ N (0, p 1 ) and X 2 ~ N (0, p 2 ) with X 1 and X 2 independent. This distribution simultaneously maximizes the mutual information bounds in (15.135) – (15.137) . Definition We define the channel capacity function (15.146) corresponding to the channel capacity of a Gaussian white-noise channel with signal-to-noise ratio x ( Figure 15.17 ). Then we write the bound on R 1 as FIGURE 15.17. Gaussian multiple-access channel capacity. (15.147) Similarly, (15.148) and (15.149) These upper bounds are achieved when X 1 ~ N (0, p 1 ) and X 2 = N (0, p 2 ) and define the capacity region. The surprising fact about these inequalities is that the sum of the rates can be as large as , which is that rate achieved by a single transmitter sending with a power equal to the sum of the powers. The interpretation of the corner points is very similar to the interpretation of the achievable rate pairs for a discrete multiple-access channel for a fixed input distribution. In the case of the Gaussian channel, we can consider decoding as a two-stage process: In the first stage, the receiver decodes the second sender, considering the first sender as part of the noise. This decoding will have low probability of error if . After the second sender has been decoded successfully, it can be subtracted out and the first sender can be decoded correctly if . Hence, this argument shows that we can achieve the rate pairs at the corner points of the capacity region by means of single-user operations. This process, called onion-peeling , can be extended to any number of users. If we generalize this to m senders with equal power, the total rate is , which goes to ∞ as m → ∞. The average rate per sender, , goes to 0. Thus, when the total number of senders is very large, so that there is a lot of interference, we can still send a total amount of information that is arbitrarily large even though the rate per individual sender goes to 0. The capacity region described above corresponds to code-division multiple access (CDMA), where separate codes are used for the different senders and the receiver decodes them one by one. In many practical situations, though, simpler schemes, such as frequency-division multiplexing or time-division multiplexing, are used. With frequency-division multiplexing , the rates depend on the bandwidth allotted to each sender. Consider the case of two senders with powers p 1 and p 2 using nonintersecting frequency bands with bandwidths W 1 and W 2 , where W 1 + W 2 = W (the total bandwidth). Using the formula for the capacity of a single-user bandlimited channel, the following rate pair is achievable: (15.150) (15.151) As we vary W 1 and W 2 , we trace out the curve as shown in Figure 15.18 . This curve touches the boundary of the capacity region at one point, which corresponds to allotting bandwidth to each channel proportional to the power in that channel. We conclude that no allocation of frequency bands to radio stations can be optimal unless the allocated powers are proportional to the bandwidths. FIGURE 15.18. Gaussian multiple-access channel capacity with FDMA and TDMA. In time-division multiple access (TDMA), time is divided into slots, and each user is allotted a slot during which only that user will transmit and every other user remains quiet. If there are two users, each of power P , the rate that each sends when the other is silent is C ( P / N ). Now if time is divided into equal-length slots, and every odd slot is allocated to user 1 and every even slot to user 2, the average rate that each user achieves is C ( P / N ). This system is called naive time-division multiple access (TDMA). However, it is possible to do better if we notice that since user 1 is sending only half the time, it is possible for him to use twice the power during his transmissions and still maintain the same average power constraint. With this modification, it is possible for each user to send information at a rate C (2 P / N ). By varying the lengths of the slots allotted to each sender (and the instantaneous power used during the slot), we can achieve the same capacity region as FDMA with different bandwidth allocations. As Figure 15.18 illustrates, in general the capacity region is larger than that achieved by time- or frequency-division multiplexing. But note that the multiple-access capacity region derived above is achieved by use of a common decoder for all the senders. However, it is also possible to achieve the capacity region by onion-peeling, which removes the need for a common decoder and instead, uses a sequence of single-user codes. CDMA achieves the entire capacity region, and in addition, allows new users to be added easily without changing the codes of the current users. On the other hand, TDMA and FDMA systems are usually designed for a fixed number of users and it is possible that either some slots are empty (if the actual number of users is less than the number of slots) or some users are left out (if the number of users is greater than the number of slots). However, in many practical systems, simplicity of design is an important consideration, and the improvement in capacity due to the multiple-access ideas presented earlier may not be sufficient to warrant the increased complexity. For a Gaussian multiple-access system with m sources with powers p 1 , p 2 ,…, P m and ambient noise of power N , we can state the equivalent of Gauss’s law for any set S in the form (15.152) (15.153) 15.4 ENCODING OF CORRELATED SOURCES We now turn to distributed data compression. This problem is in many ways the data compression dual to the multiple-access channel problem. We know how to encode a source X . A rate R > H ( X ) is sufficient. Now suppose that there are two sources ( X, Y ) ~ p ( x, y ). A rate H ( X, Y ) is sufficient if we are encoding them together. But what if the X and Y sources must be described separately for some user who wishes to reconstruct both X and Y ? Clearly, by separately encoding X and Y , it is seen that a rate R = R x + R y > H ( X ) + H ( Y ) is sufficient. However, in a surprising and fundamental paper by Slepian and Wolf [502], it is shown that a total rate R = H ( X, Y ) is sufficient even for separate encoding of correlated sources. Let ( X 1 , Y 1 ), ( X 2 , Y 2 ), … be a sequence of jointly distributed random variables i.i.d. ~ p ( x, y ). Assume that the X sequence is available at a location A and the Y sequence is available at a location B . The situation is illustrated in Figure 15.19 . FIGURE 15.19. Slepian–Wolf coding. Before we proceed to the proof of this result, we will give a few definitions. Definition A ((2 nR 1 , 2 nR 2 ), n ) distributed source code for the joint source ( X, Y ) consists of two encoder maps, (15.154) (15.155) and a decoder map, (15.156) Here f 1 ( X n ) is the index corresponding to X n , f 2 ( Y n ) is the index corresponding to Y n , and ( R 1 , R 2 ) is the rate pair of the code. Definition The probability of error for a distributed source code is defined as (15.157) Definition A rate pair ( R 1 , R 2 ) is said to be achievable for a distributed source if there exists a sequence of ((2 nR 1 , 2 nR 2 ), n ) distributed source codes with probability of error . The achievable rate region is the closure of the set of achievable rates. Theorem 15.4.1 ( Slepian – Wolf ) For the distributed source coding problem for the source ( X, Y ) drawn i.i.d ~ p ( x, y ), the achievable rate region is given by (15.158) (15.159) (15.160) Let us illustrate the result with some examples. Example 15.4.1 Consider the weather in Gotham and Metropolis. For the purposes of our example, we assume that Gotham is sunny with probability 0.5 and that the weather in Metropolis is the same as in Gotham with probability 0.89. The joint distribution of the weather is given as follows: Assume that we wish to transmit 100 days of weather information to the National Weather Service headquarters in Washington. We could send all the 100 bits of the weather in both places, making 200 bits in all. If we decided to compress the information independently, we would still need 100 H (0.5) = 100 bits of information from each place, for a total of 200 bits. If, instead, we use Slepian–Wolf encoding, we need only H ( X ) + H ( Y|X ) = 100 H (0.5) + 100 H (0.89) = 100 + 50 = 150 bits total. Example 15.4.2 Consider the following joint distribution: In this case, the total rate required for the transmission of this source is H ( U ) + H ( V | U ) = log 3 = 1.58 bits rather than the 2 bits that would be needed if the sources were transmitted independently without Slepian–Wolf encoding. 15.4.1 Achievability of the Slepian–Wolf Theorem We now prove the achievability of the rates in the Slepian–Wolf theorem. Before we proceed to the proof, we introduce a new coding procedure using random bins. The essential idea of random bins is very similar to hash functions: We choose a large random index for each source sequence. If the set of typical source sequences is small enough (or equivalently, the range of the hash function is large enough), then with high probability, different source sequences have different indices, and we can recover the source sequence from the index. Let us consider the application of this idea to the encoding of a single source. In Chapter 3 the method that we considered was to index all elements of the typical set and not bother about elements outside the typical set. We will now describe the random binning procedure, which indexes all sequences but rejects untypical sequences at a later stage. Consider the following procedure: For each sequence X n , draw an index at random from {1, 2,…, 2 nR }. The set of sequences X n which have the same index are said to form a bin , since this can be viewed as first laying down a row of bins and then throwing the X n ’s at random into the bins. For decoding the source from the bin index, we look for a typical X n sequence in the bin. If there is one and only one typical X n sequence in the bin, we declare it to be the estimate n of the source sequence; otherwise, an error is declared. The above procedure defines a source code. To analyze the probability of error for this code, we will now divide the X n sequences into two types, typical sequences and nontypical sequences. If the source sequence is typical, the bin corresponding to this source sequence will contain at least one typical sequence (the source sequence itself). Hence there will be an error only if there is more than one typical sequence in this bin. If the source sequence is nontypical, there will always be an error. But if the number of bins is much larger than the number of typical sequences, the probability that there is more than one typical sequence in a bin is very small, and hence the probability that a typical sequence will result in an error is very small. Formally, let f ( X n ) be the bin index corresponding to X n . Call the decoding function g. The probability of error (averaged over the random choice of codes f ) is (15.161) (15.162) (15.163) (15.164) (15.165) (15.166) if R > H ( X ) + and n is sufficiently large. Hence, if the rate of the code is greater than the entropy, the probability of error is arbitrarily small and the code achieves the same results as the code described in Chapter 3. The above example illustrates the fact that there are many ways to construct codes with low probabilities of error at rates above the entropy of the source; the universal source code is another example of such a code. Note that the binning scheme does not require an explicit characterization of the typical set at the encoder; it is needed only at the decoder. It is this property that enables this code to continue to work in the case of a distributed source, as illustrated in the proof of the theorem We now return to the consideration of the distributed source coding and prove the achievability of the rate region in the Slepian–Wolf theorem. Proof: ( Achievability in Theorem 15.4.1 ). The basic idea of the proof is to partition the space of X n into 2 nR 1 bins and the space of n into 2 nR 2 bins. Random code generation: Assign every x χ n to one of 2 nR 1 bins independently according to a uniform distribution on {1, 2,…, 2 nR 1 }. Similarly, randomly assign every y n to one of 2 nR 2 bins. Reveal the assignments f 1 and f 2 to both the encoder and the decoder. Encoding: Sender 1 sends the index of the bin to which X belongs. Sender 2 sends the index of the bin to which Y belongs. Decoding: Given the received index pair ( i 0 , j 0 ), declare = ( x, y ) if there is one and only one pair of sequences ( x, y ) such that f 1 ( x ) = i 0 , f 2 ( y ) = j 0 and ( x, y ) . Otherwise, declare an error. The scheme is illustrated in Figure 15.20 . The set of X sequences and the set of Y sequences are divided into bins in such a way that the pair of indices specifies a product bin. FIGURE 15.20. Slepian–Wolf encoding: the jointly typical pairs are isolated by the product bins. Probability of error: Let ( X i , Y i ) ~ p ( x , y ). Define the events (15.167) (15.168) (15.169) and (15.170) Here X, Y, f 1 , and f 2 are random. We have an error if ( X, Y ) is not in or if there is another typical pair in the same bin. Hence by the union of events bound, (15.171) (15.172) First consider E 0 . By the AEP, P ( E 0 ) → 0 and hence for n sufficiently large, P ( E 0 ) < . To bound P ( E 1 ), we have (15.173) (15.174) (15.175) (15.176) (15.177) which goes to 0 if R 1 > H ( X | Y ). Hence for sufficiently large n , P ( E 1 ) < . Similarly, for sufficiently large n , P ( E 2 ) < if R 2 > H ( Y | X ) and P ( E 12 ) < if R 1 + R 2 > H ( X , Y ). Since the average probability of error is < 4 , there exists at least one code ( f * 1 , f * 2 , g *) with probability of error < 4 . Thus, we can construct a sequence of codes with , and the proof of achievability is complete. 15.4.2 Converse for the Slepian–Wolf Theorem The converse for the Slepian–Wolf theorem follows obviously from the results for a single source, but we will provide it for completeness. Proof: ( Converse to Theorem 15.4.1 ). As usual, we begin with Fano’s inequality. Let f 1 , f 2 , g be fixed. Let I 0 = f 1 ( X n ) and J 0 = f 2 ( Y n ). Then (15.178) where n → 0 as n → ∞. Now adding conditioning, we also have (15.179) and (15.180) We can write a chain of inequalities (15.181) (15.182) (15.183) (15.184) (15.185) (15.186) where (a) follows from the fact that I 0 {1, 2,…, 2 nR 1 } and J 0 {1, 2,…, 2 nR 2 } (b) follows from the fact the I 0 is a function of X n and J 0 is a function of Y n (c) follows from Fano’s inequality (15.178) (d) follows from the chain rule and the fact that ( X i , Y i ) are i.i.d. Similarly, using (15.179) , we have (15.187) (15.188) (15.189) (15.190) (15.191) (15.192) (15.193) where the reasons are the same as for the equations above. Similarly, we can show that (15.194) Dividing these inequalities by n and taking the limit as n → ∞, we have the desired converse. The region described in the Slepian–Wolf theorem is illustrated in Figure 15.21 . FIGURE 15.21. Rate region for Slepian–Wolf encoding. 15.4.3 Slepian–Wolf Theorem for Many Sources The results of Section 15.4.2 can easily be generalized to many sources. The proof follows exactly the same lines. Theorem 15.4.2 Let ( X 1 i , X 2 i ,…, X mi ) be i . i . d . ~ p ( x 1 , x 2 ,…, x m ). Then the set of rate vectors achievable for distributed source coding with separate encoders and a common decoder is defined by (15.195) for all S ⊆ {1, 2,…, m }, where (15.196) and X ( S ) = { X j : j S }. Proof: The proof is identical to the case of two variables and is omitted. The achievability of Slepian–Wolf encoding has been proved for an i.i.d. correlated source, but the proof can easily be extended to the case of an arbitrary joint source that satisfies the AEP; in particular, it can be extended to the case of any jointly ergodic source [122]. In these cases the entropies in the definition of the rate region are replaced by the corresponding entropy rates. 15.4.4 Interpretation of Slepian–Wolf Coding We consider an interpretation of the corner points of the rate region in Slepian–Wolf encoding in terms of graph coloring. Consider the point with rate R 1 = H ( X ), R 2 = H ( Y | X ). Using nH ( X ) bits, we can encode X n efficiently, so that the decoder can reconstruct X n with arbitrarily low probability of error. But how do we code Y n with nH ( Y | X ) bits? Looking at the picture in terms of typical sets, we see that associated with every X n is a typical “fan” of Y n sequences that are jointly typical with the given X n as shown in Figure 15.22 . FIGURE 15.22. Jointly typical fans. If the Y encoder knows X n , the encoder can send the index of the Y n within this typical fan. The decoder, also knowing X n , can then construct this typical fan and hence reconstruct Y n . But the Y encoder does not know X n . So instead of trying to determine the typical fan, he randomly colors all Y n sequences with 2 nR 2 colors. If the number of colors is high enough, then with high probability all the colors in a particular fan will be different and the color of the Y n sequence will uniquely define the Y n sequence within the X n fan. If the rate R 2 > H ( Y | X ), the number of colors is exponentially larger than the number of elements in the fan and we can show that the scheme will have an exponentially small probability of error. 15.5 DUALITY BETWEEN SLEPIAN–WOLF ENCODING AND MULTIPLE-ACCESS CHANNELS With multiple-access channels, we considered the problem of sending independent messages over a channel with two inputs and only one output. With Slepian–Wolf encoding, we considered the problem of sending a correlated source over a noiseless channel, with a common decoder for recovery of both sources. In this section we explore the duality between the two systems. In Figure 15.23 , two independent messages are to be sent over the channel as X n 1 and X n 2 sequences. The receiver estimates the messages from the received sequence. In Figure 15.24 the correlated sources are encoded as “independent” messages i and j . The receiver tries to estimate the source sequences from knowledge of i and j . FIGURE 15.23. Multiple-access channels. FIGURE 15.24. Correlated source encoding. In the proof of the achievability of the capacity region for the multiple-access channel, we used a random map from the set of messages to the sequences X n 1 and X n 2 . In the proof for Slepian–Wolf coding, we used a random map from the set of sequences X n and Y n to a set of messages. In the proof of the coding theorem for the multiple-access channel, the probability of error was bounded by (15.197) (15.198) where is the probability the sequences are not typical, R i are the rates corresponding to the number of codewords that can contribute to the probability of error, and I i is the corresponding mutual information that corresponds to the probability that the codeword is jointly typical with the received sequence. In the case of Slepian–Wolf encoding, the corresponding expression for the probability of error is (15.199) (15.200) where again the probability that the constraints of the AEP are not satisfied is bounded by , and the other terms refer to the various ways in which another pair of sequences could be jointly typical and in the same bin as the given source pair. The duality of the multiple-access channel and correlated source encoding is now obvious. It is rather surprising that these two systems are duals of each other; one would have expected a duality between the broadcast channel and the multiple-access channel. 15.6 BROADCAST CHANNEL The broadcast channel is a communication channel in which there is one sender and two or more receivers. It is illustrated in Figure 15.25 . The basic problem is to find the set of simultaneously achievable rates for communication in a broadcast channel. Before we begin the analysis, let us consider some examples. FIGURE 15.25. Broadcast channel. Example 15.6.1 ( TV station ) The simplest example of the broadcast channel is a radio or TV station. But this example is slightly degenerate in the sense that normally the station wants to send the same information to everybody who is tuned in; the capacity is essentially max p ( x ) min i I ( X ; Y i ), which may be less than the capacity of the worst receiver. But we may wish to arrange the information in such a way that the better receivers receive extra information, which produces a better picture or sound, while the worst receivers continue to receive more basic information. As TV stations introduce high-definition TV (HDTV), it may be necessary to encode the information so that bad receivers will receive the regular TV signal, while good receivers will receive the extra information for the high-definition signal. The methods to accomplish this will be explained in the discussion of the broadcast channel. Example 15.6.2 ( Lecturer in classroom ) A lecturer in a classroom is communicating information to the students in the class. Due to differences among the students, they receive various amounts of information. Some of the students receive most of the information; others receive only a little. In the ideal situation, the lecturer would be able to tailor his or her lecture in such a way that the good students receive more information and the poor students receive at least the minimum amount of information. However, a poorly prepared lecture proceeds at the pace of the weakest student. This situation is another example of a broadcast channel. Example 15.6.3 ( Orthogonal broadcast channels ) The simplest broadcast channel consists of two independent channels to the two receivers. Here we can send independent information over both channels, and we can achieve rate R 1 to receiver 1 and rate R 2 to receiver 2 if R 1 < C 1 and R 2 < C 2 . The capacity region is the rectangle shown in Figure 15.26 . FIGURE 15.26. Capacity region for two orthogonal broadcast channels. Example 15.6.4 ( Spanish and Dutch speaker ) To illustrate the idea of superposition, we will consider a simplified example of a speaker who can speak both Spanish and Dutch. There are two listeners: One understands only Spanish and the other understands only Dutch. Assume for simplicity that the vocabulary of each language is 2 20 words and that the speaker speaks at the rate of 1 word per second in either language. Then he can transmit 20 bits of information per second to receiver 1 by speaking to her all the time; in this case, he sends no information to receiver 2. Similarly, he can send 20 bits per second to receiver 2 without sending any information to receiver 1. Thus, he can achieve any rate pair with R 1 + R 2 = 20 by simple time-sharing. But can he do better? Recall that the Dutch listener, even though he does not understand Spanish, can recognize when the word is Spanish. Similarly, the Spanish listener can recognize when Dutch occurs. The speaker can use this to convey information; for example, if the proportion of time he uses each language is 50%, then of a sequence of 100 words, about 50 will be Dutch and about 50 will be Spanish. But there are many ways to order the Spanish and Dutch words; in fact, there are about ways to order the words. Choosing one of these orderings conveys information to both listeners. This method enables the speaker to send information at a rate of 10 bits per second to the Dutch receiver, 10 bits per second to the Spanish receiver, and 1 bit per second of common information to both receivers, for a total rate of 21 bits per second, which is more than that achievable by simple timesharing. This is an example of superposition of information. The results of the broadcast channel can also be applied to the case of a single-user channel with an unknown distribution. In this case, the objective is to get at least the minimum information through when the channel is bad and to get some extra information through when the channel is good. We can use the same superposition arguments as in the case of the broadcast channel to find the rates at which we can send information. 15.6.1 Definitions for a Broadcast Channel Definition A broadcast channel consists of an input alphabet χ and two output alphabets, Y 1 and 2 , and a probability transition function p ( y 1 , y 2 | x ). The broadcast channel will be said to be memoryless if . We define codes, probability of error, achievability, and capacity regions for the broadcast channel as we did for the multiple-access channel. A ((2 nR 1 , 2 nR 2 ), n ) code for a broadcast channel with independent information consists of an encoder, (15.201) and two decoders, (15.202) and (15.203) We define the average probability of error as the probability that the decoded message is not equal to the transmitted message; that is, (15.204) where ( W 1 , W 2 ) are assumed to be uniformly distributed over 2 nR 1 × 2 nR 2 . Definition A rate pair ( R 1 , R 2 ) is said to be achievable for the broadcast channel if there exists a sequence of ((2 nR 1 , 2 nR 2 ), n ) codes with . We will now define the rates for the case where we have common information to be sent to both receivers. A ((2 nR 0 , 2 nR 1 , 2 nR 2 ), n ) code for a broadcast channel with common information consists of an encoder, (15.205) and two decoders, (15.206) and (15.207) Assuming that the distribution on ( W 0 , W 1 , W 2 ) is uniform, we can define the probability of error as the probability that the decoded message is not equal to the transmitted message: (15.208) Definition A rate triple ( R 0 , R 1 , R 2 ) is said to be achievable for the broadcast channel with common information if there exists a sequence of ((2 nR 0 , 2 nR 1 , 2 nR 2 ), n ) codes with → 0. Definition The capacity region of the broadcast channel is the closure of the set of achievable rates. We observe that an error for receiver Y n 1 depends only the distribution p ( x n , y n 1 ) and not on the joint distribution p ( x n , y n 1 , y n 2 ). Thus, we have the following theorem: Theorem 15.6.1 The capacity region of a broadcast channel depends only on the conditional marginal distributions p ( y 1 | x ) and p ( y 2 | x . Proof: See the problems. 15.6.2 Degraded Broadcast Channels Definition A broadcast channel is said to be physically degraded if p ( y 1 , y 2 | x ) = p ( y 1 | x ) p ( y 2 | y 1 ). Definition A broadcast channel is said to be stochastically degraded if its conditional marginal distributions are the same as that of a physically degraded broadcast channel; that is, if there exists a distribution p ’( y 2 | y 1 ) such that (15.209) Note that since the capacity of a broadcast channel depends only on the conditional marginals, the capacity region of the stochastically degraded broadcast channel is the same as that of the corresponding physically degraded channel. In much of the following, we therefore assume that the channel is physically degraded. 15.6.3 Capacity Region for the Degraded Broadcast Channel We now consider sending independent information over a degraded broadcast channel at rate R 1 to Y 1 and rate R 2 to Y 2 . Theorem 15.6.2 The capacity region for sending independent information over the degraded broadcast channel X → Y 1 → Y 2 is the convex hull of the closure of all ( R 1 , R 2 ) satisfying (15.210) (15.211) for some joint distribution p ( u ) p ( x | u ) p ( Y 1 , y 2 | x ), where the auxiliary random variable U has cardinality bounded by | U | ≤ min{| X |, | Y 1 |, | Y 2 }. Proof: (The cardinality bounds for the auxiliary random variable U are derived using standard methods from convex set theory and are not dealt with here.) We first give an outline of the basic idea of superposition coding for the broadcast channel. The auxiliary random variable U will serve as a cloud center that can be distinguished by both receivers Y 1 and Y 2 . Each cloud consists of 2 nR 1 codewords X n distinguishable by the receiver Y 1 . The worst receiver can only see the clouds, while the better receiver can see the individual codewords within the clouds. The formal proof of the achievability of this region uses a random coding argument: Fix p ( u ) and p ( x | u . Random codebook generation: Generate 2 nR 2 independent codewords of length n , U( w 2 ), w 2 {1, 2,…, 2 nR 2 }, according to . For each codeword U( w 2 ), generate 2 nR 1 independent codewords X ( w 1 , w 2 ) according to p ( x i | u i ( w 2 )). Here u ( i ) plays the role of the cloud center understandable to both Y 1 and Y 2 , while x ( i, j ) is the j th satellite codeword in the i th cloud. Encoding: To send the pair ( W 1 , W 2 ), send the corresponding codeword X ( W 1 , W 2 . Decoding: Receiver 2 determines the unique such that . If there are none such or more than one such, an error is declared. Receiver 1 looks for the unique such that . If there are none such or more than one such, an error is declared. Analysis of the probability of error: By the symmetry of the code generation, the probability of error does not depend on which codeword was sent. Hence, without loss of generality, we can assume that the message pair ( W 1 , W 2 ) = (1, 1) was sent. Let P (.) denote the conditional probability of an event given that (1,1) was sent. Since we have essentially a single-user channel from U to Y 2 , we will be able to decode the U codewords with a low probability of error if R 2 < I ( U ; Y 2 ). To prove this, we define the events (15.212) Then the probability of error at receiver 2 is (15.213) (15.214) (15.215) (15.216) if n is large enough and R 2 < I ( U ; Y 2 ), where (15.215) follows from the AEP. Similarly, for decoding for receiver 1, we define the events (15.217) (15.218) where the tilde refers to events defined at receiver 1. Then we can bound the probability of error as (15.219) (15.220) By the same arguments as for receiver 2, we can bound P ( Yi ) ≤ 2 − n (1( U ; Y 1 )-3 ) . Hence, the third term goes to 0 if R 2 < I ( U ; Y 1 ). But by the data-processing inequality and the degraded nature of the channel, I ( U ; Y 1 ) ≥ I ( U ; Y 2 ), and hence the conditions of the theorem imply that the third term goes to 0. We can also bound the fourth term in the probability of error as (15.221) (15.222) (15.223) (15.224) (15.225) (15.226) Hence, if R 1 < I ( X ; Y 1 | U ), the fourth term in the probability of error goes to 0. Thus, we can bound the probability of error (15.227) (15.228) if n is large enough and R 2 < I ( U ; Y 1 ) and R 1 < I ( X ; Y 1 | U ). The above bounds show that we can decode the messages with total probability of error that goes to 0. Hence, there exists a sequence of good ((2 nR 1 , 2 nR 2 ), n ) codes C * n with probability of error going to 0. With this, we complete the proof of the achievability of the capacity region for the degraded broadcast channel. Gallager’s proof [225] of the converse is outlined in Problem 15.11. So far we have considered sending independent information to each receiver. But in certain situations, we wish to send common information to both receivers. Let the rate at which we send common information be R 0 . Then we have the following obvious theorem: Theorem 15.6.3 If the rate pair ( R 1 , R 2 ) is achievable for a broadcast channel with independent information, the rate triple ( R 0 , R 1 − R 0 , R 2 − R 0 ) with a common rate R 0 is achievable, provided that R 0 ≤ min( R 1 , R 2 ). In the case of a degraded broadcast channel, we can do even better. Since by our coding scheme the better receiver always decodes all the information that is sent to the worst receiver, one need not reduce the amount of information sent to the better receiver when we have common information. Hence, we have the following theorem: Theorem 15.6.4 If the rate pair ( R 1 , R 2 ) is achievable for a degraded broadcast channel, the rate triple ( R 0 , R 1 , R 2 − R 0 ) is achievable for the channel with common information, provided that R 0 < R 2 . We end this section by considering the example of the binary symmetric broadcast channel. Example 15.6.5 Consider a pair of binary symmetric channels with parameters p 1 and p 2 that form a broadcast channel as shown in Figure 15.27 . Without loss of generality in the capacity calculation, we can recast this channel as a physically degraded channel. We assume that p 1 < p 2 < . Then we can express a binary symmetric channel with parameter p 2 as a cascade of a binary symmetric channel with parameter p 1 with another binary symmetric channel. Let the crossover probability of the new channel be α . Then we must have FIGURE 15.27. Binary symmetric broadcast channel. (15.229) or (15.230) We now consider the auxiliary random variable in the definition of the capacity region. In this case, the cardinality of U is binary from the bound of the theorem. By symmetry, we connect U to X by another binary symmetric channel with parameter β , as illustrated in Figure 15.28 . FIGURE 15.28. Physically degraded binary symmetric broadcast channel. We can now calculate the rates in the capacity region. It is clear by symmetry that the distribution on U that maximizes the rates is the uniform distribution on {0, 1}, so that (15.231) (15.232) where (15.233) Similarly, (15.234) (15.235) (15.236) where (15.237) Plotting these points as a function of β , we obtain the capacity region in Figure 15.29 . When β = 0, we have maximum information transfer to Y 2 [i.e., R 2 = 1 H ( p 2 ) and R 1 = 0]. When β = , we have maximum information transfer to Y 1 [i.e., R 1 = 1 − H ( p 1 )] and no information transfer to Y 2 . These values of β give us the corner points of the rate region. FIGURE 15.29. Capacity region of binary symmetric broadcast channel. Example 15.6.6 ( Gaussian broadcast channel ) The Gaussian broadcast channel is illustrated in Figure 15.30 . We have shown it in the case where one output is a degraded version of the other output. Based on the results of Problem 15.10, it follows that all scalar Gaussian broadcast channels are equivalent to this type of degraded channel. FIGURE 15.30. Gaussian broadcast channel. (15.238) (15.239) where Z 1 ~ N (0, N 1 ) and Z ′ 2 ~ N (0, N 2 − N 1 ). Extending the results of this section to the Gaussian case, we can show that the capacity region of this channel is given by (15.240) (15.241) where α may be arbitrarily chosen (0 ≤ α ≤ 1). The coding scheme that achieves this capacity region is outlined in Section 15.1.3. 15.7 RELAY CHANNEL The relay channel is a channel in which there is one sender and one receiver with a number of intermediate nodes that act as relays to help the communication from the sender to the receiver. The simplest relay channel has only one intermediate or relay node. In this case the channel consists of four finite sets χ , χ 1 , , and 1 and a collection of probability mass functions p ( y , y 1 | x , x 1 ) on × Y 1 , one for each ( x , x 1 ) X × X 1 . The interpretation is that x is the input to the channel and y is the output of the channel, y 1 is the relay’s observation, and x 1 is the input symbol chosen by the relay, as shown in Figure 15.31 . The problem is to find the capacity of the channel between the sender X and the receiver Y . FIGURE 15.31. Relay channel. The relay channel combines a broadcast channel ( X to Y and Y 1 ) and a multiple-access channel ( X and X 1 to Y ). The capacity is known for the special case of the physically degraded relay channel. We first prove an outer bound on the capacity of a general relay channel and later establish an achievable region for the degraded relay channel. Definition A (2 nR , n ) code for a relay channel consists of a set of integers W = {1, 2,…, 2 nR }, an encoding function (15.242) a set of relay functions such that (15.243) and a decoding function, (15.244) Note that the definition of the encoding functions includes the nonanticipatory condition on the relay. The relay channel input is allowed to depend only on the past observations Y 11 , Y 12 ,…, Y 1 i −1 . The channel is memoryless in the sense that ( Y i , Y 1 i ) depends on the past only through the current transmitted symbols ( X i , X 1 i ). Thus, for any choice p ( w ), w , and code choice X : {1, 2,…, 2 nR } → χ n i and relay functions , the joint probability mass function on is given by (15.245) If the message w [1, 2 nR ] is sent, let (15.246) denote the conditional probability of error. We define the average probability of error of the code as (15.247) The probability of error is calculated under the uniform distribution over the codewords w {1,…, 2 nR }. The rate R is said to be achievable by the relay channel if there exists a sequence of (2 nR , n ) codes with . The capacity C of a relay channel is the supremum of the set of achievable rates. We first give an upper bound on the capacity of the relay channel. Theorem 15.7.1 For any relay channel , the capacity C is bounded above by (15.248) Proof: The proof is a direct consequence of a more general max-flow min-cut theorem given in Section 15.10. This upper bound has a nice max-flow min-cut interpretation. The first term in (15.248) upper bounds the maximum rate of information transfer from senders X and X 1 to receiver Y . The second terms bound the rate from X to Y and Y 1 . We now consider a family of relay channels in which the relay receiver is better than the ultimate receiver Y in the sense defined below. Here the max-flow min-cut upper bound in the (15.248) is achieved. Definition The relay channel ( χ × χ 1 , p ( y , y 1 | x , x 1 ), × 1 ) is said to be physically degraded if p ( y , y 1 | x , x 1 ) can be written in the form (15.249) Thus, Y is a random degradation of the relay signal Y 1 . For the physically degraded relay channel, the capacity is given by the following theorem. Theorem 15.7.2 The capacity C of a physically degraded relay channel is given by (15.250) where the supremum is over all joint distributions on X × X 1 . Proof: Converse : The proof follows from Theorem 15.7.1 and by degradedness, since for the degraded relay channel, I ( X ; Y , Y 1 | X 1 ) = I ( X ; Y 1 | X 1 ). Achievability : The proof of achievability involves a combination of the following basic techniques: (1) random coding, (2) list codes, (3) Slepian–Wolf partitioning, (4) coding for the cooperative multiple-access channel, (5) superposition coding, and (6) block Markov encoding at the relay and transmitter. We provide only an outline of the proof. Outline of achievability : We consider B blocks of transmission, each of n symbols. A sequence of B − 1 indices, w i {1,…, 2 nR }, i = 1, 2,…, B − 1, will be sent over the channel in nB transmissions. (Note that as B → ∞ for a fixed n , the rate R ( B − 1)/ B is arbitrarily close to R .) We define a doubly indexed set of codewords: (15.251) We will also need a partition (15.252) into 2 nR 0 cells, with S i ∩ S j = φ, i ≠ j , and ∪ S i = W . The partition will enable us to send side information to the receiver in the manner of Slepian and Wolf [502]. Generation of random code: Fix p ( x 1 ) p ( x | x 1 ). First generate at random 2 nR 0 i.i.d. n -sequences in χ n 1 , each drawn according to . Index them as x 1 ( s ), s {1, 2,…, 2 nR 0 }. For each x 1 ( s ), generate 2 nR conditionally independent n -sequences x ( w | s ), w {1, 2,…, 2 nR , drawn independently according to . This defines the random codebook C = { x ( w | s ), x 1 ( s )}. The random partition S = { S 1 , S 2 ,…, S 2 nR 0 } of {1, 2,…, 2 nR } is defined as follows. Let each integer w {1, 2,…, 2 nR } be assigned independently, according to a uniform distribution over the indices s = 1, 2,…, 2 nR 0 , to cells S s . Encoding: Let w i {1, 2,…, 2 nR } be the new index to be sent in block i , and let s i be defined as the partition corresponding to w i −1 (i.e., w i −1 S s i ). The encoder sends x ( w i | s i ). The relay has an estimate of the previous index w i −1 . (This will be made precise in the decoding section.) Assume that . The relay encoder sends in block i . Decoding: We assume that at the end of block i − 1, the receiver knows ( w 1 , w 2 ,…, w i -2 ) and ( s 1 , s 2 ,…, s i −1 ) and the relay knows ( w 1 , w 2 ,…, w i −1 ) and consequently, ( s 1 , s 2 ,…, s i ). The decoding procedures at the end of block i are as follows: 1. Knowing s i and upon receiving Y 1 ( i ), the relay receiver estimates the message of the transmitter if and only if there exists a unique w such that ( x ( w | s i ), x 1 ( s i ), y 1 (i)) are jointly -typical. Using Theorem 15.2.3, it can be shown that with an arbitrarily small probability of error if (15.253) and n is sufficiently large. 2. The receiver declares that was sent iff there exists one and only one s such that ( x 1 ( s ), y ( i )) are jointly -typical. From Theorem 15.2.1 we know that s i can be decoded with arbitrarily small probability of error if (15.254) and n is sufficiently large. 3. Assuming that s i is decoded correctly at the receiver, the receiver constructs a list of indices that the receiver considers to be jointly typical with y ( i − 1) in the ( i − 1)th block. The receiver then declares as the index sent in block i − 1 if there is a unique . If n is sufficiently large and if (15.255) then with arbitrarily small probability of error. Combining the two constraints (15.254) and (15.255) , R 0 drops out, leaving (15.256) For a detailed analysis of the probability of error, the reader is referred to Cover and E1 Gamal [127]. Theorem 15.7.2 can also shown to be the capacity for the following classes of relay channels: 1. Reversely degraded relay channel, that is, (15.257) 2. Relay channel with feedback 3. Deterministic relay channel, (15.258) 15.8 SOURCE CODING WITH SIDE INFORMATION We now consider the distributed source coding problem where two random variables X and Y are encoded separately but only X is to be recovered. We now ask how many bits R 1 are required to describe X if we are allowed R 2 bits to describe Y . If R 2 > H ( Y ), then Y can be described perfectly, and by the results of Slepian–Wolf coding, R 1 = H ( X | Y ) bits suffice to describe X . At the other extreme, if R 2 = 0, we must describe X without any help, and R 1 = H ( X ) bits are then necessary to describe X . In general, we use R 2 = I ( Y ; ) bits to describe an approximate version of Y . This will allow us to describe X using H ( X | ) bits in the presence of side information . The following theorem is consistent with this intuition. Theorem 15.8.1 Let ( X , Y ) ~ p ( x , y ). If Y is encoded at rate R 2 and X is encoded at rate R 1 , we can recover X with an arbitrarily small probability of error if and only if (15.259) (15.260) for some joint probability mass function p ( x , y ) p ( u | y ), where + 2. We prove this theorem in two parts. We begin with the converse, in which we show that for any encoding scheme that has a small probability of error, we can find a random variable U with a joint probability mass function as in the theorem. Proof: ( Converse ). Consider any source code for Figure 15.32 . The source code consists of mappings f n ( X n ) and g n ( Y n ) such that the rates of f n and g n are less than R 1 and R 2 , respectively, and a decoding mapping h n such that FIGURE 15.32. Encoding with side information. (15.261) Define new random variables S = f n ( X n ) and T = g n ( Y n ). Then since we can recover X n from S and T with low probability of error, we have, by Fano’s inequality, (15.262) Then (15.263) (15.264) (15.265) (15.266) (15.267) where (a) follows from the fact that the range of g n is {1, 2,…, 2 nR 2 } (b) follows from the properties of mutual information (c) follows from the chain rule and the fact that Y i is independent of Y 1 ,…, Y i −1 and hence I ( Y i ; Y 1 ,…, Y i −1 ) = 0 (d) follows if we define U i = ( T , Y 1 ,…, Y i −1 ) We also have another chain for R 1 , (15.268) (15.269) (15.270) (15.271) (15.272) (15.273) (15.274) (15.275) (15.276) where (a) follows from the fact that the range of S is {1, 2,…, 2 nR 1 } (b) follows from the fact that conditioning reduces entropy (c) follows from Fano’s inequality (d) follows from the chain rule and the fact that S is a function of X n (e) follows from the chain rule for entropy (f) follows from the fact that conditioning reduces entropy (g) follows from the (subtle) fact that X i → ( T, Y i −1 ) ( T , Y i −1 ) → X i −1 forms a Markov chain since X i does not contain any information about X i −1 that is not there in Y i −1 and T (h) follows from the definition of U Also, since X i contains no more information about U i than is present in Y i , it follows that X i → Y i → U i forms a Markov chain. Thus we have the following inequalities: (15.277) (15.278) We now introduce a timesharing random variable Q so that we can rewrite these equations as (15.279) (15.280) Now since Q is independent of Y Q (the distribution of Y i does not depend on i ), we have (15.281) Now X Q and Y Q have the joint distribution p ( x , y ) in the theorem. Defining U = ( U Q , Q ), X = X Q , and Y = Y Q , we have shown the existence of a random variable U such that (15.282) (15.283) for any encoding scheme that has a low probability of error. Thus, the converse is proved. Before we proceed to the proof of the achievability of this pair of rates, we will need a new lemma about strong typicality and Markov chains. Recall the definition of strong typicality for a triple of random variables X , Y , and Z . A triplet of sequences x n , y n , z n is said to be -strongly typical if (15.284) In particular, this implies that ( x n , y n ) are jointly strongly typical and that ( y n , z n ) are also jointly strongly typical. But the converse is not true: The fact that ( x n , y n ) and does not in general imply that ( x n , y n , z n ) ( X , Y , Z ). But if X → Y → Z forms a Markov chain, this implication is true. We state this as a lemma without proof [53, 149]. Lemma 15.8.1 Let ( X , Y , Z ) form a Markov chain X → Y → Z [i.e., p ( x , y , z ) = p ( x , y ) p ( z | y ) ] . If for a given is drawn ~ , then Pr{( X n , y n , z n ) ( X , Y , Z )} > 1 − for n sufficiently large . Remark The theorem is true from the strong law of large numbers if . The Markovity of X → Y → Z is used to show that X n ~ p ( x i | y i ) is sufficient for the same conclusion. We now outline the proof of achievability in Theorem 15.8.1. Proof: ( Achievability in Theorem 15.8.1 ). Fix p ( u | y ). Calculate p ( u ) = ∑ y p ( y ) p ( u | y ). Generation of codebooks: Generate 2 nR 2 independent codewords of length n , U ( w 2 ), w 2 {1, 2,…, 2 nR 2 } according to . Randomly bin all the X n sequences into 2 nR 1 bins by independently generating an index b distributed uniformly on {1, 2,…, 2 nR 1 } for each X n . Let B ( i ) denote the set of X n sequences allotted to bin i . Encoding: The X sender sends the index i of the bin in which X n falls. The Y sender looks for an index s such that . If there is more than one such s , it sends the least. If there is no such U n ( s ) in the codebook, it sends s = 1. Decoding: The receiver looks for a unique X n B ( i ) such that . If there is none or more than one, it declares an error. Analysis of the probability of error: The various sources of error are as follows: 1. The pair ( X n , Y n ) generated by the source is not typical. The probability of this is small if n is large. Hence, without loss of generality, we can condition on the event that the source produces a particular typical sequence . 2. The sequence Y n is typical, but there does not exist a U n ( s ) in the codebook that is jointly typical with it. The probability of this is small from the arguments of Section 10.6, where we showed that if there are enough codewords; that is, if (15.285) we are very likely to find a codeword that is jointly strongly typical with the given source sequence. 3. The codeword U n ( s ) is jointly typical with y n but not with x n . But by Lemma 15.8.1, the probability of this is small since X → Y → U forms a Markov chain. 4. We also have an error if there exists another typical X n B ( i ) which is jointly typical with U n ( s ). The probability that any other X n is jointly typical with U n ( s ) is less than 2 − n ( I ( u ; x )-3 ) , and therefore the probability of this kind of error is bounded above by (15.286) which goes to 0 if R 1 > H ( X | U ). Hence, it is likely that the actual source sequence X n is jointly typical with U n ( s ) and that no other typical source sequence in the same bin is also jointly typical with U n ( s ). We can achieve an arbitrarily low probability of error with an appropriate choice of n and , and this completes the proof of achievability. 15.9 RATE DISTORTION WITH SIDE INFORMATION We know that R ( D ) bits are sufficient to describe X within distortion D . We now ask how many bits are required given side information Y . We begin with a few definitions. Let ( X i , Y i ) be i.i.d. ~ p ( x , y ) and encoded as shown in Figure 15.33 . FIGURE 15.33. Rate distortion with side information. Definition The rate distortion function with side information R y ( D ) is defined as the minimum rate required to achieve distortion D if the side information Y is available to the decoder. Precisely, R y ( D ) is the infimum of rates R such that there exist maps i n : χ n → {1,…, 2 nR }, g n : Y n × {1,…, 2 nR } → n such that (15.287) Clearly, since the side information can only help, we have R y ( D ) ≤ R ( D ). For the case of zero distortion, this is the Slepian–Wolf problem and we will need H ( X | Y ) bits. Hence, R y (0) = H ( X | Y ). We wish to determine the entire curve R y ( D ). The result can be expressed in the following theorem. Theorem 15.9.1 ( Rate distortion with side information ( Wyner and Ziv )) Let ( X , Y ) be drawn i.i.d. ~ p ( x , y ) and let d ( x n , n ) = be given. The rate distortion function with side information is (15.288) where the minimization is over all functions f : and conditional probability mass functions p ( w | x ), | W | ≤ | X | + 1, such that (15.289) The function f in the theorem corresponds to the decoding map that maps the encoded version of the X symbols and the side information Y to the output alphabet. We minimize over all conditional distributions on W and functions f such that the expected distortion for the joint distribution is less than D . We first prove the converse after considering some of the properties of the function R y ( D ) defined in (15.288) . Lemma 15.9.1 The rate distortion function with side information R y ( D ) defined in (15.288) is a nonincreasing convex function of D. Proof: The monotonicity of R y ( D ) follows immediately from the fact that the domain of minimization in the definition of R y ( D ) increases with D . As in the case of rate distortion without side information, we expect R y ( D ) to be convex. However, the proof of convexity is more involved because of the double rather than single minimization in the definition of R y ( D ) in (15.288) . We outline the proof here. Let D 1 and D 2 be two values of the distortion and let W 1 , f 1 and W 2 , f 2 be the corresponding random variables and functions that achieve the minima in the definitions of R y ( D 1 ) and R y ( D 2 ), respectively. Let Q be a random variable independent of X , Y , W 1 , and W 2 which takes on the value 1 with probability λ and the value 2 with probability 1 − λ . Define W = ( Q , W Q ) and let f ( W , Y ) = f Q ( W Q , Y ). Specifically, f ( W , Y ) = f 1 ( W 1 Y ) with probability λ and f ( W , Y ) = f 2 ( W 2 , Y ) with probability 1 − λ . Then the distortion becomes (15.290) (15.291) (15.292) and (15.288) becomes (15.293) (15.294) (15.295) (15.296) and hence (15.297) (15.298) (15.299) proving the convexity of R y ( D ). We are now in a position to prove the converse to the conditional rate distortion theorem. Proof: ( Converse to Theorem 15.9.1 ). Consider any rate distortion code with side information. Let the encoding function be f n : χ n → {1, 2,…, 2 nR }. Let the decoding function be g n : n × {1, 2,…, 2 nR } → , and let g ni : n × {1, 2,…, 2 nR } → denote the i th symbol produced by the decoding function. Let T = f n ( X n ) denote the encoded version of X n . We must show that if Ed ( X n , g n ( Y n , f n ( X n ))) ≤ D , then R ≥ R y ( D ). We have the following chain of inequalities: (15.300) (15.301) (15.302) (15.303) (15.304) (15.305) (15.306) (15.307) (15.308) (15.309) (15.310) (15.311) (15.312) (15.313) (15.314) (15.315) (15.316) where (a) follows from the fact that the range of T is {1, 2,…, 2 nR } (b) follows from the fact that conditioning reduces entropy (c) follows from the chain rule for mutual information (d) follows from the fact that X i is independent of the past and future Y ’s and X ’s given Y i (e) follows from the fact that conditioning reduces entropy (f) follows by defining (g) follows from the definition of mutual information (h) follows from the fact that since Y i depends only on X i and is conditionally independent of T and the past and future Y ’s, W i → X i → Y i forms a Markov chain (i) follows from the definition of the (information) conditional rate distortion function since , and hence I ( W i ; X i ) − I ( W i ; Y i ) ≥ min W:Ed ( X , )≤ D i I ( W ; X ) − I ( W ; Y ) = R y ( D i ) (j) follows from Jensen’s inequality and the convexity of the conditional rate distortion function (Lemma 15.9.1) (k) follows from the definition of It is easy to see the parallels between this converse and the converse for rate distortion without side information (Section 10.4). The proof of achievability is also parallel to the proof of the rate distortion theorem using strong typicality. However, instead of sending the index of the codeword that is jointly typical with the source, we divide these codewords into bins and send the bin index instead. If the number of codewords in each bin is small enough, the side information can be used to isolate the particular codeword in the bin at the receiver. Hence again we are combining random binning with rate distortion encoding to find a jointly typical reproduction codeword. We outline the details of the proof below. Proof: ( Achievability of Theorem 15.9.1 ). Fix p ( w | x ) and the function f ( w , y ). Calculate p ( w ) = ∑ x p ( x ) p ( w | x ). Generation of codebook: Let R 1 = I ( X ; W ) + . Generate 2 nR 1 i.i.d. codewords , and index them by s {1, 2,…, 2 nR 1 }. Let R 2 = I ( X ; W ) − I ( Y ; W ) + 5 . Randomly assign the indices s {1, 2,…, 2 nR 1 } to one of 2 nR 2 bins using a uniform distribution over the bins. Let B ( i ) denote the indices assigned to bin i . There are approximately 2 n ( R 1 – R 2 ) indices in each bin. Encoding: Given a source sequence X n , the encoder looks for a codeword W n ( s ) such that . If there is no such W n , the encoder sets s = 1. If there is more than one such s , the encoder uses the lowest s . The encoder sends the index of the bin in which s belongs. Decoding: The decoder looks for a W n ( s ) such that s B ( i ) and . If he finds a unique s , he then calculates n , where i = f ( W i , Y i ). If he does not find any such s or more than one such s , he sets n . = n , where n is an arbitrary sequence in . It does not matter which default sequence is used; we will show that the probability of this event is small. Analysis of the probability of error: As usual, we have various error events: 1. The pair ( X n , Y n ) . The probability of this event is small for large enough n by the weak law of large numbers. 2. The sequence X n is typical, but there does not exist an s such that ( X n , W n ( s )) A *( n ) . As in the proof of the rate distortion theorem, the probability of this event is small if (15.317) 3. The pair of sequences but (i.e., the codeword is not jointly typical with the Y n sequence). By the Markov lemma (Lemma 15.8.1), the probability of this event is small if n is large enough. 4. There exists another s ’ with the same bin index such that ( W n ( s ′), Y n ) . Since the probability that a randomly chosen W n is jointly typical with Y n is ≈ 2 − nI ( Y; W ) , the probability that there is another W n in the same bin that is typical with Y n is bounded by the number of codewords in the bin times the probability of joint typicality, that is, (15.318) which goes to zero since R 1 − R 2 < I ( Y; W ) − 3 . 5. If the index s is decoded correctly, ( X n , W n ( s )) A *( n ) . By item 1 we can assume that . Thus, by the Markov lemma, we have ( X n , Y n , W n ) A *( n ) and therefore the empirical joint distribution is close to the original distribution p ( x, y ) p ( w | x ) that we started with, and hence ( X n , n ) will have a joint distribution that is close to the distribution that achieves distortion D . Hence with high probability, the decoder will produce in such that the distortion between X n and n is close to nD . This completes the proof of the theorem. The reader is referred to Wyner and Ziv [574] for details of the proof. After the discussion of the various situations of compressing distributed data, it might be expected that the problem is almost completely solved, but unfortunately, this is not true. An immediate generalization of all the above problems is the rate distortion problem for correlated sources, illustrated in Figure 15.34 . This is essentially the Slepian–Wolf problem with distortion in both X and Y . It is easy to see that the three distributed source coding problems considered above are all special cases of this setup. Unlike the earlier problems, though, this problem has not yet been solved and the general rate distortion region remains unknown. FIGURE 15.34. Rate distortion for two correlated sources. 15.10 GENERAL MULTITERMINAL NETWORKS We conclude this chapter by considering a general multiterminal network of senders and receivers and deriving some bounds on the rates achievable for communication in such a network. A general multiterminal network is illustrated in Figure 15.35 . In this section, superscripts denote node indices and subscripts denote time indices. There are m nodes, and node i has an associated transmitted variable X ( i ) and a received variable Y ( i ) . FIGURE 15.35. General multiterminal network. The node i sends information at rate R ( ij ) to node j. We assume that all the messages W ( ij ) being sent from node i to node j are independent and uniformly distributed over their respective ranges . The channel is represented by the channel transition function p ( y (1) ,…, y ( m ) | x (1) ,…, x ( m ) ), which is the conditional probability mass function of the outputs given the inputs. This probability transition function captures the effects of the noise and the interference in the network. The channel is assumed to be memoryless (i.e., the outputs at any time instant depend only the current inputs and are conditionally independent of the past inputs). Corresponding to each transmitter–receiver node pair is a message . The input symbol X ( i ) at node i depends on W ( ij ) , j {1,…, m } and also on the past values of the received symbol Y ( i ) at node i . Hence, an encoding scheme of block length n consists of a set of encoding and decoding functions, one for each node: Encoders: The encoder maps the messages and past received symbols into the symbol transmitted at time k. Decoders: , j = 1, 2,…, m. The decoder j at node i maps the received symbols in each block and his own transmitted information to form estimates of the messages intended for him from node j, j = 1, 2,…, m. Associated with every pair of nodes is a rate and a corresponding probability of error that the message will not be decoded correctly, (15.319) where is defined under the assumption that all the messages are independent and distributed uniformly over their respective ranges. A set of rates { R ( ij ) } is said to be achievable if there exist encoders and decoders with block length n with → 0 as n → ∞ for all i, j {1, 2, …, m }. We use this formulation to derive an upper bound on the flow of information in any multiterminal network. We divide the nodes into two sets, S and the complement S c . We now bound the rate of flow of information from nodes in S to nodes in S c . See [514] Theorem 15.10.1 If the information rates { R ( ij ) } are achievable, there exists some joint probability distribution p ( x (1) , x (2) ,…, x ( m ) ) such that (15.320) for all S ⊂ {1, 2,…, m }. Thus, the total rate of flow of information across cut sets is bounded by the conditional mutual information. Proof: The proof follows the same lines as the proof of the converse for the multiple access channel. Let T = { i, j ) : i S, j S c ) be the set of links that cross from S to S c , and let T c be all the other links in the network. Then (15.321) (15.322) (15.323) (15.324) (15.325) (15.326) (15.327) (15.328) (15.329) (15.330) (15.331) (15.332) (15.333) (15.334) (15.335) (15.336) (15.337) (15.338) where (a) follows from the fact that the messages W ( ij ) are uniformly distributed over their respective ranges (b) follows from the definition of W ( T ) = { W ( ij ) : i S, j S c } and the fact that the messages are independent (c) follows from the independence of the messages for T and T c (d) follows from Fano’s inequality since the messages W ( T ) can be decoded from Y ( s ) and (e) is the chain rule for mutual information (f) follows from the definition of mutual information (g) follows from the fact that is a function of the past received symbols Y ( S c ) and the messages W ( T c ) and the fact that adding conditioning reduces the second term (h) follows from the fact that depends only on the current input symbols X ( S ) and (i) follows after we introduce a new timesharing random variable Q distributed uniformly on {0, 2,…, n } (j) follows from the definition of mutual information (k) follows from the fact that conditioning reduces entropy (l) follows from the fact that depends only on the inputs and and is conditionally independent of Q Thus, there exist random variables X ( s ) and X ( S c ) with some arbitrary joint distribution that satisfy the inequalities of the theorem. The theorem has a simple max-flow min-cut interpretation. The rate of flow of information across any boundary is less than the mutual information between the inputs on one side of the boundary and the outputs on the other side, conditioned on the inputs on the other side. The problem of information flow in networks would be solved if the bounds of the theorem were achievable. But unfortunately, these bounds are not achievable even for some simple channels. We now apply these bounds to a few of the channels that we considered earlier. Multiple-access channel. The multiple access channel is a network with many input nodes and one output node. For the case of a two-user multiple-access channel, the bounds of Theorem 15.10.1 reduce to (15.339) (15.340) (15.341) for some joint distribution p ( x 1 , x 2 ) p ( y | x 1 , x 2 ). These bounds coincide with the capacity region if we restrict the input distribution to be a product distribution and take the convex hull (Theorem 15.3.1). Relay channel. For the relay channel, these bounds give the upper bound of Theorem 15.7.1 with different choices of subsets as shown in Figure 15.36 . Thus, FIGURE 15.36. Relay channel. (15.342) This upper bound is the capacity of a physically degraded relay channel and for the relay channel with feedback [127]. To complement our discussion of a general network, we should mention two features of single-user channels that do not apply to a multiuser network. Source–channel separation theorem. In Section 7.13 we discussed the source–channel separation theorem, which proves that we can transmit the source noiselessly over the channel if and only if the entropy rate is less than the channel capacity. This allows us to characterize a source by a single number (the entropy rate) and the channel by a single number (the capacity). What about the multiuser case? We would expect that a distributed source could be transmitted over a channel if and only if the rate region for the noiseless coding of the source lay within the capacity region of the channel. To be specific, consider the transmission of a distributed source over a multiple-access channel, as shown in Figure 15.37 . Combining the results of Slepian–Wolf encoding with the capacity results for the multiple-access channel, we can show that we can transmit the source over the channel and recover it with a low probability of error if FIGURE 15.37. Transmission of correlated sources over a multiple-access channel. (15.343) (15.344) (15.345) for some distribution p ( q ) p ( x 1 | q ) p ( x 2 | q ) p ( y | x 1 , x 2 ). This condition is equivalent to saying that the Slepian–Wolf rate region of the source has a nonempty intersection with the capacity region of the multiple-access channel. But is this condition also necessary? No, as a simple example illustrates. Consider the transmission of the source of Example 15.4.2 over the binary erasure multiple-access channel (Example 15.3.3). The Slepian–Wolf region does not intersect the capacity region, yet it is simple to devise a scheme that allows the source to be transmitted over the channel. We just let X 1 = U and X 2 = V , and the value of Y will tell us the pair ( U , V ) with no error. Thus, the conditions (15.345) are not necessary. The reason for the failure of the source–channel separation theorem lies in the fact that the capacity of the multiple-access channel increases with the correlation between the inputs of the channel. Therefore, to maximize the capacity, one should preserve the correlation between the inputs of the channel. Slepian–Wolf encoding, on the other hand, gets rid of the correlation. Cover et al. [129] proposed an achievable region for transmission of a correlated source over a multiple access channel based on the idea of preserving the correlation. Han and Costa [273] have proposed a similar region for the transmission of a correlated source over a broadcast channel. Capacity regions with feedback. Theorem 7.12.1 shows that feedback does not increase the capacity of a single-user discrete memoryless channel. For channels with memory, on the other hand, feedback enables the sender to predict something about the noise and to combat it more effectively, thus increasing capacity. What about multiuser channels? Rather surprisingly, feedback does increase the capacity region of multiuser channels, even when the channels are memoryless. This was first shown by Gaarder and Wolf [220], who showed how feedback helps increase the capacity of the binary erasure multiple-access channel. In essence, feedback from the receiver to the two senders acts as a separate channel between the two senders. The senders can decode each other’s transmissions before the receiver does. They then cooperate to resolve the uncertainty at the receiver, sending information at the higher cooperative capacity rather than the noncooperative capacity. Using this scheme, Cover and Leung [133] established an achievable region for a multiple-access channel with feedback. Willems [557] showed that this region was the capacity for a class of multiple-access channels that included the binary erasure multiple-access channel. Ozarow [410] established the capacity region for a two-user Gaussian multiple-access channel. The problem of finding the capacity region for a multiple-access channel with feedback is closely related to the capacity of a two-way channel with a common output. There is as yet no unified theory of network information flow. But there can be no doubt that a complete theory of communication networks would have wide implications for the theory of communication and computation. SUMMARY Multiple-access channel. The capacity of a multiple-access channel ( χ 1 × χ 2 , p ( y | x 1 , x 2 ), ) is the closure of the convex hull of all ( R 1 , R 2 ) satisfying (15.346) (15.347) (15.348) for some distribution p 1 ( x 1 ) p 2 ( x 2 ) on χ 1 × χ 2 . The capacity region of the m -user multiple-access channel is the closure of the convex hull of the rate vectors satisfying (15.349) for some product distribution p 1 ( x 1 ) p 2 ( x 2 ) · · · p m ( x m ). Gaussian multiple-access channel. The capacity region of a two-user Gaussian multiple-access channel is (15.350) (15.351) (15.352) where (15.353) Slepian–Wolf coding. Correlated sources X and Y can be described separately at rates R 1 and R 2 and recovered with arbitrarily low probability of error by a common decoder if and only if (15.354) (15.355) (15.356) Broadcast channels. The capacity region of the degraded broadcast channel X → Y 1 → Y 2 is the convex hull of the closure of all ( R 1 , R 2 ) satisfying (15.357) (15.358) for some joint distribution p ( u ) p ( x |( u ) p ( y 1 , y 2 | x ). Relay channel. The capacity C of the physically degraded relay channel p ( y , y 1 | x , x 1 ) is given by (15.359) where the supremum is over all joint distributions on χ × χ 1 . Source coding with side information. Let ( X, Y ) ~ p ( x , y ). If Y is encoded at rate R 2 and X is encoded at rate R 1 , we can recover X with an arbitrarily small probability of error iff (15.360) (15.361) for some distribution p ( y, u ) such that X → Y → U . Rate distortion with side information. Let ( X, Y ) ~ p ( x, y ). The rate distortion function with side information is given by (15.362) where the minimization is over all functions f and conditional distributions p ( w | x ), |W| ≤ |X| + 1, such that (15.363) PROBLEMS 15.1 Cooperative capacity of a multiple-access channel (a) Suppose that X 1 and X 2 have access to both indices W 1 {1, 2 nR }, W 2 {1, 2 nR 2 }. Thus, the codewords X 1 ( W 1 ( W 2 ), X 2 ( W 1 , W 2 ) depend on both indices. Find the capacity region. (b) Evaluate this region for the binary erasure multiple access channel Y = X 1 + X 2 , X i {0, 1}. Compare to the noncooperative region. 15.2 Capacity of multiple-access channels. Find the capacity region for each of the following multiple-access channels: (a) Additive modulo 2 multiple-access channel. X 1 {0, 1}, X 2 {0, 1}, Y = X 1 ⊕ X 2 . (b) Multiplicative multiple-access channel. X 1 {−1, 1}, X 2 {-1, 1}, Y = X 1 · X 2 . 15.3 Cut-set interpretation of capacity region of multiple-access channel. For the multiple-access channel we know that ( R 1 , R 2 ) is achievable if (15.364) (15.365) (15.366) for X 1 , X 2 independent. Show, for X 1 , X 2 independent that Interpret the information bounds as bounds on the rate of flow across cut sets S 1 , S 2 , and S 3 . 15.4 Gaussian multiple-access channel capacity . For the AWGN multiple-access channel, prove, using typical sequences, the achievability of any rate pairs ( R 1 , R 2 ) satisfying (15.367) (15.368) (15.369) The proof extends the proof for the discrete multiple-access channel in the same way as the proof for the single-user Gaussian channel extends the proof for the discrete single-user channel. 15.5 Converse for the Gaussian multiple-access channel. Prove the converse for the Gaussian multiple-access channel by extending the converse in the discrete case to take into account the power constraint on the codewords. 15.6 Unusual multiple-access channel. Consider the following multiple-access channel: χ 1 = χ 2 = = {0, 1}. If ( X 1 , X 2 ) = (0, 0), then Y = 0. If ( X 1 , X 2 ) (0, 1), then Y = 1. If ( X 1 , X 2 ) = (1, 0), then Y = 1. If ( X 1 , X 2 ) = (1, 1), then Y = 0 with probability and Y = 1 with probability . (a) Show that the rate pairs (1,0) and (0,1) are achievable. (b) Show that for any nondegenerate distribution p ( x 1 ) p ( x 2 ), we have I ( X 1 , X 2 ; Y ) < 1. (c) Argue that there are points in the capacity region of this multiple-access channel that can only be achieved by timesharing; that is, there exist achievable rate pairs ( R 1 , R 2 ) that lie in the capacity region for the channel but not in the region defined by (15.370) (15.371) (15.372) for any product distribution p ( x 1 ) p ( x 2 ). Hence the operation of convexification strictly enlarges the capacity region. This channel was introduced independently by Csiszár and Körner [149] and Bierbaum and Wallmeier [59]. 15.7 Convexity of capacity region of broadcast channel . Let C ⊆ R 2 be the capacity region of all achievable rate pairs R = ( R 1 , R 2 ) for the broadcast channel. Show that C is a convex set by using a time-sharing argument. Specifically, show that if R (1) and R (2) are achievable, λ R (1) + (1 − λ) R (2) is achievable for 0 ≤ λ ≤ 1. 15.8 Slepian–Wolf for deterministically related sources. Find and sketch the Slepian–Wolf rate region for the simultaneous data compression of ( X, Y ), where y = f ( x ) is some deterministic function of x . 15.9 Slepian-Wolf . Let X i be i.i.d. Bemoulli( p ). Let Z i be i.i.d. ~ Bernoulli( r ), and let Z be independent of X . Finally, let Y = X ⊕ Z (mod 2 addition). Let X be described at rate R 1 and Y be described at rate R 2 . What region of rates allows recovery of X , Y with probability of error tending to zero? 15.10 Broadcast capacity depends only on the conditional marginals. Consider the general broadcast channel ( X, Y 1 × Y 2 , p ( y 1 , y 2 | x )). Show that the capacity region depends only on p ( y 1 | x ) and p ( y 2 | x ). To do this, for any given ((2 nR 1 , 2 nR 2 ), n ) code, let (15.373) (15.374) (15.375) Then show that The result now follows by a simple argument. ( Remark: The probability of error P ( n ) does depend on the conditional joint distribution p ( y 1 , y 2 | x ). But whether or not P ( n ) can be driven to zero [at rates ( R 1 , R 2 )] does not [except through the conditional marginals p ( y 1 , | x ), p ( y 2 | x )].) 15.11 Converse for the degraded broadcast channel . The following chain of inequalities proves the converse for the degraded discrete memoryless broadcast channel. Provide reasons for each of the labeled inequalities. Setup for converse for degraded broadcast channel capacity: Encoding f n : 2 nR 1 × 2 nR 2 → X n Decoding: g n : Y n 1 → 2 nR 1 , h n : 2 nR 2 . Let U i = ( W 2 , Y i −1 1 ). Then (15.376) (15.377) (15.378) (15.379) (15.380) (15.381) Continuation of converse: Give reasons for the labeled inequalities: (15.382) (15.383) (15.384) (15.385) (15.386) Now let Q be a time-sharing random variable with Pr( Q = i ) =, 1/ n i = 1, 2,…, n . Justify the following: (15.387) (15.388) for some distribution p ( q ) p ( u | q ) p ( x | u, q ) p ( y 1 , y 2 | x ). By appropriately redefining U , argue that this region is equal to the convex closure of regions of the form (15.389) (15.390) for some joint distribution p ( u ) p ( x | u ) p ( y 1 , y 2 | x ). 15.12 Capacity points. (a) For the degraded broadcast channel X → Y 1 , → Y 2 , find the points a and b where the capacity region hits the R 1 and R 2 axes. (b) Show that b < a. 15.13 Degraded broadcast channel. Find the capacity region for the degraded broadcast channel shown below. 15.14 Channels with unknown parameters. We are given a binary symmetric channel with parameter p . The capacity is C = 1 − H ( p ). Now we change the problem slightly. The receiver knows only that p { p 1 , p 2 } (i.e., p = p 1 or p = p 2 , where p 1 and p 2 are given real numbers). The transmitter knows the actual value of p . Devise two codes for use by the transmitter, one to be used if p = p 1 , the other to be used if p = p 2 , such that transmission to the receiver can take place at rate ≈ C ( p 1 ) if p = p 1 and at rate ≈ C ( p 2 ) if p = p 2 . ( Hint: Devise a method for revealing p to the receiver without affecting the asymptotic rate. Prefixing the codeword by a sequence of 1’s of appropriate length should work.) 15.15 Two-way channel . Consider the two-way channel shown in Figure 15.6 . The outputs Y 1 and Y 2 depend only on the current inputs X 1 and X 2 . (a) By using independently generated codes for the two senders, show that the following rate region is achievable: (15.391) (15.392) for some product distribution p ( x 1 , x 2 ) p ( y 1 , y 2 | x 1 , x 2 ). (b) Show that the rates for any code for a two-way channel with arbitrarily small probability of error must satisfy (15.393) (15.394) for some joint distribution p ( x 1 , x 2 ) p ( y 1 , y 2 | x 1 , x 2 ). The inner and outer bounds on the capacity of the two-way channel are due to Shannon [486]. He also showed that the inner bound and the outer bound do not coincide in the case of the binary multiplying channel χ 1 = χ 2 = 1 = 2 = {0, 1}, Y 1 = Y 2 = X 1 X 2 . The capacity of the two-way channel is still an open problem. 15.16 Multiple-access channel . Let the output Y of a multiple-access channel be given by where X 1 , X 2 are both real and power limited, and sgn(x) = . Note that there is interference but no noise in this channel. (a) Find the capacity region. (b) Describe a coding scheme that achieves the capacity region. 15.17 Slepian-Wolf . Let ( X , Y ) have the joint probability mass function p ( x, y ): where . ( Note: This is a joint, not a conditional, probability mass function.) (a) Find the Slepian-Wolf rate region for this source. (b) What is Pr{ X = Y } in terms of α? (c) What is the rate region if alpha; = ? (d) What is the rate region if α = ;? 15.18 Square channel . What is the capacity of the following multiple-access channel? (a) Find the capacity region. (b) Describe p *( x 1 ), p * ( x 2 ) achieving a point on the boundary of the capacity region. 15.19 Slepian–Wolf . Two senders know random variables U 1 and U 2 , respectively. Let the random variables ( U 1 , U 2 ) have the following joint distribution: where α + β + γ = 1. Find the region of rates ( R 1 , R 2 ) that would allow a common receiver to decode both random variables reliably. 15.20 Multiple access (a) Find the capacity region for the multiple-access channel where (b) Suppose that the range of X 1 is {1, 2}. Is the capacity region decreased? Why or why not? 15.21 Broadcast channel . Consider the following degraded broadcast channel. (a) What is the capacity of the channel from X to Y 1 ? (b) What is the channel capacity from X to Y 2 ? (c) What is the capacity region of all ( R 1 , R 2 ) achievable for this broadcast channel? Simplify and sketch. 15.22 Stereo . The sum and the difference of the right and left ear signals are to be individually compressed for a common receiver. Let Z 1 be Bernoulli ( p 1 ) and Z 2 be Bernoulli ( p 2 ) and suppose that Z 1 and Z 2 are independent. Let X = Z 1 = Z 2 , and Y = Z 1 − Z 2 . (a) What is the Slepian–Wolf rate region of achievable ( R x , R Y )? (b) Is this larger or smaller than the rate region of ( R z 1 , R Z 2 )? Why? There is a simple way to do this part. 15.23 Multiplicative multiple-access channel. Find and sketch the capacity region of the following multiplicative multiple-access channel: with X 1 {0, 1}, X 2 {1, 2, 3}, and Y = X 1 X 2 . 15.24 Distributed data compression . Let Z 1 , Z 2 , Z 3 be independent Bernoulli( p ). Find the Slepian–Wolf rate region for the description of ( X 1 , X 2 , X 3 ), where 15.25 Noiseless multiple-access channel . Consider the following multiple-access channel with two binary inputs X 1 , X 2 {0, 1} and output Y = ( X 1 , X 2 ). (a) Find the capacity region. Note that each sender can send at capacity. (b) Now consider the cooperative capacity region, R 1 ≥ 0, R 2 ≥ 0, R 1 + R 2 ≤ max p ( x 1 , x 2 ) I ( X 1 , X 2 ; Y ). Argue that the throughput R 1 + R 2 does not increase but the capacity region increases. 15.26 Infinite bandwidth multiple-access channel . Find the capacity region for the Gaussian multiple-access channel with infinite bandwidth. Argue that all senders can send at their individual capacities (i.e., infinite bandwidth eliminates interference). 15.27 Multiple-access identity . Let C ( x ) = log(1 + x ) denote the channel capacity of a Gaussian channel with signal-to-noise ratio x . Show that This suggests that two independent users can send information as well as if they had pooled their power. 15.28 Frequency-division multiple access ( FDMA ). Maximize the throughput + ( W − W 1 ) log(1 + over W 1 to show that bandwidth should be proportional to transmitted power for FDMA. 15.29 Trilingual-speaker broadcast channel. A speaker of Dutch, Spanish, and French wishes to communicate simultaneously to three people: D, S , and F. D knows only Dutch but can distinguish when a Spanish word is being spoken as distinguished from a French word; similarly for the other two, who know only Spanish and French, respectively, but can distinguish when a foreign word is spoken and which language is being spoken. Suppose that each language, Dutch, Spanish, and French, has M words: M words of Dutch, M words of French, and M words of Spanish. (a) What is the maximum rate at which the trilingual speaker can speak to D ? (b) If he speaks to D at the maximum rate, what is the maximum rate at which he can speak simultaneously to S ? (c) If he is speaking to D and S at the joint rate in part (b), can he also speak to F at some positive rate? If so, what is it? If not, why not? 15.30 Parallel Gaussian channels from a mobile telephone. Assume that a sender X is sending to two fixed base stations. Assume that the sender sends a signal X that is constrained to have average power P . Assume that the two base stations receive signals Y 1 and Y 2 , where where , and Z 1 and Z 2 are independent. We will assume the α’s are constant over a transmitted block. (a) Assuming that both signals Y 1 and Y 2 are available at a common decoder Y = ( Y 1 , Y 2 ), what is the capacity of the channel from the sender to the common receiver? (b) If, instead, the two receivers Y 1 and Y 2 each decode their signals independently, this becomes a broadcast channel. Let R 1 be the rate to base station 1 and R 2 be the rate to base station 2. Find the capacity region of this channel. 15.31 Gaussian multiple access. A group of m users, each with power P , is using a Gaussian multiple-access channel at capacity, so that (15.395) where C ( x ) = log(1 + x ) and N is the receiver noise power. A new user of power P 0 wishes to join in. (a) At what rate can he send without disturbing the other users? (b) What should his power P 0 be so that the new users’ rate is equal to the combined communication rate C ( m P / N ) of all the other users? 15.32 Converse for deterministic broadcast channel . A deterministic broadcast channel is defined by an input X and two outputs, Y 1 and Y 2 , which are functions of the input X . Thus, Y 1 = f 1 ( X ) and Y 2 = f 2 ( X ). Let R 1 and R 2 be the rates at which information can be sent to the two receivers. Prove that (15.396) (15.397) (15.398) 15.33 Multiple-access channel . Consider the multiple-access channel Y = X 1 + X 2 (mod 4), where X 1 {0, 1, 2, 3}, X 2 {0, 1}. (a) Find the capacity region ( R 1 , R 2 ). (b) What is the maximum throughput R 1 + R 2 ? 15.34 Distributed source compression. Let and let U = Z 1 Z 2 , V = Z 1 + Z 2 . Assume that Z 1 and Z 2 are independent. This induces a joint distribution on ( U, V ). Let ( U i , V i ) be i.i.d. according to this distribution. Sender 1 describes U n at rate R 1 , and sender 2 describes V n at rate R 2 . (a) Find the Slepian–Wolf rate region for recovering ( U n , V n ) at the receiver. (b) What is the residual uncertainty (conditional entropy) that the receiver has about ( X n , Y n ). 15.35 Multiple-access channel capacity with costs . The cost of using symbol x is r ( x ). The cost of a codeword x n is r ( x n ) = . A (2 nR , n ) codebook satisfies cost constraint r if . (a) Find an expression for the capacity C ( r ) of a discrete memoryless channel with cost constraint r . (b) Find an expression for the multiple-access channel capacity region for ( χ 1 × χ 2 , p ( y | x 1 , x 2 ), ) if sender X 1 has cost constraint r 1 and sender X 2 has cost constraint r 2 . (c) Prove the converse for part (b). 15.36 Slepian–Wolf . Three cards from a three-card deck are dealt, one to sender X 1 , one to sender X 2 , and one to sender X 3 . At what rates do X 1 , X 2 , and X 3 need to communicate to some receiver so that their card information can be recovered? Assume that ( X 1 i , X 2 i , X 3 i ) are drawn i.i.d. from a uniform distribution over the permutations of {1, 2, 3}. HISTORICAL NOTES This chapter is based on the review in E1 Gamal and Cover [186]. The two-way channel was studied by Shannon [486] in 1961. He derived inner and outer bounds on the capacity region. Dueck [175] and Schalkwijk [464, 465] suggested coding schemes for two-way channels that achieve rates exceeding Shannon’s inner bound; outer bounds for this channel were derived by Zhang et al. [596] and Willems and Hekstra [558]. The multiple-access channel capacity region was found by Ahlswede [7] and Liao [355] and was extended to the case of the multiple-access channel with common information by Slepian and Wolf [501]. Gaarder and Wolf [220] were the first to show that feedback increases the capacity of a discrete memoryless multiple-access channel. Cover and Leung [133] proposed an achievable region for the multiple-access channel with feedback, which was shown to be optimal for a class of multiple-access channels by Willems [557]. Ozarow [410] has determined the capacity region for a two-user Gaussian multiple-access channel with feedback. Cover et al. [129] and Ahlswede and Han [12] have considered the problem of transmission of a correlated source over a multiple-access channel. The Slepian–Wolf theorem was proved by Slepian and Wolf [502] and was extended to jointly ergodic sources by a binning argument in Cover [122]. Superposition coding for broadcast channels was suggested by Cover in 1972 [119]. The capacity region for the degraded broadcast channel was determined by Bergmans [55] and Gallager [225]. The superposition codes for the degraded broadcast channel are also optimal for the less noisy broadcast channel (Körner and Marton [324]), the more capable broadcast channel (E1 Gamal [185]), and the broadcast channel with degraded message sets (Körner and Marton [325]). Van der Meulen [526] and Cover [121] proposed achievable regions for the general broadcast channel. The capacity of a deterministic broadcast channel was found by Gelfand and Pinsker [242, 243, 423] and Marton [377]. The best known achievable region for the broadcast channel is due to Marton [377]; a simpler proof of Marton’s region was given by El Gamal and Van der Meulen [188]. E1 Gamal [184] showed that feedback does not increase the capacity of a physically degraded broadcast channel. Dueck [176] introduced an example to illustrate that feedback can increase the capacity of a memoryless broadcast channel; Ozarow and Leung [411] described a coding procedure for the Gaussian broadcast channel with feedback that increased the capacity region. The relay channel was introduced by Van der Meulen [528]; the capacity region for the degraded relay channel was determined by Cover and E1 Gamal [127]. Carleial [85] introduced the Gaussian interference channel with power constraints and showed that very strong interference is equivalent to no interference at all. Sato and Tanabe [459] extended the work of Carleial to discrete interference channels with strong interference. Sato [457] and Benzel [51] dealt with degraded interference channels. The best known achievable region for the general interference channel is due to Han and Kobayashi [274]. This region gives the capacity for Gaussian interference channels with interference parameters greater than 1, as was shown in Han and Kobayashi [274] and Sato [458]. Carleial [84] proved new bounds on the capacity region for interference channels. The problem of coding with side information was introduced by Wyner and Ziv [573] and Wyner [570]; the achievable region for this problem was described in Ahlswede and Korner [13], Gray and Wyner [261], and Wyner [571],[572]. The problem of finding the rate distortion function with side information was solved by Wyner and Ziv [574]. The channel capacity counterpart of rate distortion with side information was solved by Gelfand and Pinsker [243]; the duality between the two results is explored in Cover and Chiang [113]. The problem of multiple descriptions is treated in E1 Gamal and Cover [187]. The special problem of encoding a function of two random variables was discussed by Körner and Marton [326], who described a simple method to encode the modulo 2 sum of two binary random variables. A general framework for the description of source networks may be found in Csiszár and Körner [148],[149]. A common model that includes Slepian–Wolf encoding, coding with side information, and rate distortion with side information as special cases was described by Berger and Yeung [54]. In 1989, Ahlswede and Dueck [17] introduced the problem of identification via communication channels, which can be viewed as a problem where the sender sends information to the receivers but each receiver only needs to know whether or not a single message was sent. In this case, the set of possible messages that can be sent reliably is doubly exponential in the block length, and the key result of this paper was to show that 2 2 nC messages could be identified for any noisy channel with capacity C. This problem spawned a set of papers [16, 18, 269, 434], including extensions to channels with feedback and multiuser channels. Another active area of work has been the analysis of MIMO (multiple-input multiple-output) systems or space-time coding, which use multiple antennas at the transmitter and receiver to take advantage of the diversity gains from multipath for wireless systems. The analysis of these multiple antenna systems by Foschini [217], Teletar [512], and Rayleigh and Cioffi [246] show that the capacity gains from the diversity obtained using multiple antennas in fading environments can be substantial relative to the single-user capacity achieved by traditional equalization and interleaving techniques. A special issue of the IEEE Transactions in Information Theory [70] has a number of papers covering different aspects of this technology. Comprehensive surveys of network information theory may be found in E1 Gamal and Cover [186], Van der Meulen [526–528], Berger [53], Csiszár and Körner [149], Verdu [538], Cover [111], and Ephremides and Hajek [197].

Chapter 16: Information Theory and Portfolio Theory CHAPTER 16 INFORMATION THEORY AND PORTFOLIO THEORY The duality between the growth rate of wealth in the stock market and the entropy rate of the market is striking. In particular, we shall find the competitively optimal and growth rate optimal portfolio strategies. They are the same, just as the Shannon code is optimal both competitively and in the expected description rate. We also find the asymptotic growth rate of wealth for an ergodic stock market process. We end with a discussion of universal portfolios that enable one to achieve the same asymptotic growth rate as the best constant rebalanced portfolio in hindsight. In Section 16.8 we provide a “sandwich” proof of the asymptotic equipartition property for general ergodic processes that is motivated by the notion of optimal portfolios for stationary ergodic stock markets. 16.1 THE STOCK MARKET: SOME DEFINITIONS A stock market is represented as a vector of stocks X = ( X 1 , X 2 ,…, X m ), X i ≥ 0, i = 1, 2,…, m , where m is the number of stocks and the price relative X i is the ratio of the price at the end of the day to the price at the beginning of the day. So typically, X i is near 1. For example, X i = 1.03 means that the i th stock went up 3 percent that day. Let X ~ F ( x ), where F ( x ) is the joint distribution of the vector of price relatives. A portfolio b = ( b 1 , b 2 ,…, b m ), b i ≥ 0, ∑ b i = 1, is an allocation of wealth across the stocks. Here b i is the fraction of one’s wealth invested in stock i . If one uses a portfolio b and the stock vector is X , the wealth relative (ratio of the wealth at the end of the day to the wealth at the beginning of the day) is S = b t X = . We wish to maximize S in some sense. But S is a random variable, the distribution of which depends on portfolio b , so there is controversy over the choice of the best distribution for S . The standard theory of stock market investment is based on consideration of the first and second moments of S . The objective is to maximize the expected value of S subject to a constraint on the variance. Since it is easy to calculate these moments, the theory is simpler than the theory that deals with the entire distribution of S . The mean–variance approach is the basis of the Sharpe–Markowitz theory of investment in the stock market and is used by business analysts and others. It is illustrated in Figure 16.1 . The figure illustrates the set of achievable mean–variance pairs using various portfolios. The set of portfolios on the boundary of this region corresponds to the undominated portfolios: These are the portfolios that have the highest mean for a given variance. This boundary is called the efficient frontier , and if one is interested only in mean and variance, one should operate along this boundary. FIGURE 16.1. Sharpe–Markowitz theory: set of achievable mean–variance pairs. Normally, the theory is simplified with the introduction of a risk free asset (e.g., cash or Treasury bonds, which provide a fixed interest rate with zero variance). This stock corresponds to a point on the Y axis in the figure. By combining the risk-free asset with various stocks, one obtains all points below the tangent from the risk-free asset to the efficient frontier. This line now becomes part of the efficient frontier. The concept of the efficient frontier also implies that there is a true price for a stock corresponding to its risk. This theory of stock prices, called the capital asset pricing model (CAPM), is used to decide whether the market price for a stock is too high or too low. Looking at the mean of a random variable gives information about the long-term behavior of the sum of i.i.d. versions of the random variable. But in the stock market, one normally reinvests every day, so that the wealth at the end of n days is the product of factors, one for each day of the market. The behavior of the product is determined not by the expected value but by the expected logarithm. This leads us to define the growth rate as follows: Definition The growth rate of a stock market portfolio b with respect to a stock distribution F ( x ) is defined as (16.1) If the logarithm is to base 2, the growth rate is also called the doubling rate. Definition The optimal growth rate W * ( F ) is defined as (16.2) where the maximum is over all possible portfolios b i ≥ 0, ∑ i b i = 1. Definition A portfolio b * that achieves the maximum of W ( b , F ) is called a log-optimal portfolio or growth optimal portfolio . The definition of growth rate is justified by the following theorem, which shows that wealth grows as 2 nW * . Theorem 16.1.1 Let X 1 , X 2 ,…, X n be i.i.d. according to F ( x ). Let (16.3) be the wealth after n days using the constant rebalanced portfolio b *. Then (16.4) Proof: By the strong law of large numbers, (16.5) (16.6) Hence, S * n 2 nW *. We now consider some of the properties of the growth rate. Lemma 16.1.1 W ( b , F ) is concave in b and linear in F. W *( F ) is convex in F. Proof: The growth rate is (16.7) Since the integral is linear in F , so is W ( b , F ). Since (16.8) by the concavity of the logarithm, it follows, by taking expectations, that W ( b , F ) is concave in b . Finally, to prove the convexity of W * ( F ) as a function of F , let F 1 and F 2 be two distributions on the stock market and let the corresponding optimal portfolios be b *( F 1 ) and b * ( F 2 ), respectively. Let the log-optimal portfolio corresponding to λ F 1 + (1 – λ ) F 2 be b * ( λ F 1 + (1 – λ ) F 2 ). Then by linearity of W ( b , F ) with respect to F , we have (16.9) (16.10) since b * ( F 1 ) maximizes W ( b , F 1 ) and b * ( F 2 ) maximizes W ( b , F 2 ). Lemma 16.1.2 The set of log-optimal portfolios with respect to a given distribution is convex. Proof: Suppose that b 1 and b 2 are log-optimal (i.e., W ( b 1 , F ) = W ( b 2 , F ) = W * ( F )). By the concavity of W ( b , F ) in b , we have (16.11) Thus, λ b 1 + (1 − λ ) b 2 is also log-optimal. In the next section we use these properties to characterize the log-optimal portfolio. 16.2 KUHN–TUCKER CHARACTERIZATION OF THE LOG-OPTIMAL PORTFOLIO Let denote the set of allowed portfolios. The determination of b * that achieves W * ( F ) is a problem of maximization of a concave function W ( b , F ) over a convex set . The maximum may lie on the boundary. We can use the standard Kuhn–Tucker conditions to characterize the maximum. Instead, we derive these conditions from first principles. Theorem 16.2.1 The log-optimal portfolio b * for a stock market X ~ F (i.e., the portfolio that maximizes the growth rate W ( b , F )) satisfies the following necessary and sufficient conditions: (16.12) Proof: The growth rate W ( b ) = E (ln b t X ) is concave in b , where b ranges over the simplex of portfolios. It follows that b * is log-optimum if the directional derivative of W (·) in the direction from b * to any alternative portfolio b is nonpositive. Thus, letting b λ = (1 − λ ) b * + λ b for 0 ≤ λ ≤ 1, we have (16.13) These conditions reduce to (16.12) since the one-sided derivative at λ = 0+ of W ( b & lambda; ) is (16.14) (16.15) (16.16) where the interchange of limit and expectation can be justified using the dominated convergence theorem [39]. Thus, (16.13) reduces to (16.17) for all . If the line segment from b to b * can be extended beyond b * in the simplex, the two-sided derivative at λ = 0 of W ( b λ ) vanishes and (16.17) holds with equality. If the line segment from b to b * cannot be extended because of the inequality constraint on b , we have an inequality in (16.17). The Kuhn–Tucker conditions will hold for all portfolios b if they hold for all extreme points of the simplex since E ( b t X / b * t X ) is linear in b . Furthermore, the line segment from the j th extreme point ( b : b j = 1, b i = 0, i ≠ j ) to b * can be extended beyond b * in the simplex iff b * j > 0. Thus, the Kuhn–Tucker conditions that characterize the log-optimum b * are equivalent to the following necessary and sufficient conditions: (16.18) This theorem has a few immediate consequences. One useful equivalence is expressed in the following theorem. Theorem 16.2.2 Let S * = b * t X be the random wealth resulting from the log-optimal portfolio b *. Let S = b t X be the wealth resulting from any other portfolio b . Then (16.19) Proof: From Theorem 16.2.1 it follows that for a log-optimal portfolio b *, (16.20) for all i . Multiplying this equation by b i and summing over i , we have (16.21) which is equivalent to (16.22) The converse follows from Jensen’s inequality, since (16.23) Maximizing the expected logarithm was motivated by the asymptotic growth rate. But we have just shown that the log-optimal portfolio, in addition to maximizing the asymptotic growth rate, also “maximizes” the expected wealth relative E ( S / S *) for one day. We shall say more about the short-term optimality of the log-optimal portfolio when we consider the game-theoretic optimality of this portfolio. Another consequence of the Kuhn–Tucker characterization of the log-optimal portfolio is the fact that the expected proportion of wealth in each stock under the log-optimal portfolio is unchanged from day to day. Consider the stocks at the end of the first day. The initial allocation of wealth is b *. The proportion of the wealth in stock i at the end of the day is , and the expected value of this proportion is (16.24) Hence, the proportion of wealth in stock i expected at the end of the day is the same as the proportion invested in stock i at the beginning of the day. This is a counterpart to Kelly proportional gambling, where one invests in proportions that remain unchanged in expected value after the investment period. 16.3 ASYMPTOTIC OPTIMALITY OF THE LOG-OPTIMAL PORTFOLIO In Section 16.2 we introduced the log-optimal portfolio and explained its motivation in terms of the long-term behavior of a sequence of investments in a repeated independent versions of the stock market. In this section we expand on this idea and prove that with probability 1, the conditionally log-optimal investor will not do any worse than any other investor who uses a causal investment strategy. We first consider an i.i.d. stock market (i.e., X 1 , X 2 ,…, X n are i.i.d. according to F ( x )). Let (16.25) be the wealth after n days for an investor who uses portfolio b i on day i . Let (16.26) be the maximal growth rate, and let b * be a portfolio that achieves the maximum growth rate. We only allow alternative portfolios b i that depend causally on the past and are independent of the future values of the stock market. Definition A nonanticipating or causal portfolio strategy is a sequence of mappings b i : , with the interpretation that portfolio b i ( x 1 ,…, x i −1) is used on day i . From the definition of W *, it follows immediately that the log-optimal portfolio maximizes the expected log of the final wealth. This is stated in the following lemma. Lemma 16.3.1 Let S* n be the wealth after n days using the log-optimal strategy b * on i.i.d. stocks, and let S n be the wealth using a causal portfolio strategy b i . Then (16.27) Proof (16.28) (16.29) (16.30) (16.31) and the maximum is achieved by a constant portfolio strategy b *. So far, we have proved two simple consequences of the definition of log-optimal portfolios: that b * (satisfying (16.12) ) maximizes the expected log wealth, and that the resulting wealth S * n is equal to 2 nW * to first order in the exponent, with high probability. Now we prove a much stronger result, which shows that S * n exceeds the wealth (to first order in the exponent) of any other investor for almost every sequence of outcomes from the stock market. Theorem 16.3.1 ( Asymptotic optimality of the log-optimal portfolio ) Let X 1 , X 2 ,…, X n be a sequence of i.i.d. stock vectors drawn according to F ( x ). Let , where b * is the log-optimal portfolio, and let be the wealth resulting from any other causal portfolio. Then (16.32) Proof: From the Kuhn–Tucker conditions and the log optimality of S * n , we have (16.33) Hence by Markov’s inequality, we have (16.34) Hence, (16.35) Setting t n = n 2 and summing over n , we have (16.36) Then, by the Borel–Cantelli lemma, (16.37) This implies that for almost every sequence from the stock market, there exists an N such that for all . Thus, (16.38) The theorem proves that the log-optimal portfolio will perform as well as or better than any other portfolio to first order in the exponent. 16.4 SIDE INFORMATION AND THE GROWTH RATE We showed in Chapter 6 that side information Y for the horse race X can be used to increase the growth rate by the mutual information I ( X; Y ). We now extend this result to the stock market. Here, I ( X; Y ) is an upper bound on the increase in the growth rate, with equality if X is a horse race. We first consider the decrease in growth rate incurred by believing in the wrong distribution. Theorem 16.4.1 Let X ~ f ( x ). Let b f be a log-optimal portfolio corresponding to f ( x ), and let b g be a log-optimal portfolio corresponding to some other density g ( x ). Then the increase in growth rate Δ W by using b f instead of b g is bounded by (16.39) Proof: We have (16.40) (16.41) (16.42) (16.43) (16.44) (16.45) (16.46) (16.47) where (a) follows from Jensen’s inequality and (b) follows from the Kuhn–Tucker conditions and the fact that b g is log-optimal for g . Theorem 16.4.2 The increase Δ W in growth rate due to side information Y is bounded by (16.48) Proof: Let ( X , Y ) ~ f ( x , y ), where X is the market vector and Y is the related side information. Given side information Y = y , the log-optimal investor uses the conditional log-optimal portfolio for the conditional distribution f ( x | Y = y ). Hence, conditional on Y = y , we have; from Theorem 16.4.1, (16.49) Averaging this over possible values of Y , we have (16.50) (16.51) (16.52) (16.53) Hence, the increase in growth rate is bounded above by the mutual information between the side information Y and the stock market X . 16.5 INVESTMENT IN STATIONARY MARKETS We now extend some of the results of Section 16.4 from i.i.d. markets to time-dependent market processes. Let X 1 , X 2 , … X n ,…, be a vector-valued stochastic process with X i ≥ 0. We consider investment strategies that depend on the past values of the market in a causal fashion (i.e., b i may depend on X 1 , X 2 , … X i −1 ). Let (16.54) Our objective is to maximize E log S n , over all such causal portfolio strategies { b i (·)}. Now (16.55) (16.56) where b * i is the log-optimal portfolio for the conditional distribution of X i given the past values of the stock market; that is, b * i ( x 1 , x 2 ,…, x i −1 ) is the portfolio that achieves the conditional maximum, which is denoted by (16.57) Taking the expectation over the past, we write (16.58) as the conditional optimal growth rate, where the maximum is over all portfolio-valued functions b defined on X 1 ,…, X i −1 . Thus, the highest expected log return is achieved by using the conditional log-optimal portfolio at each stage. Let (16.59) where the maximum is over all causal portfolio strategies. Then since log log , we have the following chain rule for W *: (16.60) This chain rule is formally the same as the chain rule for H . In some ways, W is the dual of H . In particular, conditioning reduces H but increases W . We now define the counterpart of the entropy rate for time-dependent stochastic processes. Definition The growth rate W * ∞ is defined as (16.61) if the limit exists. Theorem 16.5.1 For a stationary market, the growth rate exists and is equal to (16.62) Proof: By stationarity, W *( X n | X 1 , X 2 , X n −1 ) is nondecreasing in n . Hence, it must have a limit, possibly infinity. Since (16.63) it follows by the theorem of the Cesáro mean (Theorem 4.2.3) that the left-hand side has the same limit as the limit of the terms on the right-hand side. Hence, W * ∞ exists and (16.64) We can now extend the asymptotic optimality property to stationary markets. We have the following theorem. Theorem 16.5.2 Consider an arbitrary stochastic process { X i }, X i , conditionally log-optimal portfolios , b * i ( X i −1 ) and wealth S * n . Let S n be the wealth generated by any other causal portfolio strategy b i ( X i −1 ). Then S n /S* n is a positive supermartingale with respect to the sequence of δ-fields generated by the past X 1 , X 2 ,…, X n . Consequently, there exists a random variable V such that (16.65) (16.66) and (16.67) Proof: S n / S* n is a positive supermartingale because (16.68) (16.69) (16.70) by the Kuhn–Tucker condition on the conditionally log-optimal portfolio. Thus, by the martingale convergence theorem, S n / S* n has a limit, call it V , and E V ≤ E ( S 0 / S * 0 ) = 1. Finally, the result for sup( S n / S * n ) follows from Kolmogorov’s inequality for positive martingales. We remark that (16.70) shows how strong the competitive optimality of S* n is. Apparently, the probability is less than 1/10 that S n ( X n ) will ever be 10 times as large as S* n ( X n ). For a stationary ergodic market, we can extend the asymptotic equipartition property to prove the following theorem. Theorem 16.5.3 ( AEP for the stock market ) Let X 1 , X 2 ,…, X n be a stationary ergodic vector-valued stochastic process. Let S* n be the wealth at time n for the conditionally log-optimal strategy, where (16.71) Then (16.72) Proof: The proof involves a generalization of the sandwich argument [20] used to prove the AEP in Section 16.8. The details of the proof (in Algoet and Cover [21]) are omitted. Finally, we consider the example of the horse race once again. The horse race is a special case of the stock market in which there are m stocks corresponding to the m horses in the race. At the end of the race, the value of the stock for horse i is either 0 or o i , the value of the odds for horse i . Thus, X is nonzero only in the component corresponding to the winning horse. In this case, the log-optimal portfolio is proportional betting, known as Kelly gambling (i.e., b* i = p i ), and in the case of uniform fair odds (i.e., o i = m , for all i ), (16.73) When we have a sequence of correlated horse races, the optimal portfolio is conditional proportional betting and the asymptotic growth rate is (16.74) where H ( X ) = lim H ( X 1 , X 2 ,…, X n ) if the limit exists. Then Theorem 16.5.3 asserts that (16.75) in agreement with the results in chapter 6. 16.6 COMPETITIVE OPTIMALITY OF THE LOG-OPTIMAL PORTFOLIO We now ask whether the log-optimal portfolio outperforms alternative portfolios at a given finite time n . As a direct consequence of the Kuhn–Tucker conditions, we have (16.76) and hence by Markov’s inequality, (16.77) This result is similar to the result derived in Chapter 5 for the competitive optimality of Shannon codes. By considering examples, it can be seen that it is not possible to get a better bound on the probability that S n > S* n . Consider a stock market with two stocks and two possible outcomes, (16.78) In this market the log-optimal portfolio invests all the wealth in the first stock. [It is easy to verify that b = (1, 0) satisfies the Kuhn–Tucker conditions.] However, an investor who puts all his wealth in the second stock earns more money with probability 1 − . Hence, it is not true that with high probability the log-optimal investor will do better than any other investor. The problem with trying to prove that the log-optimal investor does best with a probability of at least 1/2 is that there exist examples like the one above, where it is possible to beat the log-optimal investor by a small amount most of the time. We can get around this by allowing each investor an additional fair randomization, which has the effect of reducing the effect of small differences in the wealth. Theorem 16.6.1 ( Competitive optimality ) Let S * be the wealth at the end of one period of investment in a stock market X with the log-optimal portfolio, and let S be the wealth induced by any other portfolio. Let U * be a random variable independent of X uniformly distributed on [0, 2], and let V be any other random variable independent of X and U* with V ≥ 0 and E V = 1. Then (16.79) Remark Here U* and V correspond to initial “fair” randomizations of the initial wealth. This exchange of initial wealth S 0 = 1 for “fair” wealth U* can be achieved in practice by placing a fair bet. The effect of the fair randomization is to randomize small differences, so that only the significant deviations of the ratio S/S * affect the probability of winning. Proof: We have (16.80) (16.81) where is a non-negative-valued random variable with mean (16.82) by the independence of V from X and the Kuhn–Tucker conditions. Let F be the distribution function of W . Then since U* is uniform on [0, 2], (16.83) (16.84) (16.85) (16.86) (16.87) (16.88) using the easily proved fact (by integrating by parts) that (16.89) for a positive random variable W. Hence, we have (16.90) Theorem 16.6.1 provides a short-term justification for the use of the log-optimal portfolio. If the investor’s only objective is to be ahead of his opponent at the end of the day in the stock market, and if fair randomization is allowed, Theorem 16.6.1 says that the investor should exchange his wealth for a uniform [0, 2] wealth and then invest using the log-optimal portfolio. This is the game-theoretic solution to the problem of gambling competitively in the stock market. 16.7 UNIVERSAL PORTFOLIOS The development of the log-optimal portfolio strategy in Section 16.1 relies on the assumption that we know the distribution of the stock vectors and can therefore calculate the optimal portfolio b *. In practice, though, we often do not know the distribution. In this section we describe a causal portfolio that performs well on individual sequences. Thus, we make no statistical assumptions about the market sequence. We assume that the stock market can be represented by a sequence of vectors x 1 , x 2 , … , where x ij is the price relative for stock j on day i and x i is the vector of price relatives for all stocks on day i . We begin with a finite-horizon problem, where we have n vectors x 1 ,…, x n . We later extend the results to the infinite-horizon case. Given this sequence of stock market outcomes, what is the best we can do? A realistic target is the growth achieved by the best constant rebalanced portfolio strategy in hindsight (i.e., the best constant rebalanced portfolio on the known sequence of stock market vectors). Note that constant rebalanced portfolios are optimal against i.i.d. stock market sequences with known distribution, so that this set of portfolios is reasonably natural. Let us assume that we have a number of mutual funds, each of which follows a constant rebalanced portfolio strategy chosen in advance. Our objective is to perform as well as the best of these funds. In this section we show that we can do almost as well as the best constant rebalanced portfolio without advance knowledge of the distribution of the stock market vectors. One approach is to distribute the wealth among a continuum of fund managers, each of which follows a different constantly rebalanced portfolio strategy. Since one of the managers will do exponentially better than the others, the total wealth after n days will be dominated by the largest term. We will show that we can achieve a performance of the best fund manager within a factor of . This is the essence of the argument for the infinite-horizon universal portfolio strategy. A second approach to this problem is as a game against a malicious opponent or nature who is allowed to choose the sequence of stock market vectors. We define a causal (nonanticipating) portfolio strategy i ( x i −1 ,…, x 1 ) that depends only on the past values of the stock market sequence. Then nature, with knowledge of the strategy i ( x i − 1 ), chooses a sequence of vectors x i to make the strategy perform as poorly as possible relative to the best constantly rebalanced portfolio for that stock sequence. Let b * ( x n ) be the best constantly rebalanced portfolio for a stock market sequence x n . Note that b * ( x n ) depends only on the empirical distribution of the sequence, not on the order in which the vectors occur. At the end of n days, a constantly rebalanced portfolio b achieves wealth: (16.91) and the best constant portfolio b * ( x n ) achieves a wealth (16.92) whereas the nonanticipating portfolio i ( x i −1 ) strategy achieves (16.93) Our objective is to find a nonanticipating portfolio strategy that does well in the worst case in terms of the ratio of to S* n . We will find the optimal universal strategy and show that this strategy for each stock sequence achieves wealth that is within a factor of the wealth S* n achieved by the best constantly rebalanced portfolio on that sequence. This strategy depends on n , the horizon of the game. Later we describe some horizon-free results that have the same worst-case asymptotic performance as that of the finite-horizon game. 16.7.1 Finite-Horizon Universal Portfolios We begin by analyzing a stock market of n periods, where n is known in advance, and attempt to find a portfolio strategy that does well against all possible sequences of n stock market vectors. The main result can be stated in the following theorem. Theorem 16.7.1 For a stock market sequence x n = x 1 ,…, x n , x i of length n with m assets, let S * n ( x n ) be the wealth achieved by the optimal constantly rebalanced portfolio on x n , and let be the wealth achieved by any causal portfolio strategy on x n ; then (16.94) where (16.95) Using Stirling’s approximation, we can show that V n , is on the order of , and therefore the growth rate for the universal portfolio on the worst sequence differs from the growth rate of the best constantly rebalanced portfolio on that sequence by at most a polynomial factor. The logarithm of the ratio of growth of wealth of the universal portfolio to the growth of wealth of the best constant portfolio behaves like the redundancy of a universal source code. (See Shtarkov [496], where log V n appears as the minimax individual sequence redundancy in data compression.) We first illustrate the main results by means of an example for n = 1. Consider the case of two stocks and a single day. Let the stock vector for the day be x = ( x 1 , x 2 ). If x 1 > x 2 , the best portfolio is one that puts all its money on stock 1, and if x 2 > x 1 , the best portfolio puts all its money on stock 2. (If x 1 = x 2 , all portfolios are equivalent.) Now assume that we must choose a portfolio in advance and our opponent can choose the stock market sequence after we have chosen our portfolio to make us do as badly as possible relative to the best portfolio. Given our portfolio, the opponent can ensure that we do as badly as possible by making the stock on which we have put more weight equal to 0 and the other stock equal to 1. Our best strategy is therefore to put equal weight on both stocks, and with this, we will achieve a growth factor at least equal to half the growth factor of the best stock, and hence we will achieve at least half the gain of the best constantly rebalanced portfolio. It is not hard to calculate that V n = 2 when n = 1 and m = 2 in equation (16.94) . However, this result seems misleading, since it appears to suggest that for n days, we would use a constant uniform portfolio, putting half our money on each stock every day. If our opponent then chose the stock sequence so that only the first stock was 1 (and the other was 0) every day, this uniform strategy would achieve a wealth of 1/2 n , and we would achieve a wealth only within a factor of 2 n of the best constant portfolio, which puts all the money on the first stock for all time. The result of the theorem shows that we can do significantly better. The main part of the argument is to reduce a sequence of stock vectors to the extreme cases where only one of the stocks is nonzero for each day. If we can ensure that we do well on such sequences, we can guarantee that we do well on any sequence of stock vectors, and achieve the bounds of the theorem. Before we prove the theorem, we need the following lemma. Lemma 16.7.1 For p 1 , p 2 ,…, p m ≥ 0 and q 1 , q 2 ,…, q m ≥ 0, (16.96) Proof: Let I denote the index i that minimizes the right-hand side in (16.96) . Assume that p I > 0 (if p I = 0, the lemma is trivially true). Also, if q I = 0, both sides of (16.96) are infinite (all the other q i ’s must also be zero), and again the inequality holds. Therefore, we can also assume that q I > 0. Then (16.97) because (16.98) for all i . First consider the case when n = 1. The wealth at the end of the first day is (16.99) (16.100) and (16.101) We wish to find . Nature should choose x = e i , where e i is the i th + basis vector with 1 in the component i that minimizes , and the investor should choose to maximize this minimum. This is achieved by choosing . The important point to realize is that (16.102) can also be rewritten in the form of a ratio of terms (16.103) where . Here the m n components of the constantly rebalanced portfolios b are all of the product form . One wishes to find a universal that is uniformly close to the b ’s corresponding to constantly rebalanced portfolios. We can now prove main theorem (Theorem 16.7.1). Proof of Theorem 16.7.1: We will prove the theorem for m = 2. The proof extends in a straightforward fashion to the case m > 2. Denote the stocks by 1 and 2. The key idea is to express the wealth at time n , (16.104) which is a product of sums, into a sum of products. Each term in the sum corresponds to a sequence of stock price relatives for stock 1 or stock 2 times the proportion b i 1 or b i 2 that the strategy places on stock 1 or stock 2 at time i . We can therefore view the wealth S n as a sum over all 2 n possible n -sequences of 1’s and 2’s of the product of the portfolio proportions times the stock price relatives: (16.105) If we let w ( j n ) denote the product , the total fraction of wealth invested in the sequence j n , and let (16.106) be the corresponding return for this sequence, we can write (16.107) Similar expressions apply to both the best constantly rebalanced portfolio and the universal portfolio strategy. Thus, we have (16.108) where is the amount of wealth placed on the sequence j n by the universal nonanticipating strategy, and w * ( j n ) is the amount placed by the best constant rebalanced portfolio strategy. Now applying Lemma 16.7.1, we have (16.109) Thus, the problem of maximizing the performance ratio is reduced to ensuring that the proportion of money bet on a sequence of stocks by the universal portfolio is uniformly close to the proportion bet by b *. As might be obvious by now, this formulation of S n reduces the n -period stock market to a special case of a single-period stock market–there are 2 n stocks, one invests w ( j n ) in stock j n and receives a return x ( j n ) for stock j n , and the total wealth S n is ∑ j n w ( j n ) x ( j n ). We first calculate the weight w *( j n ) associated with the best constant rebalanced portfolio b *. We observe that a constantly rebalanced portfolio b results in (16.110) where k is the number of times 1 appears in the sequence j n . Thus, w ( j n ) depends only on k , the number of 1’s in j n . Fixing attention on j n , we find by differentiating with respect to b that the maximum value (16.111) (16.112) which is achieved by (16.113) Note that ∑ w * ( j n ) reflecting the fact that the amount “bet” on j n is chosen in hindsight, thus relieving the hindsight investor of the responsibility of allocating his investments w * ( j n ) to sum to 1. The causal investor has no such luxury. How can the causal investor choose initial investments ( j n ), ∑ ( j n ) = 1, to protect himself from all possible j n and hindsight-determined w *( j n )? The answer will be to choose ( j n ) proportional to *( j n ). Then the worst-case ratio of ( j n )/ w *( j n ) will be maximized. To proceed, we define V n by (16.114) (16.115) and let (16.116) It is clear that ( j n ) is a legitimate distribution of wealth over the 2 n stock sequences (i.e., ( j n ) ≥ 0 and ∑ j n ( j n ) = 1). Here V n is the normalization factor that makes ( j n ) a probability mass function. Also, from (16.109) and (16.113) , for all sequences x n , (16.117) (16.118) (16.119) where (16.117) follows from (16.109) and (16.119) follows from (16.112) . Consequently, we have (16.120) We have thus demonstrated a portfolio on the 2 n possible sequences of length n that achieves wealth within a factor V n of the wealth S * n ( x n ) achieved by the best constant rebalanced portfolio in hindsight. To complete the proof of the theorem, we show that this is the best possible, that is, that any nonanticipating portfolio b i ( x i −1 ) cannot do better than a factor V n , in the worst case (i.e., for the worst choice of x n ). To prove this, we construct a set of extremal stock market sequences and show that the performance of any nonanticipating portfolio strategy is bounded by V n for at least one of these sequences, proving the worst-case bound. For each j n {1, 2) n , we define the corresponding extremal stock market vector x n ( j n ) as (16.121) Let e 1 = (1, 0) t , e 2 = (0, 1) t be standard basis vectors. Let (16.122) be the set of extremal sequences. There are 2 n such extremal sequences, and for each sequence at each time, there is only one stock that yields a nonzero return. The wealth invested in the other stock is lost. Therefore, the wealth at the end of n periods for extremal sequence x n ( j n ) is the product of the amounts invested in the stocks j 1 , j 2 ,…, j n , [i.e., S n ( x n ( j n )) = i b j i = w ( j n )]. Again, we can view this as an investment on sequences of length n , and given the 0−1 nature of the return, it is easy to see for x n κ that (16.123) For any extremal sequence x n ( j n ) κ , the best constant rebalanced portfolio is (16.124) where n 1 ( j n ) is the number of occurrences of 1 in the sequence j n . The corresponding wealth at the end of n periods is (16.125) from (16.116) and it therefore follows that (16.126) We then have the following inequality for any portfolio sequence , with S n ( x n ) defined as in (16.104) : (16.127) (16.128) (16.129) (16.130) where the inequality follows from the fact that the minimum is less than the average. Thus, (16.131) The strategy described in the theorem puts mass on all sequences of length n and is clearly dependent on n . We can recast the strategy in incremental terms (i.e., in terms of the amount bet on stock 1 and stock 2 at time 1), then, conditional on the outcome at time 1, the amount bet on each of the two stocks at time 2, and so on. Consider the weight i , 1 assigned by the algorithm to stock 1 at time i given the previous sequence of stock vectors x i −1 . We can calculate this by summing over all sequences j n that have a 1 in position i , giving (16.132) where (16.133) is the weight put on all sequences j n that start with j i , and (16.134) is the return on those sequences as defined in (16.106) . Investigation of the asymptotics of V n reveals [401, 496] that (16.135) for m assets. In particular, for m = 2 assets, (16.136) and (16.137) for all n [400]. Consequently, for m = 2 stocks, the causal portfolio strategy i ( x i −1 ) given in (16.132) achieves wealth n ( x n ) such that (16.138) for all market sequences x n . 16.7.2 Horizon-Free Universal Portfolios We describe the horizon-free strategy in terms of a weighting of different portfolio strategies. As described earlier, each constantly rebalanced portfolio b can be viewed as corresponding to a mutual fund that rebalances the m assets according to b . Initially, we distribute the wealth among these funds according to a distribution μ ( b ), where dμ ( b ) is the amount of wealth invested in portfolios in the neighborhood d b of the constantly rebalanced portfolio b . Let (16.139) be the wealth generated by a constant rebalanced portfolio b on the stock sequence x n . Recall that (16.140) is the wealth of the best constant rebalanced portfolio in hindsight. We investigate the causal portfolio defined by (16.141) We note that (16.142) (16.143) Thus, the product telescopes and we see that the wealth n ( x n ) resulting from this portfolio is given by (16.144) (16.145) There is another way to interpret (16.145) . The amount given to portfolio manager b is dμ ( b ), the resulting growth factor for the manager rebalancing to b is S ( b, x n ), and the total wealth of this batch of investments is (16.146) Then i +1 defined in (16.141) , is the performance-weighted total “buy order” of the individual portfolio manager b . So far, we have not specified what distribution μ ( b ) we use to apportion the initial wealth. We now use a distribution μ that puts mass on all possible portfolios, so that we approximate the performance of the best portfolio for the actual distribution of stock price vectors. In the next lemma, we bound n / S * n as a function of the initial wealth distribution μ ( b ). Lemma 16.7.2 Let S * n ( x n ) in 16.140 be the wealth achieved by the best constant rebalanced portfolio and let n ( x n ) in (16.144) be the wealth achieved by the universal mixed portfolio (·), given by (16.147) Then (16.148) Proof: As before, we can write (16.149) where is the amount invested on the sequence j n and is the corresponding return. Similarly, we can write (16.150) (16.151) (16.152) where . Now applying Lemma 16.7.1, we have (16.153) (16.154) (16.155) We now apply this lemma when μ ( b ) is the Dirichlet( ) distribution. Theorem 16.7.2 For the causal universal portfolio i (), i = 1, 2,…, given in (16.141) , with m = 2 stocks and dμ ( b ) the Dirichlet distribution, we have for all n and all stock sequences x n . Proof: As in the discussion preceding (16.112) , we can show that the weight put by the best constant portfolio b * on the sequence j n is (16.156) where k is the number of indices where j i = 1. We can also explicitly calculate the integral in the numerator of (16.148) in Lemma 16.7.2 for the Dirichlet(1/2) density, defined for m variables as (16.157) where Γ ( x ) = ∫ ∞ 0 e − t t x −1 dt denotes the gamma function. For simplicity, we consider the case of two stocks, in which case (16.158) where b is the fraction of wealth invested in stock 1. Now consider any sequence j n {1, 2} n , and consider the amount invested in that sequence, (16.159) where l is the number of indices where j i = 1. Then (16.160) (16.161) (16.162) where B ( λ 1 , λ 2 ) is the beta function, defined as (16.163) (16.164) and (16.165) Note that for any integer n , Γ( n + 1) = n ! and . We can calculate B ( l + , n − l + ) by means of simple recursion using integration by parts. Alternatively, using (16.164) , we obtain (16.166) Combining all the results with Lemma 16.7.2, we have (16.167) (16.168) (16.169) using the results in [135, Theorem 2]. It follows for m = 2 stocks that (16.170) for all n and all market sequences x 1 , x 2 ,…, x n . Thus, good minimax performance for all n costs at most an extra factor over the fixed horizon minimax portfolio. The cost of universality is V n , which is asymptotically negligible in the growth rate in the sense that (16.171) Thus, the universal causal portfolio achieves the same asymptotic growth rate of wealth as the best hindsight portfolio. Let’s now consider how this portfolio algorithm performs on two real stocks. We consider a 14-year period (ending in 2004) and two stocks, Hewlett-Packard and Altria (formerly, Phillip Morris), which are both components of the Dow Jones Index. Over these 14 years, HP went up by a factor of 11.8, while Altria went up by a factor of 11.5. The performance of the different constantly rebalanced portfolios that contain HP and Altria are shown in Figure 16.2 . The best constantly rebalanced portfolio (which can be computed only in hindsight) achieves a growth of a factor of 18.7 using a mixture of about 51% HP and 49% Altria. The universal portfolio strategy described in this section achieves a growth factor of 15.7 without foreknowledge. Figure 16.2. Performance of different constant rebalanced portfolios b for HP and Altria. 16.8 SHANNON–MCMILLAN-BREIMAN THEOREM (GENERAL AEP) The AEP for ergodic processes has come to be known as the Shannon -McMillan -Breiman theorem. In Chapter 3 we proved the AEP for i.i.d. processes. In this section we offer a proof of the theorem for a general ergodic process. We prove the convergence of log p ( X n ) by sandwiching it between two ergodic sequences. In a sense, an ergodic process is the most general dependent process for which the strong law of large numbers holds. For finite alphabet processes, ergodicity is equivalent to the convergence of the k th-order empirical distributions to their marginals for all k . The technical definition requires some ideas from probability theory. To be precise, an ergodic source is defined on a probability space (Ω, , P ), where is a σ -algebra of subsets of Ω and P is a probability measure. A random variable X is defined as a function X ( ω ), ω Ω, on the probability space. We also have a transformation T : Ω → Ω, which plays the role of a time shift. We will say that the transformation is stationary if P ( T A ) = P ( A ) for all A . The transformation is called ergodic if every set A such that T A = A , a.e., satisfies P ( A ) = 0 or 1. If T is stationary and ergodic, we say that the process defined by X n ( Ω ) = X ( T n ω ) is stationary and ergodic. For a stationary ergodic source, Birkhoff’s ergodic theorem states that (16.172) Thus, the law of large numbers holds for ergodic processes. We wish to use the ergodic theorem to conclude that (16.173) But the stochastic sequence is not ergodic. However, the closely related quantities and are ergodic and have expectations easily identified as entropy rates. We plan to sandwich between these two more tractable processes. We define the k th-order entropy H k as (16.174) (16.175) where the last equation follows from stationarity. Recall that the entropy rate is given by (16.176) (16.177) Of course, by stationarity and the fact that conditioning does not increase entropy. It will be crucial that , where (16.178) The proof that H ∞ = H involves exchanging expectation and limit. The main idea in the proof goes back to the idea of (conditional) proportional gambling. A gambler receiving uniform odds with the knowledge of the k past will have a growth rate of wealth log | χ | − H k , while a gambler with a knowledge of the infinite past will have a growth rate of wealth of log | X | − H ∞ . We don’t know the wealth growth rate of a gambler with growing knowledge of the past X n 0 , but it is certainly sandwiched between log | X | − H k and log | X | − H ∞ . But H k H = H ∞ . Thus, the sandwich closes and the growth rate must be log | X | − H . We will prove the theorem based on lemmas that will follow the proof. Theorem 16.8.1 ( AEP: Shannon-McMillan-Breiman Theorem ) If H is the entropy rate of a finite-valued stationary ergodic process { X n }, then (16.179) Proof: We prove this for finite alphabet X ; this proof and the proof for countable alphabets and densities is given in Algoet and Cover [20]. We argue that the sequence of random variables log is asymptotically sandwiched between the upper bound H k and the lower bound H ∞ for all k ≥ 0. The AEP will follow since H k → H ∞ and H ∞ = H . The k th-order Markov approximation to the probability is defined for n ≥ k as (16.180) From Lemma 16.8.3 we have (16.181) which we rewrite, taking the existence of the limit 1/ n log p k ( X n 0 ) into account (Lemma 16.8.1), as (16.182) for k = 1, 2,…, Also, from Lemma 16.8.3, we have (16.183) which we rewrite as (16.184) from the definition of H ∞ in Lemma 16.8.1. Putting together (16.182) and (16.184) , we have (16.185) But by Lemma 16.8.2, H k → H ∞ = H . Consequently, (16.186) We now prove the lemmas that were used in the main proof. The first lemma uses the ergodic theorem. Lemma 16.8.1 ( Markov approximations ) For a stationary ergodic stochastic process { X n }, (16.187) (16.188) Proof: Functions Y n , = of ergodic processes { X i } are ergodic processes. Thus, log and log p ( X n | X n -2 ,…,) and also ergodic processes, and (16.189) (16.190) by the ergodic theorem. Similarly, by the ergodic theorem, (16.191) (16.192) Lemma 16.8.2 ( No gap ) H k H ∞ and H = H ∞ . Proof: We know that for stationary processes, H k H , so it remains to show that H k H ∞ , thus yielding H = H ∞ . Levy’s martingale convergence theorem for conditional probabilities asserts that (16.193) for all x 0 χ . Since X is finite and p log p is bounded and continuous in p for all 0 ≤ p ≤ 1, the bounded convergence theorem allows interchange of expectation and limit, yielding (16.194) (16.195) (16.196) Thus, H k H = H ∞ . Lemma 16.8.3 ( Sandwich ) (16.197) (16.198) Proof: Let A be the support set of . Then (16.199) (16.200) (16.201) (16.202) Similarly, let denote the support set of . Then we have (16.203) (16.204) (16.205) (16.206) By Markov’s inequality and (16.202) , we have (16.207) or (16.208) Letting t = n 2 and noting that , we see by the Borel-Cantelli lemma that the event (16.209) occurs only finitely often with probability 1. Thus, (16.210) Applying the same arguments using Markov’s inequality to (16.206) , we obtain (16.211) proving the lemma. The arguments used in the proof can be extended to prove the AEP for the stock market (Theorem 16.5.3). SUMMARY Growth rate. The growth rate of a stock market portfolio b with respect to a distribution F ( x ) is defined as (16.212) Log-optimal portfolio. The optimal growth rate with respect to a distribution F ( x ) is (16.213) The portfolio b * that achieves the maximum of W ( b , F ) is called the log-optimal portfolio . Concavity. W ( b , F ) is concave in b and linear in F . W * ( F ) is convex in F . Optimality conditions . The Portfolio b * is log-optimal if and only if (16.214) Expected ratio optimality. If , then (16.215) Growth rate (AEP) (16.216) Asymptotic optimality (16.217) Wrong information. Believing g when f is true loses (16.218) Side information Y (16.219) Chain rule (16.220) (16.221) Growth rate for a stationary market. (16.222) (16.223) Competitive optimality of log-optimal portfolios. (16.224) Universal portfolio. (16.225) where (16.226) For m = 2, (16.227) The causal universal portfolio (16.228) achieves (16.229) for all n and all x n . AEP. If { X i } is stationary ergodic, then (16.230) PROBLEMS 16.1 Growth rate. Let where a > 1. This vector X represents a stock market vector of cash vs. a hot stock. Let and be the growth rate. (a) Find the log optimal portfolio b *. (b) Find the growth rate W *. (c) Find the asymptotic behavior of for all b . 16.2 Side information. Suppose, in Problem 16.1, that Let the portfolio b depend on Y . Find the new growth rate W ** and verify that Δ W = W ** − W * satisfies 16.3 Stock dominance. Consider a stock market vector Suppose that X 1 = 2 with probability 1. Thus an investment in the first stock is doubled at the end of the day. (a) Find necessary and sufficient conditions on the distribution of stock X 2 such that the log-optimal portfolio b * invests all the wealth in stock X 2 [i.e., b * = (0, 1)]. (b) Argue for any distribution on X 2 that the growth rate satisfies W * ≥ 1. 16.4 Including experts and mutual funds. Let X ~ F ( x ), x R m + , be the vector of price relatives for a stock market. Suppose that an “expert” suggests a portfolio b . This would result in a wealth factor b t X . We add this to the stock alternatives to form = ( X 1 , X 2 ,…, X m b t X ). Show that the new growth rate, (16.231) is equal to the old growth rate, (16.232) 16.5 Growth rate for symmetric distribution. Consider a stock vector X ~ F ( x ), X R m , X ≥ 0, where the component stocks are exchangeable. Thus, F ( x 1 , x 2 ,…, x m ) = F ( x σ (1) , x σ (2) ,…, x σ ( m ) ) for all permutations σ . (a) Find the portfolio b * optimizing the growth rate and establish its optimality. Now assume that X has been normalized so that , and F is symmetric as before. (b) Again assuming X to be normalized, show that all symmetric distributions F have the same growth rate against b *. (c) Find this growth rate. 16.6 Convexity. We are interested in the set of stock market densities that yield the same optimal porfolio. Let P b 0 be the set of all probability densities on R m + for which b 0 is optimal. Thus, is maximized by b = b 0 }. Show that P b 0 is a convex set. It may be helpful to use Theorem 16.2.2. 16.7 Short selling. Let Let B = {( b 1 , b 2 ) : b 1 b 2 = 1}. Thus, this set of portfolios B does not include the constraint b i ≥ 0. (This allows short selling.) (a) Find the log optimal portfolio b *( p ). (b) Relate the growth rate W *( p ) to the entropy rate H ( p ). 16.8 Normalizing x. Suppose that we define the log-optimal portfolio b * to be the portfolio maximizing the relative growth rate The virtue of the normalization , which can be viewed as the wealth associated with a uniform portfolio, is that the relative growth rate is finite even when the growth rate ∫ ln b t xdF ( x ) is not. This matters, for example, if X has a St. Petersburg-like distribution. Thus, the log-optimal portfolio b * is defined for all distributions F , even those with infinite growth rates W *( F ). (a) Show that if b maximizes ∫ ln( b t x ) d F ( x ), it also maximizes , where u = (1/ m , 1/ m ,…, 1/ m ). (b) Find the log optimal portfolio b * for where k = 1, 2, …. (c) Find E X and W *. (d) Argue that b * is competitively better than any portfolio b in the sense that Pr{ b t X > c b *t X } ≤ . 16.9 Universal portfolio. We examine the first n = 2 steps of the implementation of the universal portfolio in (16.7.2) for μ ( b ) uniform for m = 2 stocks. Let the stock vectors for days 1 and 2 be x 1 = (1, ), and x 2 = (1, 2). Let b = ( b , 1 − b ) denote a portfolio. (a) Graph S 2 ( b ) = , 0 ≤ b ≤ 1. (b) Calculate S * 2 = max b S 2 ( b ). (c) Argue that log S 2 ( b ) is concave in b. (d) Calculate the (universal) wealth 2 = ∫ 1 0 S 2 ( b ) d b. (e) Calculate the universal portfolio at times n = 1 and n = 2: (f) Which of S 2 ( b ), are unchanged if we permute the order of appearance of the stock vector outcomes [i.e., if the sequence is now (1, 2), (1, )]? 16.10 Growth optimal. Let X 1 , X 2 ≥ 0, be price relatives of two independent stocks. Suppose that E X 1 > E X 2 . Do you always want some of X 1 in a growth rate optimal portfolio S ( b ) = bX 1 + X 2 ? Prove or provide a counterexample. 16.11 Cost of universality. In the discussion of finite-horizon universal portfolios, it was shown that the loss factor due to universality is (16.233) Evaluate V n for n = 1, 2, 3. 16.12 Convex families. This problem generalizes Theorem 16.2.2. We say that S is a convex family of random variables if implies that λ S 1 + (1 − λ) . Let S be a closed convex family of random variables. Show that there is a random variable S * such that (16.234) for all if and only if (16.235) for all . HISTORICAL NOTES There is an extensive literature on the mean–variance approach to investment in the stock market. A good introduction is the book by Sharpe [491]. Log-optimal portfolios were introduced by Kelly [308] and Latané [346], and generalized by Breiman [75]. The bound on the increase in the growth rate in terms of the mutual information is due to Barron and Cover [31]. See Samuelson [453, 454] for a criticism of log-optimal investment. The proof of the competitive optimality of the log-optimal portfolio is due to Bell and Cover [39, 40]. Breiman [75] investigated asymptotic optimality for random market processes. The AEP was introduced by Shannon. The AEP for the stock market and the asymptotic optimality of log-optimal investment are given in Algoet and Cover [21]. The relatively simple sandwich proof for the AEP is due to Algoet and Cover [20]. The AEP for real-valued ergodic processes was proved in full generality by Barron [34] and Orey [402]. The universal portfolio was defined in Cover [110] and the proof of universality was given in Cover [110] and more exactly in Cover and Ordentlich [135]. The fixed-horizon exact calculation of the cost of universality V n is given in Ordentlich and Cover [401]. The quantity V n also appears in data compression in the work of Shtarkov [496].

Chapter 17: Inequalities in Information Theory CHAPTER 17 INEQUALITIES IN INFORMATION THEORY This chapter summarizes and reorganizes the inequalities found throughout this book. A number of new inequalities on the entropy rates of subsets and the relationship of entropy and L p norms are also developed. The intimate relationship between Fisher information and entropy is explored, culminating in a common proof of the entropy power inequality and the Brunn–Minkowski inequality. We also explore the parallels between the inequalities in information theory and inequalities in other branches of mathematics, such as matrix theory and probability theory. 17.1 BASIC INEQUALITIES OF INFORMATION THEORY Many of the basic inequalities of information theory follow directly from convexity. Definition A function f is said to be convex if (17.1) for all 0 ≤ λ ≤ 1 and all x 1 and x 2 . Theorem 17.1.1 ( Theorem 2.6.2: Jensen’s inequality ) If f is convex, then (17.2) Lemma 17.1.1 The function log x is concave and x log x is convex, for 0 < x < ∞. Theorem 17.1.2 ( Theorem 2.7.1: Log sum inequality ) For positive numbers a 1 , a 2 ,…, a n and b 1 , b 2 ,…, b n , (17.3) with equality iff = constant. We recall the following properties of entropy from Section 2.1. Definition The entropy H ( X ) of a discrete random variable X is defined by (17.4) Theorem 17.1.3 ( Lemma 2.1.1, Theorem 2.6.4: Entropy bound ) (17.5) Theorem 17.1.4 ( Theorem 2.6.5: Conditioning reduces entropy ) For any two random variables X and Y , (17.6) with equality if X and Y are independent. Theorem 17.1.5 ( Theorem 2.5.1 with Theorem 2.6.6: Chain rule) (17.7) with equality if X 1 , X 2 ,…, X n are independent. Theorem 17.1.6 ( Theorem 2.7.3 ) H ( p ) is a concave function of p. We now state some properties of relative entropy and mutual information (Section 2.3). Definition The relative entropy or Kullback–Leibler distance between two probability mass functions p ( x ) and q ( x ) is defined by (17.8) Definition The mutual information between two random variables X and Y is defined by (17.9) The following basic information inequality can be used to prove many of the other inequalities in this chapter. Theorem 17.1.7 ( Theorem 2.6.3: Information inequality ) For any two probability mass functions p and q , (17.10) with equality iff p ( x ) = q ( x ) for all x χ. Corollary For any two random variables X and Y , (17.11) with equality iff p ( x, y ) = p ( x ) p ( y ) (i.e., X and Y are independent). Theorem 17.1.8 ( Theorem 2.7.2: Convexity of relative entropy ) D ( p || q ) is convex in the pair ( p, q ). Theorem 17.1.9 ( Theorem 2.4.1 ) (17.12) (17.13) (17.14) (17.15) Theorem 17.1.10 ( Section 4.4 ) For a Markov chain: 1. Relative entropy D ( μ n || μ’ n ) decreases with time . 2. Relative entropy D ( μ n || μ ) between a distribution and the stationary distribution decreases with time. 3. Entropy H ( X n ) increases if the stationary distribution is uniform. 4. The conditional entropy H ( X n | X 1 ) increases with time for a stationary Markov chain. Theorem 17.1.11 Let X 1 , X 2 ,…, X n be i.i.d. ~ p ( x ). Let n be the empirical probability mass function of X 1 , X 2 ,…, X n . Then (17.16) 17.2 DIFFERENTIAL ENTROPY We now review some of the basic properties of differential entropy (Section 8.1). Definition The differential entropy h ( X 1 , X 2 ,…, X n ), sometimes written h ( f ), is defined by (17.17) The differential entropy for many common densities is given in Table 17.1 . TABLE 17.1. Differential Entropies a Definition The relative entropy between probability densities f and g is (17.18) The properties of the continuous version of relative entropy are identical to the discrete version. Differential entropy, on the other hand, has some properties that differ from those of discrete entropy. For example, differential entropy may be negative. We now restate some of the theorems that continue to hold for differential entropy. Theorem 17.2.1 ( Theorem 8.6.1: Conditioning reduces entropy ) h ( X | Y ) ≤ h ( X ), with equality iff X and Y are independent. Theorem 17.2.2 ( Theorem 8.6.2: Chain rule ) (17.19) with equality iff X 1 , X 2 ,…, X n are independent. Lemma 17.2.1 If X and Y are independent, then h ( X + Y ) ≥ h ( X ). Proof: h ( X + Y ) ≥ h ( X + Y | Y ) = h ( X | Y ) = h ( X ). Theorem 17.2.3 ( Theorem 8.6.5 ) Let the random vector X R n have zero mean and covariance K = E XX t (i.e., K ij = EX i X j , 1 ≤, i, j ≤ n) . Then (17.20) with equality iff X ~ N (0, K ). 17.3 BOUNDS ON ENTROPY AND RELATIVE ENTROPY In this section we revisit some of the bounds on the entropy function. The most useful is Fano’s inequality, which is used to bound away from zero the probability of error of the best decoder for a communication channel at rates above capacity. Theorem 17.3.1 ( Theorem 2.10.1: Fano’s inequality ) Given two random variables X and Y, let = g ( Y ) be any estimator of X given Y and let P e = Pr( X ≠ ) be the probability of error. Then (17.21) Consequently, if H ( X | Y ) > 0, then P e > 0. A similar result is given in the following lemma. Lemma 17.3.1 ( Lemma 2.10.1 ) If X and X’ are i.i.d. with entropy H ( X ) (17.22) with equality if and only if X has a uniform distribution. The continuous analog of Fano’s inequality bounds the mean-squared error of an estimator. Theorem 17.3.2 ( Theorem 8.6.6 ) Let X be a random variable with differential entropy h ( X ). Let be an estimate of X, and let E ( X − ) 2 be the expected prediction error. Then (17.23) Given side information Y and estimator ( Y ), (17.24) Theorem 17.3.3 (L 1 bound on entropy) Let p and q be two probability mass functions on X such that (17.25) Then (17.26) Proof: Consider the function f ( t ) = − t log t shown in Figure 17.1 . It can be verified by differentiation that the function f (·) is concave. Also, f (0) = f (1) = 0. Hence the function is positive between 0 and 1. Consider the chord of the function from t to t + v (where v ≤ 1/2). The maximum absolute slope of the chord is at either end (when t = 0 or 1 − v ). Hence for 0 ≤ t ≤ 1 − v , we have Figure 17.1. Function f ( t ) = − t ln t . (17.27) Let r ( x ) = | p ( x ) − q ( x )|. Then (17.28) (17.29) (17.30) (17.31) (17.32) (17.33) where (17.30) follows from (17.27) . Finally, relative entropy is stronger than the 1 norm in the following sense: Lemma 17.3.2 ( Lemma 11.6.1 ) (17.34) The relative entropy between two probability mass functions P ( x ) and Q ( x ) is zero when P = Q. Around this point, the relative entropy has a quadratic behavior, and the first term in the Taylor series expansion of the relative entropy D ( P || Q ) around the point P = Q is the chi-squared distance between the distributions P and Q. Let (17.35) Lemma 17.3.3 For P near Q , (17.36) Proof: See Problem 11.2. 17.4 INEQUALITIES FOR TYPES The method of types is a powerful tool for proving results in large deviation theory and error exponents. We repeat the basic theorems. Theorem 17.4.1 ( Theorem 11.1.1 ) The number of types with denominator n is bounded by (17.37) Theorem 17.4.2 ( Theorem 11.1.2 ) If X 1 , X 2 ,…, X n are drawn i.i.d. according to Q ( x ), the probability of x n depends only on its type and is given by (17.38) Theorem 17.4.3 ( Theorem 11.1.3: Size of a type class T ( P )) For any type P n , (17.39) Theorem 17.4.4 ( Theorem 11.1.4 ) For any P P n and any distribution Q, the probability of the type class T ( P ) under Q n is 2 −nD(P||Q) to first order in the exponent. More precisely , (17.40) 17.5 COMBINATORIAL BOUNDS ON ENTROPY We give tight bounds on the size of when k is not 0 or n using the result of Wozencraft and Reiffen [568]: Lemma 17.5.1 For 0 < p < 1, q = 1 − p, such that np is an integer , (17.41) Proof: We begin with a strong form of Stirling’s approximation [208], which states that (17.42) Applying this to find an upper bound, we obtain (17.43) (17.44) (17.45) since , hence proving the upper bound. The lower bound is obtained similarly. Using Stirling’s formula, we obtain (17.46) (17.47) (17.48) If np ≥ 1, and nq ≥ 3, then (17.49) and the lower bound follows directly from substituting this into the equation. The exceptions to this condition are the cases where np = 1, nq = 1 or 2, and np = 2, nq = 2 (the case when np ≥ 3, nq = 1 or 2 can be handled by flipping the roles of p and q ). In each of these cases Thus, even in these special cases, the bound is valid, and hence the lower bound is valid for all p ≠ 0, 1. Note that the lower bound blows up when p = 0 or p = 1, and is therefore not valid. 17.6 ENTROPY RATES OF SUBSETS We now generalize the chain rule for differential entropy. The chain rule provides a bound on the entropy rate of a collection of random variables in terms of the entropy of each random variable: (17.50) We extend this to show that the entropy per element of a subset of a set of random variables decreases as the size of the subset increases. This is not true for each subset but is true on the average over subsets, as expressed in Theorem 17.6.1. Definition Let ( X 1 , X 2 ,…, X n ) have a density, and for every S ⊆ {1, 2,…, n }, denote by X ( S ) the subset {X i : i S ). Let (17.51) Here is the average entropy in bits per symbol of a randomly drawn k -element subset of { X 1 , X 2 ,…, X n }. The following theorem by Han [270] says that the average entropy decreases monotonically in the size of the subset. Theorem 17.6.1 (17.52) Proof: We first prove the last inequality, . We write Adding these n inequalities and using the chain rule, we obtain (17.53) or (17.54) which is the desired result . We now prove that for all k ≤ n by first conditioning on a k -element subset, and then taking a uniform choice over its ( k − 1)-element subsets. For each k -element subset, , and hence the inequality remains true after taking the expectation over all k -element subsets chosen uniformly from the n elements. Theorem 17.6.2 Let r > 0, and define (17.55) Then (17.56) Proof: Starting from (17.54) , we multiply both sides by r , exponentiate, and then apply the arithmetic mean geometric mean inequality, to obtain (17.57) (17.58) which is equivalent to . Now we use the same arguments as in Theorem 17.6.1, taking an average over all subsets to prove the result that for all . Definition The average conditional entropy rate per element for all subsets of size k is the average of the above quantities for k -element subsets of {1, 2,…, n }: (17.59) Here g k ( S ) is the entropy per element of the set S conditional on the elements of the set S c . When the size of the set S increases, one can expect a greater dependence among the elements of the set S , which explains Theorem 17.6.1. In the case of the conditional entropy per element, as k increases, the size, of the conditioning set S c decreases and the entropy of the set S increases. The increase in entropy per element due to the decrease in conditioning dominates the decrease due to additional dependence among the elements, as can be seen from the following theorem due to Han [270]. Note that the conditional entropy ordering in the following theorem is the reverse of the unconditional entropy ordering in Theorem 17.6.1. Theorem 17.6.3 (17.60) Proof: The proof proceeds on lines very similar to the proof of the theorem for the unconditional entropy per element for a random subset. We first prove that and then use this to prove the rest of the inequalities. By the chain rule, the entropy of a collection of random variables is less than the sum of the entropies: (17.61) Subtracting both sides of this inequality from nh ( X 1 , X 2 ,…, X n ), we have (17.62) (17.63) Dividing this by n ( n − 1), we obtain (17.64) which is equivalent to . We now prove that for all k ≤ n by first conditioning on a k -element subset and then taking a uniform choice over its ( k − 1)-element subsets. For each k -element subset, , and hence the inequality remains true after taking the expectation over all k -element subsets chosen uniformly from the n elements. Theorem 17.6.4 Let (17.65) Then (17.66) Proof: The theorem follows from the identity I ( X ( S ); X ( S c )) = h ( X ( S )) − h ( X ( S )| X ( S c )) and Theorems 17.6.1 and 17.6.3. 17.7 ENTROPY AND FISHER INFORMATION The differential entropy of a random variable is a measure of its descriptive complexity. The Fisher information is a measure of the minimum error in estimating a parameter of a distribution. In this section we derive a relationship between these two fundamental quantities and use this to derive the entropy power inequality. Let X be any random variable with density f ( x ). We introduce a location parameter θ and write the density in a parametric form as f ( x − θ ). The Fisher information (Section 11.10) with respect to θ is given by (17.67) In this case, differentiation with respect to x is equivalent to differentiation with respect to θ So we can write the Fisher information as (17.68) which we can rewrite as (17.69) We will call this the Fisher information of the distribution of X. Notice that like entropy, it is a function of the density. The importance of Fisher information is illustrated in the following theorem. Theorem 17.7.1 (Theorem 11.10.1: Cramér–Rao inequality) The mean-squared error of any unbiased estimator T ( X ) of the parameter θ is lower bounded by the reciprocal of the Fisher information: (17.70) We now prove a fundamental relationship between the differential entropy and the Fisher information: Theorem 17.7.2 ( de Bruijn’s identity: entropy and Fisher information ) Let X be any random-variable with a finite variance with a density f ( x ). Let Z be an independent normally distributed random variable with zero mean and unit variance. Then (17.71) where h e is the differential entropy to base e. In particular, if the limit exists as t → 0, (17.72) Proof: Let Y t = X + . Then the density of Y t is (17.73) Then (17.74) (17.75) We also calculate (17.76) (17.77) and (17.78) (17.79) Thus, (17.80) We will use this relationship to calculate the derivative of the entropy of Y t , where the entropy is given by (17.81) Differentiating, we obtain (17.82) (17.83) The first term is zero since f g t ( y ) dy = 1. The second term can be integrated by parts to obtain (17.84) The second term in (17.84) is J ( Y t ). So the proof will be complete if we show that the first term in (17.84) is zero. We can rewrite the first term as (17.85) The square of the first factor integrates to the Fisher information and hence must be bounded as y → ±∞. The second factor goes to zero since x ln x → 0 as x → 0 and g t ( y ) → 0 as y → ±∞. Hence, the first term in (17.84) goes to 0 at both limits and the theorem is proved. In the proof, we have exchanged integration and differentiation in (17.74) , (17.76) , (17.78) , and (17.82) . Strict justification of these exchanges requires the application of the bounded convergence and mean value theorems; the details may be found in Barron [30]. This theorem can be used to prove the entropy power inequality, which gives a lower bound on the entropy of a sum of independent random variables. Theorem 17.7.3 (Entropy power inequality) If X and Y are independent random n-vectors with densities, then (17.86) We outline the basic steps in the proof due to Stam [505] and Blachman [61]. A different proof is given in Section 17.8. Stam’s proof of the entropy power inequality is based on a perturbation argument. Let n = 1. Let X t = X + , Y t = Y + , where Z 1 and Z 2 are independent N (0, 1) random variables. Then the entropy power inequality for n = 1 reduces to showing that s (0) ≤ 1, where we define (17.87) If f ( t ) → ∞ and g ( t ) → ∞, as t → ∞, it is easy to show that s (∞) = 1. If, in addition, s ’( t ) ≥ 0 for t ≥ 0, this implies that s (0) ≤ 1. The proof of the fact that s ’( t ) ≥ 0 involves a clever choice of the functions f ( t ) and g ( t ), an application of Theorem 17.7.2 and the use of a convolution inequality for Fisher information, (17.88) The entropy power inequality can be extended to the vector case by induction. The details may be found in the papers by Stam [505] and Blachman [61]. 17.8 ENTROPY POWER INEQUALITY AND BRUNN-MINKOWSKI INEQUALITY The entropy power inequality provides a lower bound on the differential entropy of a sum of two independent random vectors in terms of their individual differential entropies. In this section we restate and outline an alternative proof of the entropy power inequality. We also show how the entropy power inequality and the Brunn–Minkowski inequality are related by means of a common proof. We can rewrite the entropy power inequality for dimension n = 1 in a form that emphasizes its relationship to the normal distribution. Let X and Y be two independent random variables with densities, and let X ′ and Y ′ be independent normals with the same entropy as X and Y , respectively. Then 2 2h( X ) = 2 2h( X ′) = (2 πe ) σ 2 X ′ , and similarly, 2 2 h ( Y ) = (2 πe ) σ 2 Y ′ . Hence the entropy power inequality can be rewritten as (17.89) since X ′ and Y ′ are independent. Thus, we have a new statement of the entropy power inequality. Theorem 17.8.1 ( Restatement of the entropy power inequality ) For two independent random variables X and Y , (17.90) where X′ and Y′ are independent normal random variables with h ( X ′) = h ( X ) and h ( Y ′) = h ( Y ). This form of the entropy power inequality bears a striking resemblance to the Brunn–Minkowski inequality, which bounds the volume of set sums. Definition The set sum A + B of two sets A, B ⊂ R n is defined as the set { x + y : x A, y B }. Example 17.8.1 The set sum of two spheres of radius 1 is a sphere of radius 2. Theorem 17.8.2 (Brunn–Minkowski inequality) The volume of the set sum of two sets A and B is greater than the volume of the set sum of two spheres A′ and B′ with the same volume as A and B, respectively: (17.91) where A′ and B′ are spheres with V ( A ′) = V ( A ) and V ( B ′) = V ( B ). The similarity between the two theorems was pointed out in [104]. A common proof was found by Dembo [162] and Lieb, starting from a strengthened version of Young’s inequality. The same proof can be used to prove a range of inequalities which includes the entropy power inequality and the Brunn–Minkowski inequality as special cases. We begin with a few definitions. Definition Let f and g be two densities over R n and let f * g denote the convolution of the two densities. Let the r norm of the density be defined by (17.92) Lemma 17.8.1 ( Strengthened Young’s inequality ) For any two densities f and g over R n , (17.93) where (17.94) and (17.95) Proof: The proof of this inequality may be found in [38] and [73]. We define a generalization of the entropy. Definition The Renyi entropy h r ( X ) of order r is defined as (17.96) for 0 < r < ∞, r ≠ 1. If we take the limit as r → 1, we obtain the Shannon entropy function, (17.97) If we take the limit as r → 0, we obtain the logarithm of the volume of the support set, (17.98) Thus, the zeroth-order Renyi entropy gives the logarithm of the measure of the support set of the density f , and the Shannon entropy h 1 gives the logarithm of the size of the “effective” support set (Theorem 8.2.2). We now define the equivalent of the entropy power for Renyi entropies. Definition The Renyi entropy power V r ( X ) of order r is defined as (17.99) Theorem 17.8.3 For two independent random variables X and Y and any 0 ≤ r < ∞ and any 0 &≤ λ ≤ 1, we have (17.100) where and H ( λ ) = − λ log λ − (1 − λ ) log(1 − λ ). Proof: If we take the logarithm of Young’s inequality (17.93) , we obtain (17.101) Setting λ = r ’/ p ′ and using (17.94) , we have 1 − λ = r ′ / q ′, p = ans . Thus, (17.101) becomes (17.102) (17.103) (17.104) (17.105) where the details of the algebra for the last step are omitted. The Brunn–Minkowski inequality and the entropy power inequality can then be obtained as special cases of this theorem. The entropy power inequality . Taking the limit of (17.100) as r → 1 and setting (17.106) we obtain (17.107) which is the entropy power inequality. The Brunn–Minkowski inequality . Similarly, letting r → 0 and choosing (17.108) we obtain (17.109) Now let A be the support set of X and B be the support set of Y . Then A + B is the support set of X + Y , and (17.109) reduces to (17.110) which is the Brunn–Minkowski inequality. The general theorem unifies the entropy power inequality and the Brunn–Minkowski inequality and introduces a continuum of new inequalities that lie between the entropy power inequality and the Brunn–Minkowski inequality. This further strengthens the analogy between entropy power and volume. 17.9 INEQUALITIES FOR DETERMINANTS Throughout the remainder of this chapter, we assume that K is a nonnegative definite symmetric n × n matrix. Let | K | denote the determinant of K . We first give an information-theoretic proof of a result due to Ky Fan [199]. Theorem 17.9.1 log | K | is concave . Proof: Let X 1 and X 2 be normally distributed n -vectors, X i ~ N (0, K i ), i = 1, 2. Let the random variable θ have the distribution (17.111) (17.112) for some 0 ≤ λ ≤ 1. Let θ , X 1 , and X 2 be independent, and let Z = X θ . Then Z has covariance K Z = λK 1 + (1 − λ ) K 2 . However, Z will not be multivariate normal. By first using Theorem 17.2.3, followed by Theorem 17.2.1, we have (17.113) (17.114) Thus, (17.115) as desired. We now give Hadamard’s inequality using an information-theoretic proof [128]. Theorem 17.9.2 ( Hadamard ) | K | ≤ Π K ii , with equality iff K ij = 0, i ≠ j . Proof: Let X ~ N (O, K ). Then (17.116) with equality iff X 1 , X 2 , … X n are independent (i.e., K ij = 0, i ≠ j ). We now prove a generalization of Hadamard’s inequality due to Szasz [391]. Let K ( i 1 , i 2 ,…, i k ) be the k × k principal submatrix of K formed by the rows and columns with indices i 1 , i 2 ,…, i k . Theorem 17.9.3 ( Szasz ) If K is a positive definite n × n matrix and P k denotes the product of the determinants of all the principal k-rowed minors of K, that is , (17.117) then (17.118) Proof: Let X ~ N (O, K ). Then the theorem follows directly from Theorem 17.6.1, with the identification . We can also prove a related theorem. Theorem 17.9.4 Let K be a positive definite n × n matrix and let (17.119) Then (17.120) Proof: This follows directly from the corollary to Theorem 17.6.1, with the identification and r = 2. Theorem 17.9.5 Let (17.121) Then (17.122) Proof: The theorem follows immediately from Theorem 17.6.3 and the identification (17.123) The outermost inequality, Q 1 ≤ Q n , can be rewritten as (17.124) where (17.125) is the minimum mean-squared error in the linear prediction of X i from the remaining X ’s. Thus, σ 2 i is the conditional variance of X i given the remaining X j ’s if X 1 , X 2 ,…, X n are jointly normal. Combining this with Hadamard’s inequality gives upper and lower bounds on the determinant of a positive definite matrix. Corollary (17.126) Hence, the determinant of a covariance matrix lies between the product of the unconditional variances K ii of the random variables X i and the product of the conditional variances σ 2 i . We now prove a property of Toeplitz matrices, which are important as the covariance matrices of stationary random processes. A Toeplitz matrix K is characterized by the property that K ij = K rs , if | i − j | = | r − s |. Let K k denote the principal minor K (1, 2,…, k ). For such a matrix, the following property can be proved easily from the properties of the entropy function. Theorem 17.9.6 If the positive definite n × n matrix K is Toeplitz, then (17.127) and | K k |/| K k −1 | is decreasing in k, and (17.128) Proof: Let ( X 1 , X 2 ,…, X n ) ~ N (0, K n ). We observe that (17.129) (17.130) Thus, the monotonicity of | K k |/| K k −1 | follows from the monotonocity of h ( X k | X k −1 ,…, X 1 ), which follows from (17.131) (17.132) where the equality follows from the Toeplitz assumption and the inequality from the fact that conditioning reduces entropy. Since h ( X k | X k −1 ,…, X 1 ) is decreasing, it follows that the running averages (17.133) are decreasing in k . Then (17.127) follows from h ( X 1 , X 2 ,…, X k ) = log(2 πe ) k | K k |. Finally, since h ( X n | X n −1 ,…, X 1 ) is a decreasing sequence, it has a limit. Hence by the theorem of the Cesáro mean, (17.134) Translating this to determinants, one obtains (17.135) Theorem 17.9.7 ( Minkowski inequality [390] ) (17.136) Proof: Let X 1 , X 2 be independent with X i ~ N (0, K i ). Noting that X 1 + X 2 ~ N (0, K 1 + K 2 ) and using the entropy power inequality (Theorem 17.7.3) yields (17.137) (17.138) (17.139) 17.10 INEQUALITIES FOR RATIOS OF DETERMINANTS We now prove similar inequalities for ratios of determinants. Before developing the next theorem, we make an observation about minimum mean-squared-error linear prediction. If ( X 1 , X 2 ,…, X n ) ~ N (0, K n ), we know that the conditional density of X n , given ( X 1 , X 2 ,…, X n −1 ) is univariate normal with mean linear in X 1 , X 2 ,…, X n −1 and conditional variance σ 2 n . Here σ 2 n is the minimum mean squared error E ( X n − n ) 2 over all linear estimators n based on X 1 , X 2 ,…, X n −1 . Lemma 17.10.1 σ 2 n = | K n |/| K n −1 . Proof: Using the conditional normality of X n , we have (17.140) (17.141) (17.142) (17.143) Minimization of σ 2 n over a set of allowed covariance matrices { K n } is aided by the following theorem. Such problems arise in maximum entropy spectral density estimation. Theorem 17.10.1 ( Bergstrϕm [42] ) log(| K n |/| K n−p |) is concave in K n . Proof: We remark that Theorem 17.9.1 cannot be used because log(| K n |/| K n−p |) is the difference of two concave functions. Let Z = X θ , where X 1 ~ N (0, S n ), X 2 ~ N (0, T n ), Pr{ θ = 1} = λ = 1 − Pr{ θ = 2}, and let X 1 , X 2 , θ be independent. The covariance matrix K n of Z is given by (17.144) The following chain of inequalities proves the theorem: (17.145) (17.146) (17.147) (17.148) where (a) follows from h ( X n , X n −1 ,…, X n - p +1 | X 1 ,…, X n - p ) = h ( X 1 ,…, X n ) − h ( X 1 ,…, X n - p ), (b) follows from the conditioning lemma, and (c) follows from a conditional version of Theorem 17.2.3. Theorem 17.10.2 ( Bergstrϕm [42] ) | K n |/| K n −1 | is concave in K n . Proof: Again we use the properties of Gaussian random variables. Let us assume that we have two independent Gaussian random n -vectors, X ~ N (0, A n ) and Y ~ N (0, B n ). Let Z = X Y. Then (17.149) (17.150) (17.151) (17.152) (17.153) (17.154) (17.155) where (a) follows from Lemma 17.10.1 (b) follows from the fact that the conditioning decreases entropy (c) follows from the fact that Z is a function of X and Y (d) follows since X n + Y n is Gaussian conditioned on X 1 , X 2 ,…, X n −1 , Y 1 , Y 2 ,…, Y n −1 , and hence we can express its entropy in terms of its variance (e) follows from the independence of X n and Y n conditioned on the past X 1 , X 2 ,…, X n −1 , Y 1 , Y 2 ,…, Y n −1 (f) follows from the fact that for a set of jointly Gaussian random variables, the conditional variance is constant, independent of the conditioning variables (Lemma 17.10.1) Setting A = λS and B = T , we obtain (17.156) (i.e., | K n |/| K n −1 | is concave). Simple examples show that | K n |/| K n − p | is not necessarily concave for p ≥ 2. A number of other determinant inequalities can be proved by these techniques. A few of them are given as problems. OVERALL SUMMARY Entropy. H ( X ) = − ∑ p ( x ) log p ( x ). Relative entropy. D ( p || g ) = ∑ p ( x ) log . Mutual information. I ( X ; Y ) = ∑ p ( x, y ) log . Information inequality. D ( p || q ) ≥ 0. Asymptotic equipartition property. − log p ( X 1 , X 2 ,…, X n ) → H ( χ ). Data compression. H ( X ) ≤ L * < H ( X ) + 1. Kolmogorov complexity. K ( x ) = min u ( p )= x l ( p ). Universal probability. log ≈ K ( x ). Channel capacity. C = max p ( x ) I ( X ; Y ). Data transmission R < C : Asymptotically error-free communication possible R > C : Asymptotically error-free communication not possible Gaussian channel capacity. . Rate distortion. R ( D ) = min I ( X ; ) over all p ( | x ) such that E p ( x ) p ( | x ) d ( X , ) ≤ D . Growth rate for investment. W * = max b* E log b t X . PROBLEMS 17.1 Sum of positive definite matrices . For any two positive definite matrices, K 1 and K 2 , show that | K 1 + K 2 | ≥ | K 1 |. 17.2 Fan’s inequality [200] for ratios of determinants . For all 1 ≤ p ≤ n , for a positive definite K = K (1, 2,…, n ), show that (17.157) 17.3 Convexity of determinant ratios . For positive definite matrices K , K 0 , show that in(| K + K 0 | K |) is convex in K. 17.4 Data-processing inequality. Let random variable X 1 , X 2 , X 3 , and X 4 form a Markov chain X 1 → X 2 → X 3 → X 4 . Show that (17.158) 17.5 Markov chains. Let random variables X, Y, Z , and W form a Markov chain so that X → Y → ( Z, W ) [i.e., p ( x, y, z, w ) = p ( x ) p ( Y | x ) p ( z, w | y )]. Show that (17.159) HISTORICAL NOTES The entropy power inequality was stated by Shannon [472]; the first formal proofs are due to Stam [505] and Blachman [61]. The unified proof of the entropy power and Brunn–Minkowski inequalities is in Dembo et al.[164]. Most of the matrix inequalities in this chapter were derived using information-theoretic methods by Cover and Thomas [118]. Some of the subset inequalities for entropy rates may be found in Han [270].

Bibliography BIBLIOGRAPHY [1] J. Abrahams. Code and parse trees for lossless source encoding. Proc. Compression and Complexity of Sequences 1997 , pages 145–171, 1998. [2] N. Abramson. The ALOHA system—another alternative for computer communications. AFIPS Conf. Proc. , pages 281–285, 1970. [3] N. M. Abramson. Information Theory and Coding . McGraw-Hill, New York, 1963. [4] Y. S. Abu-Mostafa. Information theory. Complexity , pages 25–28, Nov. 1989. [5] R. L. Adler, D. Coppersmith, and M. Hassner. Algorithms for sliding block codes: an application of symbolic dynamics to information theory. IEEE Trans. Inf. Theory , IT-29(1):5–22, 1983. [6] R. Ahlswede. The capacity of a channel with arbitrary varying Gaussian channel probability functions. Trans. 6th Prague Conf. Inf. Theory , pages 13–21, Sept. 1971. [7] R. Ahlswede. Multi-way communication channels. In Proc. 2nd Int. Symp. Inf. Theory ( Tsahkadsor, Armenian S.S.R. ), pages 23–52. Hungarian Academy of Sciences, Budapest, 1971. [8] R. Ahlswede. The capacity region of a channel with two senders and two receivers. Ann. Prob. , 2:805–814, 1974. [9] R. Ahlswede. Elimination of correlation in random codes for arbitrarily varying channels. Z. Wahrscheinlichkeitstheorie und verwandte Gebiete , 33:159–175, 1978. [10] R. Ahlswede. Coloring hypergraphs: A new approach to multiuser source coding. J. Comb. Inf. Syst. Sci. , pages 220–268, 1979. [11] R. Ahlswede. A method of coding and an application to arbitrarily varying channels. J. Comb. Inf. Syst. Sci. , pages 10–35, 1980. [12] R. Ahlswede and T. S. Han. On source coding with side information via a multiple access channel and related problems in multi-user information theory. IEEE Trans. Inf. Theory , IT-29:396–412, 1983. [13] R. Ahlswede and J. Körner. Source coding with side information and a converse for the degraded broadcast channel. IEEE Trans. Inf. Theory , IT-21:629–637, 1975. [14] R. F. Ahlswede. Arbitrarily varying channels with states sequence known to the sender. IEEE Trans. Inf. Theory , pages 621–629, Sept. 1986. [15] R. F. Ahlswede. The maximal error capacity of arbitrarily varying channels for constant list sizes (corresp.). IEEE Trans. Inf. Theory , pages 1416–1417, July 1993. [16] R. F. Ahlswede and G. Dueck. Identification in the presence of feedback: a discovery of new capacity formulas. IEEE Trans. Inf. Theory , pages 30–36, Jan. 1989. [17] R. F. Ahlswede and G. Dueck. Identification via channels. IEEE Trans. Inf. Theory , pages 15–29, Jan. 1989. [18] R. F. Ahlswede, E. H. Yang, and Z. Zhang. Identification via compressed data. IEEE Trans. Inf. Theory , pages 48–70, Jan. 1997. [19] H. Akaike. Information theory and an extension of the maximum likelihood principle. Proc. 2nd Int. Symp. Inf. Theory , pages 267–281, 1973. [20] P. Algoet and T. M. Cover. A sandwich proof of the Shannon–McMillan–Breiman theorem. Ann. Prob. , 16(2):899–909, 1988. [21] P. Algoet and T. M. Cover. Asymptotic optimality and asymptotic equipartition property of log-optimal investment. Ann. Prob. , 16(2):876–898, 1988. [22] S. Amari. Differential-Geometrical Methods in Statistics . Springer-Verlag, New York, 1985. [23] S. I. Amari and H. Nagaoka. Methods of Information Geometry . Oxford University Press, Oxford, 1999. [24] V. Anantharam and S. Verdu. Bits through queues. IEEE Trans. Inf. Theory , pages 4–18, Jan. 1996. [25] S. Arimoto. An algorithm for calculating the capacity of an arbitrary discrete memoryless channel. IEEE Trans. Inf. Theory , IT-18:14–20, 1972. [26] S. Arimoto. On the converse to the coding theorem for discrete memoryless channels. IEEE Trans. Inf. Theory , IT-19:357–359, 1973. [27] R. B. Ash. Information Theory . Interscience, New York, 1965. [28] J. Aczél and Z. Daróczy. On Measures of Information and Their Characterization . Academic Press, New York, 1975. [29] L. R. Bahl, J. Cocke, F. Jelinek, and J. Raviv. Optimal decoding of linear codes for minimizing symbol error rate (corresp.). IEEE Trans. Inf. Theory , pages 284–287, March 1974. [30] A. Barron. Entropy and the central limit theorem. Ann. Prob. , 14(1):336–342, 1986. [31] A. Barron and T. M. Cover. A bound on the financial value of information. IEEE Trans. Inf. Theory , IT-34:1097–1100, 1988. [32] A. Barron and T. M. Cover. Minimum complexity density estimation. IEEE Trans. Inf. Theory , 37(4):1034–1054, July 1991. [33] A. R. Barron. Logically smooth density estimation . Ph.D. thesis, Department of Electrical Engineering, Stanford University, Stanford, CA, 1985. [34] A. R. Barron. The strong ergodic theorem for densities: generalized Shannon–McMillan–Breiman theorem. Ann. Prob. , 13:1292–1303, 1985. [35] A. R. Barron. Are Bayes’ rules consistent in information? Prob. Commun. Computation , pages 85–91, 1987. [36] A. R. Barron, J. Rissanen, and Bin Yu. The minimum description length principle in coding and modeling. IEEE Trans. Inf. Theory , pages 2743–2760, Oct. 1998. [37] E. B. Baum. Neural net algorithms that learn in polynomial time from examples and queries. IEEE Trans. Neural Networks , pages 5–19, 1991. [38] W. Beckner. Inequalities in Fourier analysis. Ann. Math. , 102:159–182, 1975. [39] R. Bell and T. M. Cover. Competitive optimality of logarithmic investment. Math. Oper. Res. , 5(2):161–166, May 1980. [40] R. Bell and T. M. Cover. Game-theoretic optimal portfolios. Manage. Sci. , 34(6):724–733, 1988. [41] T. C. Bell, J. G. Cleary, and I. H. Witten. Text Compression . Prentice-Hall, Englewood Cliffs, NJ, 1990. [42] R. Bellman. Notes on matrix theory. IV: An inequality due to Bergstrøm. Am. Math. Monthly , 62:172–173, 1955. [43] C. H. Bennett and G. Brassard. Quantum cryptography: public key distribution and coin tossing. Proc. IEEE Int. Conf. Comput. , pages 175–179, 1984. [44] C. H. Bennett, D. P. DiVincenzo, J. Smolin, and W. K. Wootters. Mixed state entanglement and quantum error correction. Phys. Rev. A , pages 3824–3851, 1996. [45] C. H. Bennett, D. P. DiVincenzo, and J. A. Smolin. Capacities of quantum erasure channels. Phys. Rev. Lett. , pages 3217–3220, 1997. [46] C. H. Bennett and S. J. Wiesner. Communication via one- and two-particle operators on Einstein–podolsky–Rosen states. Phys. Rev. Lett. , pages 2881–2884, 1992. [47] C. H. Bennett. Demons, engines and the second law. Sci. Am. , 259(5):108–116, Nov. 1987. [48] C. H. Bennett and R. Landauer. The fundamental physical limits of computation. Sci. Am. , 255(1):48–56, July 1985. [49] C. H. Bennett and P. W. Shor. Quantum information theory. IEEE Trans. Inf. Theory , IT-44:2724–2742, Oct. 1998. [50] J. Bentley, D. Sleator, R. Tarjan, and V. Wei. Locally adaptive data compression scheme. Commun. ACM , pages 320–330, 1986. [51] R. Benzel. The capacity region of a class of discrete additive degraded interference channels. IEEE Trans. Inf. Theory , IT-25:228–231, 1979. [52] T. Berger. Rate Distortion Theory: A Mathematical Basis for Data Compression . Prentice-Hall, Englewood Cliffs, NJ, 1971. [53] T. Berger. Multiterminal source coding. In G. Longo (Ed.), The Information Theory Approach to Communications . Springer-Verlag, New York, 1977. [54] T. Berger and R. W. Yeung. Multiterminal source encoding with one distortion criterion. IEEE Trans. Inf. Theory , IT-35:228–236, 1989. [55] P. Bergmans. Random coding theorem for broadcast channels with degraded components. IEEE Trans. Inf. Theory , IT-19:197–207, 1973. [56] E. R. Berlekamp. Block Coding with Noiseless Feedback . Ph.D. thesis, MIT, Cambridge, MA, 1964. [57] C. Berrou, A. Glavieux, and P. Thitimajshima. Near Shannon limit error-correcting coding and decoding: Turbo codes. Proc. 1993 Int. Conf. Commun. , pages 1064–1070, May 1993. [58] D. Bertsekas and R. Gallager. Data Networks, 2nd ed. . Prentice-Hall, Englewood Cliffs, NJ, 1992. [59] M. Bierbaum and H. M. Wallmeier. A note on the capacity region of the multiple access channel. IEEE Trans. Inf. Theory , IT-25:484, 1979. [60] E. Biglieri, J. Proakis, and S. Shamai. Fading channels: information-theoretic and communications aspects. IEEE Trans. Inf. Theory , pages 2619–2692, October 1998. [61] N. Blachman. The convolution inequality for entropy powers. IEEE Trans. Inf. Theory , IT-11:267–271, Apr. 1965. [62] D. Blackwell, L. Breiman, and A. J. Thomasian. Proof of Shannon’s transmission theorem for finite-state indecomposable channels. Ann. Math. Stat. , pages 1209–1220, 1958. [63] D. Blackwell, L. Breiman, and A. J. Thomasian. The capacity of a class of channels. Ann. Math. Stat. , 30:1229–1241, 1959. [64] D. Blackwell, L. Breiman, and A. J. Thomasian. The capacities of certain channel classes under random coding. Ann. Math. Stat. , 31:558–567, 1960. [65] R. Blahut. Computation of channel capacity and rate distortion functions. IEEE Trans. Inf. Theory , IT-18:460–473, 1972. [66] R. E. Blahut. Information bounds of the Fano–Kullback type. IEEE Trans. Inf. Theory , IT-22:410–421, 1976. [67] R. E. Blahut. Principles and Practice of Information Theory . Addison-Wesley, Reading, MA, 1987. [68] R. E. Blahut. Hypothesis testing and information theory. IEEE Trans. Inf. Theory , IT-20:405–417, 1974. [69] R. E. Blahut. Theory and Practice of Error Control Codes . Addison-Wesley, Reading, MA, 1983. [70] B. M. Hochwald, G. Caire, B. Hassibi, and T. L. Marzetta (Eds.). IEEE Trans. Inf. Theory , Special Issue on Space-Time Transmission, Reception, Coding and Signal-Processing, Vol. 49, Oct. 2003. [71] L. Boltzmann. Beziehung Zwischen dem zweiten Hauptsatze der mechanischen Wärmertheorie und der Wahrscheilichkeitsrechnung respektive den Saetzen uber das Wärmegleichgwicht. Wien. Ber. , pages 373–435, 1877. [72] R. C. Bose and D. K. Ray-Chaudhuri. On a class of error correcting binary group codes. Inf. Control , 3:68–79, Mar. 1960. [73] H. J. Brascamp and E. J. Lieb. Best constants in Young’s inequality, its converse and its generalization to more than three functions. Adv. Math. , 20:151–173, 1976. [74] L. Breiman. The individual ergodic theorems of information theory. Ann. Math. Stat. , 28:809–811, 1957. With correction made in 31:809–810. [75] L. Breiman. Optimal gambling systems for favourable games. In Fourth Berkeley Symposium on Mathematical Statistics and Probability , Vol. 1, pages 65–78. University of California Press, Berkeley, CA, 1961. [76] L. Breiman, J. H. Friedman, R. A. Olshen, and C. J. Stone. Classification and Regression Trees . Wadsworth & Brooks, Pacific Grove, CA, 1984. [77] L. Brillouin. Science and Information Theory . Academic Press, New York, 1962. [78] J. A. Bucklew. The source coding theorem via Sanov’s theorem. IEEE Trans. Inf. Theory , pages 907–909, Nov. 1987. [79] J. A. Bucklew. Large Deviation Techniques in Decision, Simulation, and Estimation . Wiley, New York, 1990. [80] J. P. Burg. Maximum entropy spectral analysis . Ph.D. thesis, Department of Geophysics, Stanford University, Stanford, CA, 1975. [81] M. Burrows and D. J. Wheeler. A Block-Sorting Lossless Data Compression Algorithm (Tech. Rept. 124). Digital Systems Research Center, Palo Alto, CA, May 1994. [82] A. R. Calderbank. The art of signaling: fifty years of coding theory. IEEE Trans. Inf. Theory , pages 2561–2595, Oct. 1998. [83] A. R. Calderbank and P. W. Shor. Good quantum error-correcting codes exist. Phys. Rev. A , pages 1098–1106, 1995. [84] A. Carleial. Outer bounds on the capacity of the interference channel. IEEE Trans. Inf. Theory , IT-29:602–606, 1983. [85] A. B. Carleial. A case where interference does not reduce capacity. IEEE Trans. Inf. Theory , IT-21:569–570, 1975. [86] G. Chaitin. Information-Theoretic Incompleteness . World Scientific, Singapore, 1992. [87] G. J. Chaitin. On the length of programs for computing binary sequences. J. ACM , pages 547–569, 1966. [88] G. J. Chaitin. The limits of mathematics. J. Universal Comput. Sci. , 2(5):270–305, 1996. [89] G. J. Chaitin. On the length of programs for computing binary sequences. J. ACM , 13:547–569, 1966. [90] G. J. Chaitin. Information theoretical limitations of formal systems. J. ACM , 21:403–424, 1974. [91] G. J. Chaitin. Randomness and mathematical proof. Sci. Am. , 232(5):47–52, May 1975. [92] G. J. Chaitin. Algorithmic information theory. IBM J. Res. Dev. , 21:350–359, 1977. [93] G. J. Chaitin. Algorithmic Information Theory . Cambridge University Press, Cambridge, 1987. [94] C. S. Chang and J. A. Thomas. Huffman algebras for independent random variables. Discrete Event Dynam. Syst. , 4:23–40, 1994. [95] C. S. Chang and J. A. Thomas. Effective bandwidth in high speed digital networks. IEEE J. Select. Areas Commun. , 13:1091–1114, Aug. 1995. [96] R. Chellappa. Markov Random Fields: Theory and Applications . Academic Press, San Diego, CA, 1993. [97] H. Chernoff. A measure of the asymptotic efficiency of tests of a hypothesis based on a sum of observations. Ann. Math. Stat. , 23:493–507, 1952. [98] B. S. Choi and T. M. Cover. An information-theoretic proof of Burg’s maximum entropy spectrum. Proc. IEEE , 72:1094–1095, 1984. [99] N. Chomsky. Three models for the description of language. IEEE Trans. Inf. Theory , pages 113–124, Sept. 1956. [100] P. A. Chou, M. Effros, and R. M. Gray. A vector quantization approach to universal noiseless coding and quantization. IEEE Trans. Inf. Theory , pages 1109–1138, July 1996. [101] K. L. Chung. A note on the ergodic theorem of information theory. Ann. Math. Stat. , 32:612–614, 1961. [102] B. S. Clarke and A. R. Barron. Information-theoretic asymptotics of Bayes’ methods. IEEE Trans. Inf. Theory , pages 453–471, May 1990. [103] B. S. Clarke and A. R. Barron. Jeffreys’ prior is asymptotically least favorable under entropy risk. J. Stat. Planning Inf. , pages 37–60, Aug. 1994. [104] M. Costa and T. M. Cover. On the similarity of the entropy power inequality and the Brunn–Minkowski inequality. IEEE Trans. Inf. Theory , IT-30:837–839, 1984. [105] M. H. M. Costa. On the Gaussian interference channel. IEEE Trans. Inf. Theory , pages 607–615, Sept. 1985. [106] M. H. M. Costa and A. A. El Gamal. The capacity region of the discrete memoryless interference channel with strong interference. IEEE Trans. Inf. Theory , pages 710–711, Sept. 1987. [107] T. M. Cover. Geometrical and statistical properties of systems of linear inequalities with applications to pattern recognition. IEEE Trans. Electron. Computation , pages 326–334, 1965. [108] T. M. Cover. Universal Gambling Schemes and the Complexity Measures of Kolmogorov and Chaitin (Tech. Rept. 12). Department of Statistics, Stanford University, Stanford, CA, Oct. 1974. [109] T. M. Cover. Open problems in information theory. Proc. Moscow Inf. Theory Workshop , pages 35–36, 1975. [110] T. M. Cover. Universal portfolios. Math. Finance , pages 1–29, Jan. 1991. [111] T. M. Cover. Comments on broadcast channels. IEEE Trans. Inf. Theory , pages 2524–2530, Oct. 1998. [112] T. M. Cover. Shannon and investment. IEEE Inf. Theory Newslett (Special Golden Jubilee Issue), pp. 10–11, June 1998. [113] T. M. Cover and M. S. Chiang. Duality between channel capacity and rate distortion with two-sided state information. IEEE Trans. Inf. Theory , IT-48(6):1629–1638, June 2002. [114] T. M. Cover, P. Gács, and R. M. Gray. Kolmogorov’s contributions to information theory and algorithmic complexity. Ann. Prob. , pages 840–865, July 1989. [115] T. M. Cover, A. A. El Gamal, and M. Salehi. Multiple access channels with arbitrarily correlated sources. IEEE Trans. Inf. Theory , pages 648–657, Nov. 1980. [116] T. M. Cover and P. E. Hart. Nearest neighbor pattern classification. IEEE Trans. Inf. Theory , pages 21–27, Jan. 1967. [117] T. M. Cover and S. Pombra. Gaussian feedback capacity. IEEE Trans. Inf. Theory , pages 37–43, January 1989. [118] T. M. Cover and J. A. Thomas. Determinant inequalities via information theory. SIAM J. Matrix Anal. and Its Applications , 9(3):384–392, July 1988. [119] T. M. Cover. Broadcast channels. IEEE Trans. Inf. Theory , IT-18:2–14, 1972. [120] T. M. Cover. Enumerative source encoding. IEEE Trans. Inf. Theory , IT-19(1):73–77, Jan. 1973. [121] T. M. Cover. An achievable rate region for the broadcast channel. IEEE Trans. Inf. Theory , IT-21:399–404, 1975. [122] T. M. Cover. A proof of the data compression theorem of Slepian and Wolf for ergodic sources. IEEE Trans. Inf. Theory , IT-22:226–228, 1975. [123] T. M. Cover. An algorithm for maximizing expected log investment return. IEEE Trans. Inf. Theory , IT-30(2):369–373, 1984. [124] T. M. Cover. Kolmogorov complexity, data compression and inference. In J. Skwirzynski (Ed.), The Impact of Processing Techniques on Communications , Vol. 91 of Applied Sciences . Martinus-Nijhoff, Dordrecht, The Netherlands, 1985. [125] T. M. Cover. On the competitive optimality of Huffman codes. IEEE Trans. Inf. Theory , 37(1):172–174, Jan. 1991. [126] T. M. Cover. Universal portfolios. Math. Finance , pages 1–29, Jan. 1991. [127] T. M. Cover and A El Gamal. Capacity theorems for the relay channel. IEEE Trans. Inf. Theory , IT-25:572–584, 1979. [128] T. M. Cover and A. El Gamal. An information theoretic proof of Hadamard’s inequality. IEEE Trans. Inf. Theory , IT-29(6):930–931, Nov. 1983. [129] T. M. Cover, A. El Gamal, and M. Salehi. Multiple access channels with arbitrarily correlated sources. IEEE Trans. Inf. Theory , IT-26:648–657, 1980. [130] T. M. Cover. Pick the largest number, Open Problems in Communication and Computation . Ed. by T. M. Cover and B. Gopinath, page 152, New York, 1987. [131] T. M. Cover and R. King. A convergent gambling estimate of the entropy of English. IEEE Trans. Inf. Theory , IT-24:413–421, 1978. [132] T. M. Cover and C. S. K. Leung. Some equivalences between Shannon entropy and Kolmogorov complexity. IEEE Trans. Inf. Theory , IT-24:331–338, 1978. [133] T. M. Cover and C. S. K. Leung. An achievable rate region for the multiple access channel with feedback. IEEE Trans. Inf. Theory , IT-27:292–298, 1981. [134] T. M. Cover, R. J. McEliece, and E. Posner. Asynchronous multiple access channel capacity. IEEE Trans. Inf. Theory , IT-27:409–413, 1981. [135] T. M. Cover and E. Ordentlich. Universal portfolios with side information. IEEE Trans. Inf. Theory , IT-42:348–363, Mar. 1996. [136] T. M. Cover and S. Pombra. Gaussian feedback capacity. IEEE Trans. Inf. Theory , IT-35:37–43, 1989. [137] H. Cramer. Mathematical Methods of Statistics . Princeton University Press, Princeton, NJ, 1946. [138] I. Csiszár. Information type measures of difference of probability distributions and indirect observations. Stud. Sci. Math. Hung. , 2:299–318, 1967. [139] I Csiszár. On the computation of rate distortion functions. IEEE Trans. Inf. Theory , IT-20:122–124, 1974. [140] I. Csiszár. I-divergence geometry of probability distributions and minimization problems. Ann. Prob. , pages 146–158, Feb. 1975. [141] I Csiszár. Sanov property, generalized I-projection and a conditional limit theorem. Ann. Prob. , 12:768–793, 1984. [142] I. Csiszár. Information theory and ergodic theory. Probl. Contr. Inf. Theory , pages 3–27, 1987. [143] I. Csiszár. A geometric interpretation of Darroch and Ratcliff’s generalized iterative scaling. Ann. Stat. , pages 1409–1413, 1989. [144] I. Csiszár. Why least squares and maximum entropy? An axiomatic approach to inference for linear inverse problems. Ann. Stat. , pages 2032–2066, Dec. 1991. [145] I. Csiszár. Arbitrarily varying channels with general alphabets and states. IEEE Trans. Inf. Theory , pages 1725–1742, Nov. 1992. [146] I. Csiszár. The method of types. IEEE Trans. Inf. Theory , pages 2505–2523, October 1998. [147] I. Csiszár, T. M. Cover, and B. S. Choi. Conditional limit theorems under Markov conditioning. IEEE Trans. Inf. Theory , IT-33:788–801, 1987. [148] I. Csiszár and J. Körner. Towards a general theory of source networks. IEEE Trans. Inf. Theory , IT-26:155–165, 1980. [149] I. Csiszár and J. Körner. Information Theory: Coding Theorems for Discrete Memoryless Systems . Academic Press, New York, 1981. [150] I. Csiszár and J. Körner. Feedback does not affect the reliability function of a DMC at rates above capacity (corresp.). IEEE Trans. Inf. Theory , pages 92–93, Jan. 1982. [151] I. Csiszár and J. Körner. Broadcast channels with confidential messages. IEEE Trans. Inf. Theory , pages 339–348, May 1978. [152] I. Csiszár and J. Körner. Graph decomposition: a new key to coding theorems. IEEE Trans. Inf. Theory , pages 5–12, Jan. 1981. [153] I. Csiszár and G. Longo. On the Error Exponent for Source Coding and for Testing Simple Statistical Hypotheses . Hungarian Academy of Sciences, Budapest, 1971. [154] I. Csiszár and P. Narayan. Capacity of the Gaussian arbitrarily varying channel. IEEE Trans. Inf. Theory , pages 18–26, Jan. 1991. [155] I. Csiszár and G. Tusnády. Information geometry and alternating minimization procedures. Statistics and Decisions , Supplement Issue 1:205–237, 1984. [156] G. B. Dantzig and D. R. Fulkerson. On the max-flow min-cut theorem of networks. In H. W. Kuhn and A. W. Tucker (Eds.), Linear Inequalities and Related Systems (Vol. 38 of Annals of Mathematics Study ), pages 215–221. Princeton University Press, Princeton, NJ, 1956. [157] J. N. Darroch and D. Ratcliff. Generalized iterative scaling for log-linear models. Ann. Math. Stat. , pages 1470–1480, 1972. [158] I. Daubechies. Ten Lectures on Wavelets . SIAM, Philadelphia, 1992. [159] L. D. Davisson. Universal noiseless coding. IEEE Trans. Inf. Theory , IT-19:783–795, 1973. [160] L. D. Davisson. Minimax noiseless universal coding for Markov sources. IEEE Trans. Inf. Theory , pages 211–215, Mar. 1983. [161] L. D. Davisson, R. J. McEliece, M. B. Pursley, and M. S. Wallace. Efficient universal noiseless source codes. IEEE Trans. Inf. Theory , pages 269–279, May 1981. [162] A. Dembo. Information Inequalities and Uncertainty Principles (Technical Report), Department of Statistics, Stanford University, Stanford, CA, 1990. [163] A. Dembo. Information inequalities and concentration of measure. Ann. Prob. , pages 927–939, 1997. [164] A. Dembo, T. M. Cover, and J. A. Thomas. Information theoretic inequalities. IEEE Trans. Inf. Theory , 37(6):1501–1518, Nov. 1991. [165] A. Dembo and O. Zeitouni. Large Deviations Techniques and Applications . Jones & Bartlett, Boston, 1993. [166] A. P. Dempster, N. M. Laird, and D. B. Rubin. Maximum likelihood from incomplete data via the EM algorithm. J. Roy. Stat. Soc. B , 39(1):1–38, 1977. [167] L. Devroye and L. Gyorfi. Nonparametric Density Estimation: The L 1 View . Wiley, New York, 1985. [168] L. Devroye, L. Gyorfi, and G. Lugosi. A Probabilistic Theory of Pattern Recognition . Springer-Verlag, New York, 1996. [169] D. P. DiVincenzo, P. W. Shor, and J. A. Smolin. Quantum-channel capacity of very noisy channels. Phys. Rev. A , pages 830–839, 1998. [170] R.L. Dobrushin. General formulation of Shannon’s main theorem of information theory. Usp. Math. Nauk , 14:3–104, 1959. Translated in Am. Math. Soc. Trans. , 33:323–438. [171] R. L. Dobrushin. Survey of Soviet research in information theory. IEEE Trans. Inf. Theory , pages 703–724, Nov. 1972. [172] D. L. Donoho. De-noising by soft-thresholding. IEEE Trans. Inf. Theory , pages 613–627, May 1995. [173] R. O. Duda and P. E. Hart. Pattern Classification and Scene Analysis . Wiley, New York, 1973. [174] G. Dueck. Maximal error capacity regions are smaller than average error capacity regions for multi-user channels. Probl. Contr. Inf. Theory , pages 11–19, 1978. [175] G. Dueck. The capacity region of the two-way channel can exceed the inner bound. Inf. Control , 40:258–266, 1979. [176] G. Dueck. Partial feedback for two-way and broadcast channels. Inf. Control , 46:1–15, 1980. [177] G. Dueck and J. Körner. Reliability function of a discrete memoryless channel at rates above capacity. IEEE Trans. Inf. Theory , IT-25:82–85, 1979. [178] P. M. Ebert. The capacity of the Gaussian channel with feedback. Bell Syst. Tech. J. , 49:1705–1712, Oct. 1970. [179] P. M. Ebert. The capacity of the Gaussian channel with feedback. Bell Syst. Tech. J. , pages 1705–1712, Oct. 1970. [180] K. Eckschlager. Information Theory in Analytical Chemistry . Wiley, New York, 1994. [181] M. Effros, K. Visweswariah, S. R. Kulkarni, and S. Verdu. Universal lossless source coding with the Burrows–Wheeler transform. IEEE Trans. Inf. Theory , IT-48:1061–1081, May 2002. [182] B. Efron and R. Tibshirani. An Introduction to the Bootstrap . Chapman & Hall, London, 1993. [183] H. G. Eggleston. Convexity (Cambridge Tracts in Mathematics and Mathematical Physics, No. 47). Cambridge University Press, Cambridge, 1969. [184] A. El Gamal. The feedback capacity of degraded broadcast channels. IEEE Trans. Inf. Theory , IT-24:379–381, 1978. [185] A. El Gamal. The capacity region of a class of broadcast channels. IEEE Trans. Inf. Theory , IT-25:166–169, 1979. [186] A. El Gamal and T. M. Cover. Multiple user information theory. Proc. IEEE , 68:1466–1483, 1980. [187] A. El Gamal and T. M. Cover. Achievable rates for multiple descriptions. IEEE Trans. Inf. Theory , IT-28:851–857, 1982. [188] A. El Gamal and E. C. Van der Meulen. A proof of Marton’s coding theorem for the discrete memoryless broadcast channel. IEEE Trans. Inf. Theory , IT-27:120–122, 1981. [189] P. Elias. Error-free coding. IRE Trans. Inf. Theory , IT-4:29–37, 1954. [190] P. Elias. Coding for noisy channels. IRE Conv. Rec., Pt. 4 , pages 37–46, 1955. [191] P. Elias. Networks of Gaussian channels with applications to feedback systems. IEEE Trans. Inf. Theory , pages 493–501, July 1967. [192] P. Elias. The efficient construction of an unbiased random sequence. Ann. Math. Stat. , pages 865–870, 1972. [193] P. Elias. Universal codeword sets and representations of the integers. IEEE Trans. Inf. Theory , pages 194–203, Mar. 1975. [194] P. Elias. Interval and recency rank source coding: two on-line adaptive variable-length schemes. IEEE Trans. Inf. Theory , pages 3–10, Jan. 1987. [195] P. Elias, A. Feinstein, and C. E. Shannon. A note on the maximum flow through a network. IEEE Trans. Inf. Theory , pages 117–119, December 1956. [196] R. S. Ellis. Entropy, Large Deviations, and Statistical Mechanics . Springer-Verlag, New York, 1985. [197] A. Ephremides and B. Hajek. Information theory and communication networks: an unconsummated union. IEEE Trans. Inf. Theory , pages 2416–2434, Oct. 1998. [198] W. H. R. Equitz and T. M. Cover. Successive refinement of information. IEEE Trans. Inf. Theory , pages 269–275, Mar. 1991. [199] Ky Fan. On a theorem of Weyl concerning the eigenvalues of linear transformations II. Proc. Nat. Acad. Sci. USA , 36:31–35, 1950. [200] Ky Fan. Some inequalities concerning positive-definite matrices. Proc. Cambridge Philos. Soc. , 51:414–421, 1955. [201] R. M. Fano. Class notes for Transmission of Information, course 6.574 (Technical Report). MIT, Cambridge, MA, 1952. [202] R. M. Fano. Transmission of Information: A Statistical Theory of Communication . Wiley, New York, 1961. [203] M. Feder. A note on the competetive optimality of Huffman codes. IEEE Trans. Inf. Theory , 38(2):436–439, Mar. 1992. [204] M. Feder, N. Merhav, and M. Gutman. Universal prediction of individual sequences. IEEE Trans. Inf. Theory , pages 1258–1270, July 1992. [205] A. Feinstein. A new basic theorem of information theory. IRE Trans. Inf. Theory , IT-4:2–22, 1954. [206] A. Feinstein. Foundations of Information Theory . McGraw-Hill, New York, 1958. [207] A. Feinstein. On the coding theorem and its converse for finite-memory channels. Inf. Control , 2:25–44, 1959. [208] W. Feller. An Introduction to Probability Theory and Its Applications , 2nd ed., Vol. 1. Wiley, New York, 1957. [209] R. A. Fisher. On the mathematical foundations of theoretical statistics. Philos. Trans. Roy. Soc., London A , 222:309–368, 1922. [210] R. A. Fisher. Theory of statistical estimation. Proc. Cambridge Philos. Soc. , 22:700–725, 1925. [211] B. M. Fitingof. Optimal encoding with unknown and variable message statistics. Probl. Inf. Transm. ( USSR ), pages 3–11, 1966. [212] B. M. Fitingof. The compression of discrete information. Probl. Inf. Transm. ( USSR ), pages 28–36, 1967. [213] L. R. Ford and D. R. Fulkerson. Maximal flow through a network. Can. J. Math. , pages 399–404, 1956. [214] L. R. Ford and D. R. Fulkerson. Flows in Networks . Princeton University Press, Princeton, NJ, 1962. [215] G. D. Forney. Exponential error bounds for erasure, list and decision feedback schemes. IEEE Trans. Inf. Theory , IT-14:549–557, 1968. [216] G. D. Forney. Information Theory: unpublished course notes. Stanford University, Stanford, CA, 1972. [217] G. J. Foschini. Layered space-time architecture for wireless communication in a fading environment when using multi-element antennas. Bell Syst. Tech. J. , 1(2):41–59, 1996. [218] P. Franaszek, P. Tsoucas, and J. Thomas. Context allocation for multiple dictionary data compression. In Proc. IEEE Int. Symp. Inf. Theory , Trondheim, Norway, page 12, 1994. [219] P. A. Franaszek. On synchronous variable length coding for discrete noiseless channels. Inf. Control , 15:155–164, 1969. [220] T. Gaarder and J. K. Wolf. The capacity region of a multiple-access discrete memoryless channel can increase with feedback. IEEE Trans. Inf. Theory , IT-21:100–102, 1975. [221] D. Gabor. Theory of communication. J. Inst. Elec. Engg. , pages 429–457, Sept. 1946. [222] P. Gacs and J. Körner. Common information is much less than mutual information. Probl. Contr. Inf. Theory , pages 149–162, 1973. [223] R. G. Gallager. Source coding with side information and universal coding. Unpublished manuscript, also presented at the Int. Symp. Inf. Theory, Oct. 1974. [224] R. G. Gallager. A simple derivation of the coding theorem and some applications. IEEE Trans. Inf. Theory , IT-11:3–18, 1965. [225] R. G. Gallager. Capacity and coding for degraded broadcast channels. Probl. Peredachi Inf. , 10(3):3–14, 1974. [226] R. G. Gallager. Basic limits on protocol information in data communication networks. IEEE Trans. Inf. Theory , pages 385–398, July 1976. [227] R. G. Gallager. A minimum delay routing algorithm using distributed computation. IEEE Trans. Commun. , pages 73–85, Jan. 1977. [228] R. G. Gallager. Variations on a theme by Huffman. IEEE Trans. Inf. Theory , pages 668–674, Nov. 1978. [229] R. G. Gallager. Source Coding with Side Information and Universal Coding (Tech. Rept. LIDS-P-937). Laboratory for Information Decision Systems, MIT, Cambridge, MA, 1979. [230] R. G. Gallager. A perspective on multiaccess channels. IEEE Trans. Inf. Theory , pages 124–142, Mar. 1985. [231] R. G. Gallager. Low density parity check codes. IRE Trans. Inf. Theory , IT-8:21–28, Jan. 1962. [232] R. G. Gallager. Low Density Parity Check Codes . MIT Press, Cambridge, MA, 1963. [233] R. G. Gallager. Information Theory and Reliable Communication . Wiley, New York, 1968. [234] A. A. El Gamal and T. M. Cover. Achievable rates for multiple descriptions. IEEE Trans. Inf. Theory , pages 851–857, November 1982. [235] A. El Gamal. Broadcast channels with and without feedback. 11th Ann. Asilomar Conf. Circuits , pages 180–183, Nov. 1977. [236] A. El Gamal. Capacity of the product and sum of two unmatched broadcast channels. Probl. Peredachi Inf. , pages 3–23, Jan.–Mar. 1980. [237] A. A. El Gamal. The feedback capacity of degraded broadcast channels (corresp.). IEEE Trans. Inf. Theory , pages 379–381, May 1978. [238] A. A. El Gamal. The capacity of a class of broadcast channels. IEEE Trans. Inf. Theory , pages 166–169, Mar. 1979. [239] A. A. El Gamal. The capacity of the physically degraded Gaussian broadcast channel with feedback (corresp.). IEEE Trans. Inf. Theory , pages 508–511, July 1981. [240] A. A. El Gamal and E. C. van der Meulen. A proof of Marton’s coding theorem for the discrete memoryless broadcast channel. IEEE Trans. Inf. Theory , pages 120–122, Jan. 1981. [241] I. M. Gelfand, A. N. Kolmogorov, and A. M. Yaglom. On the general definition of mutual information. Rept. Acad. Sci. USSR , pages 745–748, 1956. [242] S. I. Gelfand. Capacity of one broadcast channel. Probl. Peredachi Inf. , pages 106–108, July–Sept. 1977. [243] S. I. Gelfand and M. S. Pinsker. Capacity of a broadcast channel with one deterministic component. Probl. Peredachi Inf. , pages 24–34, Jan.–Mar. 1980. [244] S. I. Gelfand and M. S. Pinsker. Coding for channel with random parameters. Probl. Contr. Inf. Theory , pages 19–31, 1980. [245] A. Gersho and R. M. Gray. Vector Quantization and Signal Compression . Kluwer, Boston, 1992. [246] G. G. Rayleigh and J. M. Cioffi. Spatio-temporal coding for wireless communication. IEEE Trans. Commun. , 46:357–366, 1998. [247] J. D. Gibson and J. L. Melsa. Introduction to Nonparametric Detection with Applications . IEEE Press, New York, 1996. [248] E. N. Gilbert. Codes based on inaccurate source probabilities. IEEE Trans. Inf. Theory , pages 304–314, May 1971. [249] E. N. Gilbert and E. F. Moore. Variable length binary encodings. Bell Syst. Tech. J. , 38:933–967, 1959. [250] S. Goldman. Some fundamental considerations concerning noise reduction and range in radar and communication. Proc. Inst. Elec. Engg. , pages 584–594, 1948. [251] S. Goldman. Information Theory . Prentice-Hall, Englewood Cliffs, NJ, 1953. [252] A. Goldsmith and M. Effros. The capacity region of Gaussian broadcast channels with intersymbol interference and colored Gaussian noise. IEEE Trans. Inf. Theory , 47:2–8, Jan. 2001. [253] S. W. Golomb. Run-length encodings. IEEE Trans. Inf. Theory , pages 399–401, July 1966. [254] S. W. Golomb, R. E. Peile, and R. A. Scholtz. Basic Concepts in Information Theory and Coding: The Adventures of Secret Agent 00111 ( Applications of Communications Theory ). Plenum Publishing, New York, 1994. [255] A. J. Grant, B. Rimoldi, R. L. Urbanke, and P. A. Whiting. Rate-splitting multiple access for discrete memoryless channels. IEEE Trans. Inf. Theory , pages 873–890, Mar. 2001. [256] R. M. Gray. Source Coding Theory . Kluwer, Boston, 1990. [257] R. M. Gray and L. D. Davisson, (Eds.). Ergodic and Information Theory . Dowden, Hutchinson & Ross, Stroudsburg, PA, 1977. [258] R. M. Gray and Lee D. Davisson. Source coding theorems without the ergodic assumption. IEEE Trans. Inf. Theory , pages 502–516, July 1974. [259] R. M. Gray. Sliding block source coding. IEEE Trans. Inf. Theory , IT-21:357–368, 1975. [260] R. M. Gray. Entropy and Information Theory . Springer-Verlag, New York, 1990. [261] R. M. Gray and A. Wyner. Source coding for a simple network. Bell Syst. Tech. J. , 58:1681–1721, 1974. [262] U. Grenander and G. Szego. Toeplitz Forms and Their Applications . University of California Press, Berkeley, CA, 1958. [263] B. Grünbaum. Convex Polytopes . Interscience, New York, 1967. [264] S. Guiasu. Information Theory with Applications . McGraw-Hill, New York, 1976. [265] B. E. Hajek and M. B. Pursley. Evaluation of an achievable rate region for the broadcast channel. IEEE Trans. Inf. Theory , pages 36–46, Jan. 1979. [266] R. V. Hamming. Error detecting and error correcting codes. Bell Syst. Tech. J. , 29:147–160, 1950. [267] T. S. Han. The capacity region for the deterministic broadcast channel with a common message (corresp.). IEEE Trans. Inf. Theory , pages 122–125, Jan. 1981. [268] T. S. Han and S. I. Amari. Statistical inference under multiterminal data compression. IEEE Trans. Inf. Theory , pages 2300–2324, Oct. 1998. [269] T. S. Han and S. Verdu. New results in the theory of identification via channels. IEEE Trans. Inf. Theory , pages 14–25, Jan. 1992. [270] T. S. Han. Nonnegative entropy measures of multivariate symmetric correlations. Inf. Control , 36(2):133–156, 1978. [271] T. S. Han. The capacity region of a general multiple access channel with certain correlated sources. Inf. Control , 40:37–60, 1979. [272] T. S. Han. Information-Spectrum Methods in Information Theory . Springer-Verlag, New York, 2002. [273] T. S. Han and M. H. M. Costa. Broadcast channels with arbitrarily correlated sources. IEEE Trans. Inf. Theory , IT-33:641–650, 1987. [274] T. S. Han and K. Kobayashi. A new achievable rate region for the interference channel. IEEE Trans. Inf. Theory , IT-27:49–60, 1981. [275] R. V. Hartley. Transmission of information. Bell Syst. Tech. J. , 7:535, 1928. [276] C. W. Helstrom. Elements of Signal Detection and Estimation . Prentice-Hall, Englewood Cliffs, NJ, 1995. [277] Y. Hershkovits and J. Ziv. On sliding-window universal data compression with limited memory. IEEE Trans. Inf. Theory , pages 66–78, Jan. 1998. [278] P. A. Hocquenghem. Codes correcteurs d’erreurs. Chiffres , 2:147–156, 1959. [279] J. L. Holsinger. Digital Communication over Fixed Time-Continuous Channels with Memory, with Special Application to Telephone Channels (Technical Report). MIT, Cambridge, MA, 1964. [280] M. L. Honig, U. Madhow, and S. Verdu. Blind adaptive multiuser detection. IEEE Trans. Inf. Theory , pages 944–960, July 1995. [281] J. E. Hopcroft and J. D. Ullman. Introduction to Automata Theory, Formal Languages and Computation . Addison-Wesley, Reading, MA, 1979. [282] Y. Horibe. An improved bound for weight-balanced tree. Inf. Control , 34:148–151, 1977. [283] D. A. Huffman. A method for the construction of minimum redundancy codes. Proc. IRE , 40:1098–1101, 1952. [284] J. Y. Hui. Switching an Traffic Theory for Integrated Broadband Networks . Kluwer, Boston, 1990. [285] J. Y. N. Hui and P. A. Humblet. The capacity region of the totally asynchronous multiple-access channel. IEEE Trans. Inf. Theory , pages 207–216, Mar. 1985. [286] S. Ihara. On the capacity of channels with additive non-Gaussian noise. Inf. Contr. , pages 34–39, 1978. [287] S. Ihara. Information Theory for Continuous Systems . World Scientific, Singapore, 1993. [288] K. A. Schouhamer Immink, Paul H. Siegel, and Jack K. Wolf. Codes for digital recorders. IEEE Trans. Inf. Theory , pages 2260–2299, Oct. 1998. [289] N. S. Jayant (Ed.). Waveform Quantization and Coding . IEEE Press, New York, 1976. [290] N. S. Jayant and P. Noll. Digital Coding of Waveforms . Prentice-Hall, Englewood Cliffs, NJ, 1984. [291] E. T. Jaynes. Information theory and statistical mechanics. Phys. Rev. , 106:620, 1957. [292] E. T. Jaynes. Information theory and statistical mechanics II. Phys. Rev. , 108:171, 1957. [293] E. T. Jaynes. On the rationale of maximum entropy methods. Proc. IEEE , 70:939–952, 1982. [294] E. T. Jaynes. Papers on Probability, Statistics and Statistical Physics . Reidel, Dordrecht, The Netherlands, 1982. [295] F. Jelinek. Buffer overflow in variable length encoding of fixed rate sources. IEEE Trans. Inf. Theory , IT-14:490–501, 1968. [296] F. Jelinek. Evaluation of expurgated error bounds. IEEE Trans. Inf. Theory , IT-14:501–505, 1968. [297] F. Jelinek. Probabilistic Information Theory . McGraw-Hill, New York, 1968. [298] F. Jelinek. Statistical Methods for Speech Recognition . MIT Press, Cambridge, MA, 1998. [299] R Jozsa and B. Schumacher. A new proof of the quantum noiseless coding theorem. J Mod. Opt. , pages 2343–2350, 1994. [300] G. G. Langdon, Jr. A note on the Ziv–Lempel model for compressing individual sequences. IEEE Trans. Inf. Theory , pages 284–287, Mar. 1983. [301] J. Justesen. A class of constructive asymptotically good algebraic codes. IEEE Trans. Inf. Theory , IT-18:652–656, 1972. [302] M. Kac. On the notion of recurrence in discrete stochastic processes. Bull. Am. Math. Soc. , pages 1002–1010, Oct. 1947. [303] T. Kailath and J. P. M. Schwalkwijk. A coding scheme for additive noise channels with feedback. Part I: No bandwidth constraints. IEEE Trans. Inf. Theory , IT-12:172–182, 1966. [304] T. Kailath and H. V. Poor. Detection of stochastic processes. IEEE Trans. Inf. Theory , pages 2230–2259, Oct. 1998. [305] S. Karlin. Mathematical Methods and Theory in Games, Programming and Economics , Vol. 2. Addison-Wesley, Reading, MA, 1959. [306] J. Karush. A simple proof of an inequality of McMillan. IRE Trans. Inf. Theory , IT-7:118, 1961. [307] F. P. Kelly. Notes on effective bandwidth. Stochastic Networks Theory and Applications , pages 141–168, 1996. [308] J. Kelly. A new interpretation of information rate. Bell Syst. Tech. J , 35:917–926, July 1956. [309] J. H. B. Kemperman. On the Optimum Rate of Transmitting Information (Lecture Notes in Mathematics), pages 126–169. Springer Verlag, New York, 1967. [310] M. Kendall and A. Stuart. The Advanced Theory of Statistics . Macmillan, New York, 1977. [311] A. Y. Khinchin. Mathematical Foundations of Information Theory . Dover, New York, 1957. [312] J. C. Kieffer. A simple proof of the Moy–Perez generalization of the Shannon–McMillan theorem. Pacific J. Math. , 51:203–206, 1974. [313] J. C. Kieffer. A survey of the theory of source coding with a fidelity criterion. IEEE Trans. Inf. Theory , pages 1473–1490, Sept. 1993. [314] Y. H. Kim. Feedback capacity of first-order moving average Gaussian channel. Proc. IEEE Int. Symp. Information Theory , Adelaide, pages 416–420, Sept. 2005. [315] D. E. Knuth. Dynamic Huffman coding. J. Algorithms , pages 163–180, 1985. [316] D. E. Knuth. Art of Computer Programming . [317] D. E. Knuth and A. C. Yao. The complexity of random number generation. In J. F. Traub (Ed.), Algorithms and Complexity: Recent Results and New Directions (Proceedings of the Symposium on New Directions and Recent Results in Algorithms and Complexity, Carnegie-Mellon University, 1976), pages 357–428. Academic Press, New York, 1976. [318] A. N. Kolmogorov. A new metric invariant of transitive dynamical systems and automorphism in Lebesgue spaces. Dokl. Akad. Nauk SSSR , pages 861–864, 1958. [319] A. N. Kolmogorov. On the Shannon theory of information transmission in the case of continuous signals. IRE Trans. Inf. Theory , IT-2:102–108, Sept. 1956. [320] A. N. Kolmogorov. A new invariant for transitive dynamical systems. Dokl. Acad. Nauks SSR , 119:861–864, 1958. [321] A. N. Kolmogorov. Three approaches to the quantitative definition of information. Probl. Inf. Transm. (USSR) , 1:4–7, 1965. [322] A. N. Kolmogorov. Logical basis for information theory and probability theory. IEEE Trans. Inf. Theory , IT-14:662–664, 1968. [323] A. N. Kolmogorov. The theory of transmission of information. In Selected Works of A. N. Kolmogorov, Vol. III: Information Theory and the Theory of Algorithms , Session on scientific problems of automatization in industry, Vol. 1, Plenary talks, Izd. Akad. Nauk SSSR, Moscow, 1957, pages 66–99. Kluwer, Dordrecht, The Netherlands, 1993. [324] J. Körner and K. Marton. The comparison of two noisy channels. In I. Csiszár and P. Elias (Ed.), Topics in Information Theory (Coll. Math. Soc. J. Bolyai, No. 16), pages 411–423. North-Holland, Amsterdam, 1977. [325] J. Körner and K. Marton. General broadcast channels with degraded message sets. IEEE Trans. Inf. Theory , IT-23:60–64, 1977. [326] J. Körner and K. Marton. How to encode the modulo 2 sum of two binary sources. IEEE Trans. Inf. Theory , IT-25:219–221, 1979. [327] J. Körner and A. Orlitsky. Zero error information theory. IEEE Trans. Inf. Theory , IT-44:2207–2229, Oct. 1998. [328] V. A. Kotel’nikov. On the transmission capacity of “ether” and wire in electrocommunications. Izd. Red. Upr. Svyazi RKKA , 44, 1933. [329] V. A. Kotel’nikov. The Theory of Optimum Noise Immunity . McGraw-Hill, New York, 1959. [330] L. G. Kraft. A device for quantizing, grouping and coding amplitude modulated pulses . Master’s thesis, Department of Electrical Engineering, MIT, Cambridge, MA, 1949. [331] R. E. Krichevsky. Laplace’s law of succession and universal encoding. IEEE Trans. Inf. Theory , pages 296–303, Jan. 1998. [332] R. E. Krichevsky. Universal Compression and Retrieval . Kluwer, Dordrecht, The Netherlands, 1994. [333] R. E. Krichevsky and V. K. Trofimov. The performance of universal encoding. IEEE Trans. Inf. Theory , pages 199–207, Mar. 1981. [334] S. R. Kulkarni, G. Lugosi, and S. S. Venkatesh. Learning pattern classification: a survey. IEEE Trans. Inf. Theory , pages 2178–2206, Oct. 1998. [335] S. Kullback. Information Theory and Statistics . Wiley, New York, 1959. [336] S. Kullback. A lower bound for discrimination in terms of variation. IEEE Trans. Inf. Theory , IT-13:126–127, 1967. [337] S. Kullback, J. C. Keegel, and J. H. Kullback. Topics in Statistical Information Theory . Springer-Verlag, Berlin, 1987. [338] S. Kullback and M. A. Khairat. A note on minimum discrimination information. Ann. Math. Stat. , pages 279–280, 1966. [339] S. Kullback and R. A. Leibler. On information and sufficiency. Ann. Math. Stat. , 22:79–86, 1951. [340] H. J. Landau and H. O. Pollak. Prolate spheroidal wave functions, Fourier analysis and uncertainty: Part II. Bell Syst. Tech. J. , 40:65–84, 1961. [341] H. J. Landau and H. O. Pollak. Prolate spheroidal wave functions, Fourier analysis and uncertainty: Part II. Bell Syst. Tech. J. , 41:1295–1336, 1962. [342] G. G. Langdon. An introduction to arithmetic coding. IBM J. Res. Dev. , 28:135–149, 1984. [343] G. G. Langdon and J. J. Rissanen. A simple general binary source code. IEEE Trans. Inf. Theory , IT-28:800, 1982. [344] A. Lapidoth and P. Narayan. Reliable communication under channel uncertainty. IEEE Trans. Inf. Theory , pages 2148–2177, Oct. 1998. [345] A. Lapidoth and J. Ziv. On the universality of the LZ-based decoding algorithm. IEEE Trans. Inf. Theory , pages 1746–1755, Sept. 1998. [346] H. A. Latané. Criteria for choice among risky ventures. J. Polit. Econ. , 38:145–155, Apr. 1959. [347] H. A. Latané and D.L. Tuttle. Criteria for portfolio building. J. Finance , 22:359–373, Sept. 1967. [348] E. A. Lee and D. G. Messerschmitt. Digital Communication , 2nd ed. Kluwer, Boston, 1994. [349] J. Leech and N. J. A. Sloane. Sphere packing and error-correcting codes. Can. J. Math , pages 718–745, 1971. [350] E. L. Lehmann and H. Scheffé. Completeness, similar regions and unbiased estimation. Sankhya , 10:305–340, 1950. [351] A. Lempel and J. Ziv. On the complexity of finite sequences. IEEE Trans. Inf. Theory , pages 75–81, Jan. 1976. [352] L. A. Levin. On the notion of a random sequence. Sov. Math. Dokl. , 14:1413–1416, 1973. [353] L. A. Levin and A. K. Zvonkin. The complexity of finite objects and the development of the concepts of information and randomness by means of the theory of algorithms. Russ. Math. Surv. , 25/6:83–124, 1970. [354] M. Li and P. Vitanyi. An Introduction to Kolmogorov Complexity and Its Applications , 2nd ed. Springer-Verlag, New York, 1997. [355] H. Liao. Multiple access channels . Ph.D. thesis, Department of Electrical Engineering, University of Hawaii, Honolulu, 1972. [356] S. Lin and D. J. Costello, Jr. Error Control Coding: Fundamentals and Applications . Prentice-Hall, Englewood Cliffs, NJ, 1983. [357] D. Lind and B. Marcus. Symbolic Dynamics and Coding . Cambridge University Press, Cambridge, 1995. [358] Y. Linde, A. Buzo, and R. M. Gray. An algorithm for vector quantizer design. IEEE Trans. Commun. , COM-28:84–95, 1980. [359] T. Linder, G. Lugosi, and K. Zeger. Rates of convergence in the source coding theorem in empirical quantizer design. IEEE Trans. Inf. Theory , pages 1728–1740, Nov. 1994. [360] T. Linder, G. Lugosi, and K. Zeger. Fixed-rate universal lossy source coding and rates of convergence for memoryless sources. IEEE Trans. Inf Theory , pages 665–676, May 1995. [361] D. Lindley. Boltzmann’s Atom: The Great Debate That Launched A Revolution in Physics . Free Press, New York, 2001. [362] A. Liversidge. Profile of Claude Shannon. In N. J. A. Sloane and A. D. Wyner (Eds.), Claude Elwood Shannon Collected Papers . IEEE Press, Piscataway, NJ, 1993 ( Omni magazine, Aug. 1987.) [363] S. P. Lloyd. Least Squares Quantization in PCM (Technical Report). Bell Lab. Tech. Note , 1957. [364] G. Louchard and Wojciech Szpankowski. On the average redundancy rate of the Lempel–Ziv code. IEEE Trans. Inf. Theory , pages 2–8, Jan. 1997. [365] L. Lovasz. On the Shannon capacity of a graph. IEEE Trans. Inf. Theory , IT-25:1–7, 1979. [366] R. W. Lucky. Silicon Dreams: Information, Man and Machine . St. Martin’s Press, New York, 1989. [367] D. J. C. Mackay. Information Theory, Inference, and Learning Algorithms . Cambridge University Press, Cambridge, 2003. [368] D. J. C. MacKay and R. M. Neal. Near Shannon limit performance of low-density parity-check codes. Electron. Lett. , pages 1645–1646, Mar. 1997. [369] F. J. MacWilliams and N. J. A. Sloane. The Theory of Error-Correcting Codes . North-Holland, Amsterdam, 1977. [370] B. Marcus. Sofic systems and encoding data. IEEE Trans. Inf. Theory , IT-31(3):366–377, May 1985. [371] R. J. Marks. Introduction to Shannon Sampling and Interpolation Theory . Springer-Verlag New York, 1991. [372] A. Marshall and I. Olkin. Inequalities: Theory of Majorization and Its Applications . Academic Press, New York, 1979. [373] A. Marshall and I. Olkin. A convexity proof of Hadamard’s inequality. Am. Math. Monthly , 89(9):687–688, 1982. [374] P. Martin-Löf. The definition of random sequences. Inf. Control , 9:602–619, 1966. [375] K. Marton. Information and information stability of ergodic sources. Probl. Inf. Transm. ( VSSR ), pages 179–183, 1972. [376] K. Marton. Error exponent for source coding with a fidelity criterion. IEEE Trans. Inf. Theory , IT-20:197–199, 1974. [377] K. Marton. A coding theorem for the discrete memoryless broadcast channel. IEEE Trans. Inf. Theory , IT-25:306–311, 1979. [378] J. L. Massey and P. Mathys. The collision channel without feedback. IEEE Trans. Inf. Theory , pages 192–204, Mar. 1985. [379] R. A. McDonald. Information rates of Gaussian signals under criteria constraining the error spectrum . D. Eng. dissertation, Yale University School of Electrical Engineering, New Haven, CT, 1961. [380] R. A. McDonald and P. M. Schultheiss. Information rates of Gaussian signals under criteria constraining the error spectrum. Proc. IEEE , pages 415–416, 1964. [381] R. A. McDonald and P. M. Schultheiss. Information rates of Gaussian signals under criteria constraining the error spectrum. Proc. IEEE , 52:415–416, 1964. [382] R. J. McEliece, D. J. C. MacKay, and J. F. Cheng. Turbo decoding as an instance of Pearl’s belief propagation algorithm. IEEE J. Sel. Areas Commun. , pages 140–152, Feb. 1998. [383] R. J. McEliece. The Theory of Information and Coding . Addison-Wesley, Reading, MA, 1977. [384] B. McMillan. The basic theorems of information theory. Ann. Math. Stat. , 24:196–219, 1953. [385] B. McMillan. Two inequalities implied by unique decipherability. IEEE Trans. Inf. Theory , IT-2:115–116, 1956. [386] N. Merhav and M. Feder. Universal schemes for sequential decision from individual data sequences. IEEE Trans. Inf. Theory , pages 1280–1292, July 1993. [387] N. Merhav and M. Feder. A strong version of the redundancy-capacity theorem of universal coding. IEEE Trans. Inf. Theory , pages 714–722, May 1995. [388] N. Merhav and M. Feder. Universal prediction. IEEE Trans. Inf. Theory , pages 2124–2147, Oct. 1998. [389] R. C. Merton and P. A. Samuelson. Fallacy of the log-normal approximation to optimal portfolio decision-making over many periods. J. Finan. Econ. , 1:67–94, 1974. [390] H. Minkowski. Diskontinuitätsbereich für arithmetische Äquivalenz. J. Math. , 129:220–274, 1950. [391] L. Mirsky. On a generalization of Hadamard’s determinantal inequality due to Szasz. Arch. Math. , VIII:274–275, 1957. [392] S. C. Moy. Generalizations of the Shannon–McMillan theorem. Pacific J. Math. , pages 705–714, 1961. [393] J. von Neumann and O. Morgenstern. Theory of Games and Economic Behaviour . Princeton University Press, Princeton, NJ, 1980. [394] J. Neyman and E. S. Pearson. On the problem of the most efficient tests of statistical hypotheses. Philos. Trans. Roy. Soc. London A , 231:289–337, 1933. [395] M. Nielsen and I. Chuang. Quantum Computation and Quantum Information . Cambridge University Press, Cambridge, 2000. [396] H. Nyquist. Certain factors affecting telegraph speed. Bell Syst. Tech. J. , 3:324, 1924. [397] H. Nyquist. Certain topics in telegraph transmission theory. AIEE Trans. , pages 617–644, Apr. 1928. [398] J. Omura. A coding theorem for discrete time sources. IEEE Trans. Inf. Theory , IT-19:490–498, 1973. [399] A. Oppenheim. Inequalities connected with definite Hermitian forms. J. London Math. Soc. , 5:114–119, 1930. [400] E. Ordentlich. On the factor-of-two bound for Gaussian multiple-access channels with feedback. IEEE Trans. Inf. Theory , pages 2231–2235, Nov. 1996. [401] E. Ordentlich and T. Cover. The cost of achieving the best portfolio in hindsight. Math. Operations Res. , 23(4): 960–982, Nov. 1998. [402] S. Orey. On the Shannon–Perez–Moy theorem. Contemp. Math. , 41:319–327, 1985. [403] A. Orlitsky. Worst-case interactive communication. I: Two messages are almost optimal. IEEE Trans. Inf. Theory , pages 1111–1126, Sept. 1990. [404] A. Orlitsky. Worst-case interactive communication. II: Two messages are not optimal. IEEE Trans. Inf. Theory , pages 995–1005, July 1991. [405] A. Orlitsky. Average-case interactive communication. IEEE Trans. Inf. Theory , pages 1534–1547, Sept. 1992. [406] A. Orlitsky and A. El Gamal. Average and randomized communication complexity. IEEE Trans. Inf. Theory , pages 3–16, Jan. 1990. [407] D. S. Ornstein. Bernoulli shifts with the same entropy are isomorphic. Adv. Math. , pages 337–352, 1970. [408] D. S. Ornstein and B. Weiss. Entropy and data compression schemes. IEEE Trans. Inf. Theory , pages 78–83, Jan. 1993. [409] D. S. Ornstein. Bernoulli shifts with the same entropy are isomorphic. Adv. Math. , 4:337–352, 1970. [410] L. H. Ozarow. The capacity of the white Gaussian multiple access channel with feedback. IEEE Trans. Inf. Theory , IT-30:623–629, 1984. [411] L. H. Ozarow and C. S. K. Leung. An achievable region and an outer bound for the Gaussian broadcast channel with feedback. IEEE Trans. Inf. Theory , IT-30:667–671, 1984. [412] H. Pagels. The Dreams of Reason: the Computer and the Rise of the Sciences of Complexity . Simon and Schuster, New York, 1988. [413] C. Papadimitriou. Information theory and computational complexity: The expanding interface . IEEE Inf. Theory Newslett . (Special Golden Jubilee Issue), pages 12–13, June 1998. [414] R. Pasco. Source coding algorithms for fast data compression . Ph.D. thesis, Stanford University, Stanford, CA, 1976. [415] A. J. Paulraj and C. B. Papadias. Space-time processing for wireless communications. IEEE Signal Processing Mag. , pages 49–83, Nov. 1997. [416] W. B. Pennebaker and J. L. Mitchell. JPEG Still Image Data Compression Standard . Van Nostrand Reinhold, New York, 1988. [417] A. Perez. Extensions of Shannon–McMillan’s limit theorem to more general stochastic processes. In Trans. Third Prague Conference on Information Theory, Statistical Decision Functions and Random Processes , pages 545–574, Czechoslovak Academy of Sciences, Prague, 1964. [418] J. R. Pierce. The early days of information theory. IEEE Trans. Inf. Theory , pages 3–8, Jan. 1973. [419] J. R. Pierce. An Introduction to Information Theory: Symbols, Signals and Noise , 2nd ed. Dover Publications, New York, 1980. [420] J. T. Pinkston. An application of rate-distortion theory to a converse to the coding theorem. IEEE Trans. Inf. Theory , IT-15:66–71, 1969. [421] M. S. Pinsker. Talk at Soviet Information Theory meeting, 1969. No abstract published. [422] M. S. Pinsker. Information and Information Stability of Random Variables and Processes . Holden-Day, San Francisco, CA, 1964. (Originally published in Russian in 1960.) [423] M. S. Pinsker. The capacity region of noiseless broadcast channels. Probl. Inf. Transm. (USSR) , 14(2):97–102, 1978. [424] M. S. Pinsker and R. L. Dobrushin. Memory increases capacity. Probl. Inf. Transm. (USSR) , pages 94–95, Jan. 1969. [425] M. S. Pinsker. Information and Stability of Random Variables and Processes . Izd. Akad. Nauk, 1960. Translated by A. Feinstein, 1964. [426] E. Plotnik, M. Weinberger, and J. Ziv. Upper bounds on the probability of sequences emitted by finite-state sources and on the redundancy of the Lempel–Ziv algorithm. IEEE Trans. Inf. Theory , IT-38(1):66–72, Jan. 1992. [427] D. Pollard. Convergence of Stochastic Processes . Springer-Verlag, New York, 1984. [428] G. S. Poltyrev. Carrying capacity for parallel broadcast channels with degraded components. Probl. Peredachi Inf. , pages 23–35, Apr.–June 1977. [429] S. Pombra and T. M. Cover. Nonwhite Gaussian multiple access channels with feedback. IEEE Trans. Inf. Theory , pages 885–892, May 1994. [430] H. V. Poor. An Introduction to Signal Detection and Estimation , 2nd ed. Springer-Verlag, New York, 1994. [431] F. Pratt. Secret and Urgent . Blue Ribbon Books, Garden City, NY, 1939. [432] L. R. Rabiner. A tutorial on hidden Markov models and selected applications in speech recognition. Proc. IEEE , pages 257–286, Feb. 1989. [433] L. R. Rabiner and R. W. Schafer. Digital Processing of Speech Signals . Prentice-Hall, Englewood Cliffs, NJ, 1978. [434] R. Ahlswede and Z. Zhang. New directions in the theory of identification via channels. IEEE Trans. Inf. Theory , 41:1040–1050, 1995. [435] C. R. Rao. Information and accuracy obtainable in the estimation of statistical parameters. Bull. Calcutta Math. Soc. , 37:81–91, 1945. [436] I. S. Reed. 1982 Claude Shannon lecture: Application of transforms to coding and related topics . IEEE Inf. Theory Newslett. , pages 4–7, Dec. 1982. [437] F. M. Reza. An Introduction to Information Theory . McGraw-Hill, New York, 1961. [438] S. O. Rice. Mathematical analysis of random noise. Bell Syst. Tech. J. , pages 282–332, Jan. 1945. [439] S. O. Rice. Communication in the presence of noise: probability of error for two encoding schemes. Bell Syst. Tech. J. , 29:60–93, 1950. [440] B. E. Rimoldi and R. Urbanke. A rate-splitting approach to the Gaussian multiple-access channel. IEEE Trans. Inf. Theory , pages 364–375, Mar. 1996. [441] J. Rissanen. Generalized Kraft inequality and arithmetic coding. IBM J. Res. Dev. , 20:198, 1976. [442] J. Rissanen. Modelling by shortest data description. Automatica , 14:465–471, 1978. [443] J. Rissanen. A universal prior for integers and estimation by minimum description length. Ann. Stat. , 11:416–431, 1983. [444] J. Rissanen. Universal coding, information, prediction and estimation. IEEE Trans. Inf. Theory , IT-30:629–636, 1984. [445] J. Rissanen. Stochastic complexity and modelling. Ann. Stat. , 14:1080–1100, 1986. [446] J. Rissanen. Stochastic complexity (with discussions). J. Roy. Stat. Soc. , 49:223–239, 252–265, 1987. [447] J. Rissanen. Stochastic complexity in Statistical Inquiry . World Scientific, Singapore, 1989. [448] J. J. Rissanen. Complexity of strings in the class of Markov sources. IEEE Trans. Inf. Theory , pages 526–532, July 1986. [449] J. J. Rissanen and G. G. Langdon, Jr. Universal modeling and coding. IEEE Trans. Inf. Theory , pages 12–23, Jan. 1981. [450] B. Y. Ryabko. Encoding a source with unknown but ordered probabilities. Probl. Inf. Transm. , pages 134–139, Oct. 1979. [451] B. Y. Ryabko. A fast on-line adaptive code. IEEE Trans. Inf. Theory , pages 1400–1404, July 1992. [452] P. A. Samuelson. Lifetime portfolio selection by dynamic stochastic programming. Rev. Econ. Stat. , pages 236–239, 1969. [453] P. A. Samuelson. The “fallacy” of maximizing the geometric mean in long sequences of investing or gambling. Proc. Natl. Acad. Sci. USA , 68:214–224, Oct. 1971. [454] P. A. Samuelson. Why we should not make mean log of wealth big though years to act are long. J. Banking and Finance , 3:305–307, 1979. [455] I. N. Sanov. On the probability of large deviations of random variables. Mat. Sbornik , 42:11–44, 1957. English translation in Sel. Transl. Math. Stat. Prob. , Vol. 1, pp. 213–244, 1961. [456] A. A. Sardinas and G.W. Patterson. A necessary and sufficient condition for the unique decomposition of coded messages. IRE Conv. Rec., Pt. 8 , pages 104–108, 1953. [457] H. Sato. On the capacity region of a discrete two-user channel for strong interference. IEEE Trans. Inf. Theory , IT-24:377–379, 1978. [458] H. Sato. The capacity of the Gaussian interference channel under strong interference. IEEE Trans. Inf. Theory , IT-27:786–788, 1981. [459] H. Sato and M. Tanabe. A discrete two-user channel with strong interference. Trans. IECE Jap. , 61:880–884, 1978. [460] S. A. Savari. Redundancy of the Lempel–Ziv incremental parsing rule. IEEE Trans. Inf. Theory , pages 9–21, January 1997. [461] S. A. Savari and R. G. Gallager. Generalized Tunstall codes for sources with memory. IEEE Trans. Inf. Theory , pages 658–668, Mar. 1997. [462] K. Sayood. Introduction to Data Compression . Morgan Kaufmann, San Francisco, CA, 1996. [463] J. P. M. Schalkwijk. A coding scheme for additive noise channels with feedback. II: Bandlimited signals. IEEE Trans. Inf. Theory , pages 183–189, Apr. 1966. [464] J. P. M. Schalkwijk. The binary multiplying channel: a coding scheme that operates beyond Shannon’s inner bound. IEEE Trans. Inf. Theory , IT-28:107–110, 1982. [465] J. P. M. Schalkwijk. On an extension of an achievable rate region for the binary multiplying channel. IEEE Trans. Inf. Theory , IT-29:445–448, 1983. [466] C. P. Schnorr. A unified approach to the definition of random sequences. Math. Syst. Theory , 5:246–258, 1971. [467] C. P. Schnorr. Process, complexity and effective random tests. J. Comput. Syst. Sci. , 7:376–388, 1973. [468] C. P. Schnorr. A surview on the theory of random sequences. In R. Butts and J. Hinitikka (Eds.), Logic, Methodology and Philosophy of Science . Reidel, Dordrecht, The Netherlands, 1977. [469] G. Schwarz. Estimating the dimension of a model. Ann. Stat. , 6:461–464, 1978. [470] S. Shamai and S. Verdu. The empirical distribution of good codes. IEEE Trans. Inf. Theory , pages 836–846, May 1997. [471] C. E. Shannon. A Mathematical Theory of Cryptography (Tech. Rept. MM 45-110-02). Bell Lab. Tech. Memo., Sept. 1, 1945. [472] C. E. Shannon. A mathematical theory of communication. Bell Syst. Tech. J. , 27:379–423,623–656, 1948. [473] C. E. Shannon. Some geometrical results in channel capacity. Verh. Dtsch. Elektrotechnik. Fachber. , pages 13–15, 1956. [474] C. E. Shannon. The zero-error capacity of a noisy channel. IRE Trans. Inf. Theory , IT-2:8–19, 1956. [475] C. E. Shannon. Channels with side information at the transmitter. IBM J. Res. Dev. , pages 289–293, 1958. [476] C. E. Shannon. Probability of error for optimal codes in a Gaussian channel. Bell Syst. Tech. J. , pages 611–656, May 1959. [477] C. E. Shannon. Two-way communication channels. Proc. 4th. Berkeley Symp. Mathematical Statistics and Probability (June 20–July 30, 1960), pages 611–644, 1961. [478] C. E. Shannon. The wonderful world of feedback . IEEE Int. Symp. Infor. Theory, ser. First Shannon Lecture, Ashkelon, Israel, 1973. [479] C. E. Shannon. The mind reading machine. In Shannon’s Collected Papers , pages 688–689, 1993. [480] C. E. Shannon. Communication in the presence of noise. Proc. IRE , 37:10–21, January 1949. [481] C. E. Shannon. Communication theory of secrecy systems. Bell Syst. Tech. J. , 28:656–715, 1949. [482] C. E. Shannon. Prediction and entropy of printed English. Bell Syst. Tech. J. , 30:50–64, January 1951. [483] C. E. Shannon. Certain results in coding theory for noisy channels. Infor. Control , 1:6–25, 1957. [484] C. E. Shannon. Channels with side information at the transmitter. IBM J. Res. Dev. , 2:289–293, 1958. [485] C. E. Shannon. Coding theorems for a discrete source with a fidelity criterion. IRE Nat. Conv. Rec., Pt. 4 , pages 142–163, 1959. [486] C. E. Shannon. Two-way communication channels. In Proc. 4th Berkeley Symp. Math. Stat. Prob. , Vol. 1, pages 611–644. University of California Press, Berkeley, CA, 1961. [487] C. E. Shannon, R. G. Gallager, and E. R. Berlekamp. Lower bounds to error probability for coding in discrete memoryless channels. I. Inf. Control , 10:65–103, 1967. [488] C. E. Shannon, R. G. Gallager, and E. R. Berlekamp. Lower bounds to error probability for coding in discrete memoryless channels. II. Inf. Control , 10:522–552, 1967. [489] C. E. Shannon and W. W. Weaver. The Mathematical Theory of Communication . University of Illinois Press, Urbana, IL, 1949. [490] C. E. Shannon. General treatment of the problem of coding. IEEE Trans. Inf. Theory , pages 102–104, February 1953. [491] W. F. Sharpe. Investments , 3rd ed. Prentice-Hall, Englewood Cliffs, NJ, 1985. [492] P. C. Shields. Universal redundancy rates do not exist. IEEE Trans. Inf. Theory , pages 520–524, Mar. 1993. [493] P. C. Shields. The interactions between ergodic theory and information theory. IEEE Trans. Inf. Theory , pages 2079–2093, Oct. 1998. [494] P. C. Shields and B. Weiss. Universal redundancy rates for the class of B-processes do not exist. IEEE Trans. Inf. Theory , pages 508–512, Mar. 1995. [495] J. E. Shore and R. W. Johnson. Axiomatic derivation of the principle of maximum entropy and the principle of minimum cross-entropy. IEEE Trans. Inf. Theory , IT-26:26–37, 1980. [496] Y. M. Shtarkov. Universal sequential coding of single messages. Probl. Inf. Transm. ( USSR ), 23(3):3–17, July–Sept. 1987. [497] A. Shwartz and A. Weiss. Large Deviations for Performance Analysis, Queues, Communication and Computing . Chapman & Hall, London, 1995. [498] D. Slepian. Key Papers in the Development of Information Theory . IEEE Press, New York, 1974. [499] D. Slepian. On bandwidth. Proc. IEEE , pages 292–300, Mar. 1976. [500] D. Slepian and H. O. Pollak. Prolate spheroidal wave functions, Fourier analysis and uncertainty: Part I. Bell Syst. Tech. J. , 40:43–64, 1961. [501] D. Slepian and J. K. Wolf. A coding theorem for multiple access channels with correlated sources. Bell Syst. Tech. J. , 52:1037–1076, 1973. [502] D. Slepian and J. K. Wolf. Noiseless coding of correlated information sources. IEEE Trans. Inf. Theory , IT-19:471–480, 1973. [503] D. S. Slepian. Information theory in the fifties. IEEE Trans. Inf. Theory , pages 145–148, Mar. 1973. [504] R. J. Solomonoff. A formal theory of inductive inference. Inf. Control , 7:1–22,224–254, 1964. [505] A. Stam. Some inequalities satisfied by the quantities of information of Fisher and Shannon. Inf. Control , 2:101–112, June 1959. [506] A. Steane. Quantum computing. Rept. Progr. Phys ., pages 117–173, Feb. 1998. [507] J. A. Storer and T. G. Szymanski. Data compression via textual substitution. J. ACM , 29(4):928–951, 1982. [508] W. Szpankowski. Asymptotic properties of data compression and suffix trees. IEEE Trans. Inf. Theory , pages 1647–1659, Sept. 1993. [509] W. Szpankowski. Average Case Analysis of Algorithms on Sequences . Wiley-Interscience, New York, 2001. [510] D. L. Tang and L. R. Bahl. Block codes for a class of constrained noiseless channels. Inf. Control , 17:436–461, 1970. [511] I. E. Teletar and R. G. Gallager. Combining queueing theory with information theory for multiaccess. IEEE J. Sel. Areas Commun. , pages 963–969, Aug. 1995. [512] E. Teletar. Capacity of multiple antenna Gaussian channels. Eur. Trans. Telecommun. , 10(6):585–595, 1999. [513] J. A. Thomas. Feedback can at most double Gaussian multiple access channel capacity. IEEE Trans. Inf. Theory , pages 711–716, Sept. 1987. [514] T. J. Tjalkens and F. M. J. Willems. A universal variable-to-fixed length source code based on Lawrence’s algorithm. IEEE Trans. Inf. Theory , pages 247–253, Mar. 1992. [515] T. J. Tjalkens and F. M. J. Willems. Variable- to fixed-length codes for Markov sources. IEEE Trans. Inf. Theory , pages 246–257, Mar. 1987. [516] S. C. Tornay. Ockham: Studies and Selections (chapter “Commentarium in Sententias,” I, 27). Open Court Publishers, La Salle, IL, 1938. [517] H. L. Van Trees. Detection, Estimation, and Modulation Theory , Part I. Wiley, New York, 1968. [518] B. S. Tsybakov. Capacity of a discrete-time Gaussian channel with a filter. Probl. Inf. Transm. , pages 253–256, July–Sept. 1970. [519] B. P. Tunstall. Synthesis of noiseless compression codes . Ph.D. dissertation, Georgia Institute of Technology, Atlanta, GA, Sept. 1967. [520] G. Ungerboeck. Channel coding with multilevel/phase signals. IEEE Trans. Inf. Theory , pages 55–67, January 1982. [521] G. Ungerboeck. Trellis-coded modulation with redundant signal sets part I: Introduction. IEEE Commun. Mag. , pages 5–11, Feb. 1987. [522] G. Ungerboeck. Trellis-coded modulation with redundant signal sets part II: State of the art. IEEE Commun. Mag. , pages 12–21, Feb. 1987. [523] I. Vajda. Theory of Statistical Inference and Information . Kluwer, Dordrecht, The Netherlands, 1989. [524] L. G. Valiant. A theory of the learnable. Commun. ACM , pages 1134–1142, 1984. [525] J. M. Van Campenhout and T. M. Cover. Maximum entropy and conditional probability. IEEE Trans. Inf. Theory , IT-27:483–489, 1981. [526] E. Van der Meulen. Random coding theorems for the general discrete memoryless broadcast channel. IEEE Trans. Inf. Theory , IT-21:180–190, 1975. [527] E. C. van der Meulen. Some reflections on the interference channel . In R. E. Blahut, D. J. Costello, U. Maurer, and T. Mittelholzer, (Eds.), Communications and Cryptography: Two Sides of One Tapestry . Kluwer, Boston, 1994. [528] E. C. Van der Meulen. A survey of multi-way channels in information theory. IEEE Trans. Inf. Theory , IT-23:1–37, 1977. [529] E. C. Van der Meulen. Recent coding theorems for multi-way channels. Part I: The broadcast channel (1976-1980). In J. K. Skwyrzinsky (Ed.), New Concepts in Multi-user Communication (NATO Advanced Study Institute Series), pages 15–51. Sijthoff & Noordhoff, Amsterdam, 1981. [530] E. C. Van der Meulen. Recent coding theorems and converses for multiway channels. Part II: The multiple access channel (1976–1985) (Technical Report). Department Wiskunde, Katholieke Universiteit Leuven, 1985. [531] V. N. Vapnik. Estimation of Dependencies Based on Empirical Data . Springer-Verlag, New York, 1982. [532] V. N. Vapnik. The Nature of Statistical Learning Theory . Springer-Verlag, New York, 1991. [533] V. N. Vapnik and A. Y. Chervonenkis. On the uniform convergence of relative frequencies to their probabilities. Theory Prob. Appl. , pages 264–280, 1971. [534] V. N. Vapnik and A. Y. Chervonenkis. Necessary and sufficient conditions for the uniform convergence of means to their expectations. Theory Prob. Appl. , pages 532–553, 1981. [535] S. Verdu. The capacity region of the symbol-asynchronous Gaussian multiple-access channel. IEEE Trans. Inf. Theory , pages 733–751, July 1989. [536] S. Verdu. Recent Progress in Multiuser Detection (Advances in Communication and Signal Processing), Springer-Verlag, Berlin, 1989. [Reprinted in N. Abramson (Ed.), Multiple Access Communications , IEEE Press, New York, 1993.] [537] S. Verdu. The exponential distribution in information theory. Probl. Inf. Transm. (USSR) , pages 86–95, Jan.–Mar. 1996. [538] S. Verdu. Fifty years of Shannon theory. IEEE Trans. Inf. Theory , pages 2057–2078, Oct. 1998. [539] S. Verdu. Multiuser Detection . Cambridge University Press, New York, 1998. [540] S. Verdu and T. S. Han. A general formula for channel capacity. IEEE Trans. Inf. Theory , pages 1147–1157, July 1994. [541] S. Verdu and T. S. Han. The role of the asymptotic equipartition property in noiseless source coding. IEEE Trans. Inf. Theory , pages 847–857, May 1997. [542] S. Verdu and S. W. McLaughlin (Eds.). Information Theory: 50 Years of Discovery . Wiley–IEEE Press, New York, 1999. [543] S. Verdu and V. K. W. Wei. Explicit construction of optimal constant-weight codes for identification via channels. IEEE Trans. Inf. Theory , pages 30–36, Jan. 1993. [544] A. C. G. Verdugo Lazo and P. N. Rathie. On the entropy of continuous probability distributions. IEEE Trans. Inf. Theory , IT-24:120–122, 1978. [545] M. Vidyasagar. A Theory of Learning and Generalization . Springer-Verlag, New York, 1997. [546] K. Visweswariah, S. R. Kulkarni, and S. Verdu. Source codes as random number generators. IEEE Trans. Inf. Theory , pages 462–471, Mar. 1998. [547] A. J. Viterbi and J. K. Omura. Principles of Digital Communication and Coding . McGraw-Hill, New York, 1979. [548] J. S. Vitter. Dynamic Huffman coding. ACM Trans. Math. Software , pages 158–167, June 1989. [549] V. V. V’yugin. On the defect of randomness of a finite object with respect to measures with given complexity bounds. Theory Prob. Appl. , 32(3):508–512, 1987. [550] A. Wald. Sequential Analysis . Wiley, New York, 1947. [551] A. Wald. Note on the consistency of the maximum likelihood estimate. Ann. Math. Stat. , pages 595–601, 1949. [552] M. J. Weinberger, N. Merhav, and M. Feder. Optimal sequential probability assignment for individual sequences. IEEE Trans. Inf. Theory , pages 384–396, Mar. 1994. [553] N. Weiner. Cybernetics . MIT Press, Cambridge, MA, and Wiley, New York, 1948. [554] T. A. Welch. A technique for high-performance data compression. Computer , 17(1):8–19, Jan. 1984. [555] N. Wiener. Extrapolation, Interpolation and Smoothing of Stationary Time Series . MIT Press, Cambridge, MA, and Wiley, New York, 1949. [556] H. J. Wilcox and D. L. Myers. An Introduction to Lebesgue Integration and Fourier Series . R.E. Krieger, Huntington, NY, 1978. [557] F. M. J. Willems. The feedback capacity of a class of discrete memoryless multiple access channels. IEEE Trans. Inf. Theory , IT-28:93–95, 1982. [558] F. M. J. Willems and A. P. Hekstra. Dependence balance bounds for single-output two-way channels. IEEE Trans. Inf. Theory , IT-35:44–53, 1989. [559] F. M. J. Willems. Universal data compression and repetition times. IEEE Trans. Inf. Theory , pages 54–58, Jan. 1989. [560] F. M. J. Willems, Y. M. Shtarkov, and T. J. Tjalkens. The context-tree weighing method: basic properties. IEEE Trans. Inf. Theory , pages 653–664, May 1995. [561] F. M. J. Willems, Y. M. Shtarkov, and T. J. Tjalkens. Context weighting for general finite-context sources. IEEE Trans. Inf. Theory , pages 1514–1520, Sept. 1996. [562] H. S. Witsenhausen. The zero-error side information problem and chromatic numbers. IEEE Trans. Inf. Theory , pages 592–593, Sept. 1976. [563] H. S. Witsenhausen. Some aspects of convexity useful in information theory. IEEE Trans. Inf. Theory , pages 265–271, May 1980. [564] I. H. Witten, R. M. Neal, and J. G. Cleary. Arithmetic coding for data compression. Commun. ACM , 30(6):520–540, June 1987. [565] J. Wolfowitz. The coding of messages subject to chance errors. Ill. J. Math. , 1:591–606, 1957. [566] J. Wolfowitz. Coding Theorems of Information Theory . Springer-Verlag, Berlin, and Prentice-Hall, Englewood Cliffs, NJ, 1978. [567] P. M. Woodward. Probability and Information Theory with Applications to Radar . McGraw-Hill, New York, 1953. [568] J. Wozencraft and B. Reiffen. Sequential Decoding . MIT Press, Cambridge, MA, 1961. [569] J. M. Wozencraft and I. M. Jacobs. Principles of Communication Engineering . Wiley, New York, 1965. [570] A. Wyner. A theorem on the entropy of certain binary sequences and applications II. IEEE Trans. Inf. Theory , IT-19:772–777, 1973. [571] A. Wyner. The common information of two dependent random variables. IEEE Trans. Inf. Theory , IT-21:163–179, 1975. [572] A. Wyner. On source coding with side information at the decoder. IEEE Trans. Inf. Theory , IT-21:294–300, 1975. [573] A. Wyner and J. Ziv. A theorem on the entropy of certain binary sequences and applications I. IEEE Trans. Inf. Theory , IT-19:769–771, 1973. [574] A. Wyner and J. Ziv. The rate distortion function for source coding with side information at the receiver. IEEE Trans. Inf. Theory , IT-22:1–11, 1976. [575] A. Wyner and J. Ziv. On entropy and data compression. IEEE Trans. Inf. Theory , 1991. [576] A. D. Wyner. Capacity of the the band-limited Gaussian channel. Bell Syst. Tech. J. , 45:359–395, Mar. 1966. [577] A. D. Wyner. Communication of analog data from a Gaussian source over a noisy channel. Bell Syst. Tech. J. , pages 801–812, May–June 1968. [578] A. D. Wyner. Recent results in the Shannon theory. IEEE Trans. Inf. Theory , pages 2–10, Jan. 1974. [579] A. D. Wyner. The wiretap channel. Bell Syst. Tech. J. , pages 1355–1387, 1975. [580] A. D. Wyner. The rate-distortion function for source coding with side information at the decoder. II: General sources. Inf. Control , pages 60–80, 1978. [581] A. D. Wyner. Shannon-theoretic approach to a Gaussian cellular multiple-access channel. IEEE Trans. Inf. Theory , pages 1713–1727, Nov. 1994. [582] A. D. Wyner and A. J. Wyner. Improved redundancy of a version of the Lempel–Ziv algorithm. IEEE Trans. Inf. Theory , pages 723–731, May 1995. [583] A. D. Wyner and J. Ziv. Bounds on the rate-distortion function for stationary sources with memory. IEEE Trans. Inf. Theory , pages 508–513, Sept. 1971. [584] A. D. Wyner and J. Ziv. The rate-distortion function for source coding with side information at the decoder. IEEE Trans. Inf. Theory , pages 1–10, Jan. 1976. [585] A. D. Wyner and J. Ziv. Some asymptotic properties of the entropy of a stationary ergodic data source with applications to data compression. IEEE Trans. Inf. Theory , pages 1250–1258, Nov. 1989. [586] A. D. Wyner and J. Ziv. Classification with finite memory. IEEE Trans. Inf. Theory , pages 337–347, Mar. 1996. [587] A. D. Wyner, J. Ziv, and A. J. Wyner. On the role of pattern matching in information theory. IEEE Trans. Inf. Theory , pages 2045–2056, Oct. 1998. [588] A. J. Wyner. The redundancy and distribution of the phrase lengths of the fixed-database Lempel–Ziv algorithm. IEEE Trans. Inf. Theory , pages 1452–1464, Sept. 1997. [589] A. D. Wyner. The capacity of the band-limited Gaussian channel. Bell Syst. Tech. J. , 45:359–371, 1965. [590] A. D. Wyner and N. J. A. Sloane (Eds.) Claude E. Shannon: Collected Papers . Wiley–IEEE Press, New York, 1993. [591] A. D. Wyner and J. Ziv. The sliding window Lempel–Ziv algorithm is asymptotically optimal. Proc. IEEE , 82(6):872–877, 1994. [592] E.-H. Yang and J. C. Kieffer. On the performance of data compression algorithms based upon string matching. IEEE Trans. Inf. Theory , pages 47–65, Jan. 1998. [593] R. Yeung. A First Course in Information Theory . Kluwer Academic, Boston, 2002. [594] H. P. Yockey. Information Theory and Molecular Biology . Cambridge University Press, New York, 1992. [595] Z. Zhang, T. Berger, and J. P. M. Schalkwijk. New outer bounds to capacity regions of two-way channels. IEEE Trans. Inf. Theory , pages 383–386, May 1986. [596] Z. Zhang, T. Berger, and J. P. M. Schalkwijk. New outer bounds to capacity regions of two-way channels. IEEE Trans. Inf. Theory , IT-32:383–386, 1986. [597] J. Ziv. Coding of sources with unknown statistics. II: Distortion relative to a fidelity criterion. IEEE Trans. Inf. Theory , IT-18:389–394, 1972. [598] J. Ziv. Coding of sources with unknown statistics. II: Distortion relative to a fidelity criterion. IEEE Trans. Inf. Theory , pages 389–394, May 1972. [599] J. Ziv. Coding theorems for individual sequences. IEEE Trans. Inf. Theory , pages 405–412, July 1978. [600] J. Ziv. Distortion-rate theory for individual sequences. IEEE Trans. Inf. Theory , pages 137–143, March 1980. [601] J. Ziv. Universal decoding for finite-state channels. IEEE Trans. Inf. Theory , pages 453–460, July 1985. [602] J. Ziv. Variable-to-fixed length codes are better than fixed-to-variable length codes for Markov sources. IEEE Trans. Inf. Theory , pages 861–863, July 1990. [603] J. Ziv and A. Lempel. A universal algorithm for sequential data compression. IEEE Trans. Inf. Theory , IT-23:337–343, 1977. [604] J. Ziv and A. Lempel. Compression of individual sequences by variable rate coding. IEEE Trans. Inf. Theory , IT-24:530–536, 1978. [605] J. Ziv and N. Merhav. A measure of relative entropy between individual sequences with application to universal classification. IEEE Trans. Inf. Theory , pages 1270–1279, July 1993. [606] W. H. Zurek. Algorithmic randomness and physical entropy. Phys. Rev. A , 40:4731–4751, Oct. 15 1989. [607] W. H. Zurek. Thermodynamic cost of computation, algorithmic complexity and the information metric. Nature , 341(6238):119–124, Sept. 1989. [608] W. H. Zurek (Ed.) Complexity, Entropy and the Physics of Information (Proceedings of the 1988 Workshop on the Complexity, Entropy and the Physics of Information). Addison-Wesley, Reading, MA, 1990.

List of Symbols LIST OF SYMBOLS X , 14 p ( x ), 14 p X ( x ), 14 χ , 14 H ( X ), 14 H ( p ), 14 H b ( X ), 14 E p g ( X ), 14 Eg ( X ), 14 , 15 p ( x, y ), 17 H ( X, Y ), 17 H ( Y | X ), 17 D ( p || q ), 20 I ( X ; Y ), 21 I ( X ; Y | Z ), 24 D ( p ( y | x )|| q ( y | x )), 25 | χ |, 30 X → Y → Z , 35 N (μ, σ 2 ), 37 T ( X ), 38 f θ ( x ), 38 P e , 39 H ( p ), 45 {0, 1}*, 55 2 − n ( H ± ) , 58 , 59 x , 60 χ n , 60 x n , 61 , 62 , 63 , 65 H ( χ ), 71 P ij , 72 H′ ( χ ), 75 C ( x ), 103 l ( x ), 103 C , 103 L ( C ), 104 D , 104 C *, 105 l i , 107 l max , 108 L , 110 L *, 111 H D ( X ), 111 [ x ], 113 F ( x ), 127 ( x ), 128 sgn( t ), 132 p i ( j ) , 138 p i , 159 o i , 159 b i , 160 b ( i ), 160 S n , 160 S ( X ), 160 W ( b, p ), 160 b , 160 p , 160 W *( p ), 161 Δ W , 165 W *( X | Y ), 165 C , 184 , 193 ( χ n , p ( y n | x n ), n ), 193 λ i , 194 λ ( n ) , 194 , 194 R , 195 , n ), 195 C , 200 ε , 202 E i , 203 ∪, 203 C *, 204 C F B , 216 , 224 F ( x ), 243 f ( x ), 243 h ( X ), 243 S , 243 h ( f ), 243 ϕ ( x ), 244 Vol( A ), 245 X Δ , 247 h ( X | Y ), 249 N n (μ, K ), 249 | K |, 249 D ( f || g ), 250 X , 253 P , 261 W , 270 F ( ω ), 271 sinc( t ), 271 N 0 , 272 x + , 276 K X , 278 K Z , 278 tr( K X ), 278 B , 282 K V , 282 C n,FB , 283 , 303 , 304 R + , 304 d max , 304 D , 306 , 306 R ( D ), 306 D ( R ), 306 R ( I ) ( D ), 307 A , 319 , 321 K ( x n , n ), 322 N ( a | x n ), 326 , 326 N ( a, b | x n , y n ), 326 ϕ ( D ), 337 , 342 T V ( x n ), 342 ( Y | x n ), 343 x , 347 χ , 347 P x , 348 , 348 P n , 348 T ( P ), 348 Q n ( x n ), 349 , 356 Q n ( E ), 361 P *, 362 1 , 369 || || 1 , 369 S t , 372 D *, 372 α , 375 β , 376 a *, 376 b *, 376 A n , 376 B n , 376 ϕ A (), 376 P λ , 380 λ *, 380 C ( p 1 , p 2 ), 386 ψ ( s ), 392 T ( X 1 , X 2 ,…, X n ), 393 V , 394 J ( θ ), 394 b T ( θ ), 396 J ij ( θ ), 397 R ( k ), 415 S ( λ ), 415 ( k ), 415 K ( n ) , 416 , 417 K p , 420 Ψ( u ), 422 p θ , 428 R ( p θ , q ), 429 R *, 429 q π , 430 A ( n, k ), 434 , 436 F U ( u ), 437 R n ( X 0 , X 1 ,…, X n −1 ), 444 Q u ( i ), 445 A jk , 445 c ( n ), 450 n k , 450 c ls , 452 , 455 A D , 460 u , 466 u ( p ), 466 p , 466 K U ( x ), 466 K U ( x | l ( x )), 467 K ( x | l ( x )), 468 log* n , 469 H 0 ( p ), 470 K ( n ), 471 P U ( x ), 481 Ω, 484 Ω n , 484 K k ( x n | n ), 496 k *, 497 p *, 497 S *, 497 S **, 497 p **, 497 C ( P/N ), 514 S , 520 X ( S ), 520 , 521 , 521 , 523 E ij , 531 Q , 534 C I , 535 R ( S ), 543 S c , 543 β * p 1 , 569 b , 613 S , 613 W ( b , F ), 615 W *( F ), 615 b *, 615 S n *, 615 W *, 615 B , 617 Δ W , 622 W * ∞ , 624 U *, 628 S * n ( x n ), 630 , 630 V n , 631 j n , 634 w ( j n ), 634 κ , 636 Γ;( m ), 638 B ( λ 1 , λ 2 ), 642 (Ω, B, P ), 644 X ( ω ), 644 H k , 645 H ∞ , 645 , 660 Γ;( z ), 662 ψ ( z ), 662 γ , 662 X ( S ), 668 , 668 , 669 , 669 , 671 J ( X ), 671 g t ( y ), 672 V ( A ), 675 f * g , 676 r , 676 || f || r , 676 C p , 676 h r ( X ), 676 V r ( X ), 677 P k , 680 S k ( n ) , 680 K ( i 1 , i 2 ,…, i k ), 680 Q k , 681 , 681 K k , 681

Index INDEX Abrahams, J. Abramson, N.M. Abu-Mostafa, Y.S. acceptance region achievable rate achievable rate distortion pair achievable rate region Aczél, J. Adams, K. adaptive dictionary compression algorithms additive channel additive noise channel additive white Gaussian noise (AWGN) Adler, R.L. AEP, see also Shannon-McMillan-Breiman theorem continuous random variables discrete random variables distortion typical growth rate joint products relative entropy sandwich proof stationary ergodic processes Ahlswede, R. Akaike, H. Algoet, P. algorithm alternating minimization arithmetic coding, see arithmetic coding Blahut-Arimoto, see Blahut-Arimoto algorithm Durbin Frank-Wolfe gradient search greedy Huffman coding, see Huffman coding iterative Lempel-Ziv, see Lempel-Ziv coding Levinson online algorithmic complexity, see Kolmogorov complexity algorithmically random almost sure alphabet discrete effective size effective support set input output alphabetic codes Altria Amari, S.I. Anantharam, V. antenna Arimoto, S., see also Blahut-Arimoto algorithm arbitrarily varying channel arithmetic coding finite precision arithmetic arithmetic mean geometric mean inequality ASCII Ash, R.B. asymmetric distortion asymptotic equipartition property, see AEP asymptotic optimality, log-optimal portfolio ATM networks atmosphere atom autocorrelation autoregressive process auxiliary random variable average codeword length average description length average distortion average power average probability of error AWGN (Additive white Gaussian noise) axiomatic definition of entropy Baer, M. Bahl, L.R. bandlimited bandpass filter bandwidth Barron, A.R. base of logarithm baseball Baum, E.B. Bayesian error exponent Bayesian hypothesis testing Bayesian posterior probability Bayesian probability of error BCH (Bose-Chaudhuri-Hocquenghem) codes Beckenbach, E.F. Beckner, W. Bell, R. Bell, T.C. Bell’s inequality Bellman, R. Bennett, C.H. Bentley, J. Benzel, R. Berger, T. Bergmans, P. Bergstrøm’s inequality Berlekamp, E.R. Bernoulli, J. Bernoulli distribution Bernoulli process Bernoulli random variable Bernoulli source rate distortion Berrou, C. Berry’s paradox Bertsekas, D. beta distribution beta function betting horse race proportional bias Bierbaum, M. Biglieri, E. binary entropy function graph binary erasure channel binary multiplier channel binary rate distortion function binary source binary symmetric channel (BSC) capacity binning random bioinformatics bird Birkhoff’s ergodic theorem bishop bit Blachman, N. Blackwell, D. Blahut, R.E., see also Blahut-Arimoto algorithm Blahut-Arimoto algorithm block code block length block Markov encoding Boltzmann, L., see also Maxwell-Boltzmann distribution bone bookie Borel-Cantelli lemma Bose, R.C. bottleneck bounded convergence theorem bounded distortion brain Brascamp, H.J. Brassard, G. Breiman, L., see also Shannon-McMillan-Breiman theorem Brillouin, L. broadcast channel capacity region convexity common information converse degraded achievablity converse with feedback Gaussian physically degraded stochastically degraded Brunn-Minkowski inequality BSC, see binary symmetric channel (BSC) Bucklew, J.A. Burg, J.P. Burg’s algorithm Burg’s maximum entropy theorem Burrows, M. burst error correcting code Buzo, A. Caire, G. cake calculus Calderbank, A.R. Canada capacity channel, see channel capacity capacity region degraded broadcast channel multiple access channel capacity theorem CAPM (Capital Asset Pricing Model) Carathéodory’s theorem cardinality cards Carleial, A.B. cascade cascade of channels Castelli, V. Cauchy distribution Cauchy-Schwarz inequality causal causal investment strategy causal portfolio universal CCITT CDMA (Code Division Multiple Access) central limit theorem centroid Cesáro mean chain rule differential entropy entropy growth rate mutual information relative entropy Chaitin, G.J. Chang, C.S. channel binary erasure binary symmetric, see binary symmetric channel (BSC) broadcast, see broadcast channel cascade discrete memoryless, see discrete memoryless channel exponential noise extension feedback Gaussian, see Gaussian channel interference, see interference channel multiple access, see multiple access channel noiseless binary parallel relay, see relay channel symmetric time-varying two-way, see two-way channel union weakly symmetric with memory Z-channel channel capacity achievability computation feedback information operational definition properties zero-error channel capacity theorem channel code channel coding achievability channel coding theorem achievability converse channel transition matrix channels with memory characteristic function Chellappa, R. Cheng, J.F. Chernoff, H. Chernoff bound Chernoff information Chernoff-Stein lemma Chervonenkis, A.Y. chessboard χ 2 distance χ 2 statistic Chi-squared distribution Chiang, M.S. chicken Choi, B.S. Chomsky, N. Chou, P.A. Chuang, I. Chung, K.L. Church’s thesis Cioffi, J.M. cipher substitution Clarke, B.S. classroom Cleary, J.G. closed system closure Cocke, J. cocktail party code arithmetic, see arithmetic coding block, see block code channel, see channel code distributed source, see distributed source coding error correcting, see error correcting code extension Gaussian channel Hamming, see Hamming code Huffman, see Huffman code instantaneous, see also code, prefix minimum distance minimum weight Morse, see Morse code nonsingular optimal prefix random self-punctuating Shannon, see Shannon code source, see source code uniquely decodable zero-error codebook codelength code points codeword optimal length Cohn, M. coin flips coin tosses coin weighing coins bent biased fair large deviations colored noise coloring random comma common information communication channel communication networks communication system communication theory compact disc compact set company mergers competitive optimality log-optimal portfolio Shannon code competitively optimal composition class compression, see data compression computable computable probability distribution computable statistical tests computation channel capacity halting, see halting computation models of physical limits rate distortion computer science computer source code computers concatenation concavity, see also convexity conditional entropy conditional limit theorem conditional mutual information conditional rate distortion, convexity conditional rate distortion function conditional relative entropy conditional type conditionally typical set conditioning reduces entropy constant rebalanced portfolio constrained sequences continuous alphabet continuous channel continuous random variable, see also differential entropy, rate distortion theory quantization, see quantization continuous time convergence of random variables convergence in mean square convergence in probability convergence with probability converse broadcast channel discrete memoryless channel with feedback general multiterminal network multiple access channel rate distortion Slepian-Wolf coding convex closure convex families convex hull convex set convexification convexity, see also concavity capacity region broadcast channel multiple access channel rate distortion function strict convolution convolutional code interleaved cookie-cutting copper Coppersmith, D. correlated random variables, coding, see Slepian-Wolf coding correlation Costa, M.H.M. Costello, D.J. counterfeit covariance matrix Cover, T.M. CPU Cramér, H. Cramér-Rao inequality with bias crosstalk cryptography Csiszár, I. Csiszár-Tusnády algorithm cumulative distribution function cut set D -adic distribution D -ary alphabet Dantzig, G.B. Darroch, J.N. Daróczy, Z. data compression data processing inequality data transmission Daubechies, I. Davisson, L.D. de Bruijn’s identity decision function decision theory, see hypothesis testing decoder decoding robust decoding delay decoding function degraded broadcast channel, see broadcast channel, degraded physically degraded relay channel, see relay channel, degraded stochastically degraded Dembo, A. demodulation Dempster, A.P. density descriptive complexity determinant determinant inequalities deterministic deterministic decoding rule deterministic function Devroye, L. dice dictionary differential entropy bound conditional Gaussian distribution relationship to discrete entropy table of Diggavi, S. digital dimension Dirichlet distribution Dirichlet partition discrete discrete channel discrete entropy discrete memoryless channel discrete memoryless source discrete random variable discrete time discrimination distance between probability distributions Euclidean relative entropy variational distinguishable inputs distinguishable signals distortion, see also rate distortion theory asymmetric Hamming, see Hamming distortion squared error, see squared error distortion distortion function distortion measure bounded Hamming distortion Itakura-Saito squared error distortion distortion rate function distortion typical distributed source coding, see also Slepian-Wolf coding distribution two mass point divergence DiVincenzo, D.P. DMC, see discrete memoryless channel Dobrushin, R.L. dog Donoho, D.L. doubling rate doubly stochastic matrix DSL duality data compression and data transmission data compression and gambling growth rate and entropy rate multiple access channel and Slepian-Wolf coding rate distortion and channel capacity source coding and generation of random variables Duda, R.O. Dueck, G. Durbin algorithm Dutch Dutch book DVD dyadic dyadic distribution ear Ebert, P.M. echoes Eckschlager, K. economics edge process effectively computable efficient estimator efficient frontier Effros, M. Efron, B. Eggleston, H.G. eigenvalue Einstein, A. Ekroot, L. El Gamal, A. elephant Elias, P. Ellis, R.S. EM algorithm empirical empirical distribution convergence empirical entropy empirical frequency encoder encoding function encrypted text energy England English entropy rate models of entanglement entropy average axiomatic definition base of logarithm bounds chain rule concavity conditional, see conditional entropy conditioning cross entropy differential, see differential entropy discrete encoded bits functions grouping independence bound infinite joint, see joint entropy mixing increase mixture and mutual information properties of relative, see relative entropy Renyi sum thermodynamics entropy and relative entropy entropy power entropy power inequality entropy rate differential English Gaussian process Hidden Markov model Markov chain subsets envelopes Ephremides, A. Epimenides liar paradox equalization Equitz, W. erasure erasure channel ergodic ergodic process ergodic source ergodic theorem ergodic theory Erkip, E. Erlang distribution error correcting code error detecting code error exponent estimation spectrum estimator bias biased consistent in probability domination efficient unbiased Euclidean distance Euclidean geometry Euclidean space Euler’s constant exchangeable stocks expectation expected length exponential distribution extension of channel extension of code F-distribution face vase illusion factorial Stirling’s approximation fading fading channel Fahn, P. fair odds fair randomization Fan, K. Fano, R.M. see also Shannon-Fano-Elias code Fano’s inequality FAX FDMA (Frequency Division Multiple Access) Feder, M. Feder, T. feedback discrete memoryless channel Gaussian channel Feinstein, A. Feller, W. Fermat’s last theorem fingers finite alphabet finitely often finitely refutable first order in the expononent Fisher, R.A. Fisher information examples multiparameter Fitingof, B.M. fixed rate block code flag flow of information flow of time flow of water football Ford, L.R. Ford-Fulkerson theorem Forney, G.D. Foschini, G.J. Fourier transform fractal Franaszek, P.A. Frank-Wolfe algorithm French frequency Friedman, J.H. Fulkerson, D.R. function concave convex functional future Gaarder, T. Gabor, D. Gács, P. Gadsby Gallager, R.G. Galois field theory gambling universal gambling and data compression game 20 questions Hi-Lo mutual information red and black Shannon guessing stock market game theory fundamental theorem game-theoretic optimality γ (Euler’s constant) Gamma distribution gas Gauss’s law Gauss-Markov process Gaussian Gaussian channel achievability AWGN (additive white Gaussian noise) bandlimited broadcast, see broadcast channel, Gaussian capacity colored noise converse feedback interference, see interference channel, Gaussian with memory multiple access, see also multiple access channel, Gaussian parallel relay, see also relay channel, Gaussian Gaussian distribution, see normal distribution Gaussian process Gaussian source rate distortion function Gaussian stochastic process Gelfand, I.M. Gelfand, S.I. Gemelos, G. general multiterminal network general theory of relativity generalized Lloyd algorithm generation of random variables geodesic geometric distribution geometry Euclidean geophysical applications Gersho, A. Gibson, J.D. GIF Gilbert, E.N. Gill, J. Glavieux, A. Gödel’s incompleteness theorem Goldbach’s conjecture Goldberg, M. Goldman, S. Goldsmith, A. Golomb, S.W. Goodell, K. Gopinath, R. Gotham gradient search grammar Grant, A.J. graph graph coloring gravestone gravitation Gray, R.M. greetings telegrams Grenander, U. grouping rule growth rate chain rule competitive optimality convexity optimal side information growth rate optimal Grünbaum, B. Guiasu, S. Gupta, V. Gutman, M. Gyorfi, L. gzip Hadamard’s inequality Hajek, B. halting halting computation halting problem halting program Hamming codes Hamming distortion Hamming, R.V. Han, T.S. handwriting Hart, P.E. Hartley, R.V. Hassanpour, N. Hassibi, B. Hassner, M. HDTV Hekstra, A.P. Helstrom, C.W. Hershkovits, Y. Hewlett-Packard hidden Markov model (HMM) high probability set histogram historical notes HMM, see hidden Markov model (HMM) Hochwald, B.M. Hocquenghem, P.A. Holsinger, J.L. Honig, M.L. Hopcroft, J.E. Horibe, Y. horse race Huffman code competitive optimality dyadic distribution Huffman, D.A. Hui, J.Y. Humblet, P.A. hypothesis testing Bayesian optimal, see Neyman-Pearson lemma i.i.d. (independent and identically distributed) source identification capacity Ihara, S. image distortion measure entropy rate Kolmogorov complexity Immink, K.A.S. incompressible sequence independence bound on entropy India indicator function induction inequalities inequality arithmetic mean geometric mean Brunn-Minkowski, see Brunn-Minkowski inequality Cauchy-Schwarz Chebyshev’s data processing, see data processing inequality determinant, see determinant inequalities entropy power, see entropy power inequality Fano’s, see Fano’s inequality Hadamard’s, see Hadamard’s inequality information Jensen’s, see Jensen’s inequality Kraft, see Kraft inequality log sum, see log sum inequality Markov’s, see Markov’s inequality McMillan’s, see McMillan’s inequality subset, see subset inequalities Young’s Ziv’s inference infinite bandwidth infinitely often information, see also Fisher information, mutual information, self information information capacity information channel capacity information divergence, see also relative entropy information for discrimination, see also relative entropy information rate distortion function innovations input alphabet input distribution instantaneous code, see code, instantaneous integer binary representation descriptive complexity integrability interference interference channel degraded Gaussian high interference strong interference interleaving internet intersymbol interference intrinsic complexity investment investor irreducible Markov chain, see Markov chain, irreducible Itakura-Saito distance iterative decoding Iyengar, G. Jacobs, I.M. Jayant, N.S. Jaynes, E.T. Jelinek, F. Jensen’s inequality Johnson, R.W. joint AEP joint density joint distribution joint entropy joint source channel coding theorem joint type joint typicality jointly typical jointly typical sequences jointly typical set Jozsa, R JPEG Julian, D. Justesen, J. Kac, M. Kac’s lemma Kailath, T. Karlin, S. Karush, J. Kaul, A. Kawabata, B. Keegel, J.C. Kelly, J. Kelly, F.P. Kelly gambling Kemperman, J.H.B. Kendall, M. keyboard Khairat, M.A. Khinchin, A.Y. Kieffer, J.C. Kim, Y.H. Kimber, D. kinetic energy King, R. Knuth, D.E. Kobayashi, K. Kolmogorov, A.N. Kolmogorov complexity conditional and entropy of integers lower bound universal probability upper bound Kolmogorov structure function Kolmogorov sufficient statistic Kolmogorov’s inequality Kontoyiannis, Y. Körner, J. Kotel’nikov, V.A. Kraft, L.G. Kraft inequality Krichevsky, R.E. Kuhn-Tucker conditions Kulkarni, S.R. Kullback, J.H. Kullback, S. Kullback Leibler distance, see also relative entropy 1 distance Lagrange multipliers Laird, N.M. Lamping, J. Landau, H.J. Landauer, R. Langdon, G.G. Lapidoth, A. Laplace, P.S. Laplace distribution Laplace estimate large deviation theory Latané, H.A. Lavenberg, S. law of large numbers incompressible sequences method of types weak law lecturer Lee, E.A. Leech, J. Lehmann, E.L. Leibler, R.A. Lempel, A., see also Lempel-Ziv coding Lempel-Ziv fixed database infinite dictionary sliding window tree structured Lempel-Ziv algorithm Lempel-Ziv coding Lempel-Ziv compression Lempel-Ziv parsing letter Leung, C.S.K. Levin, L.A. Levinson algorithm Levy’s martingale convergence theorem lexicographic order Li, M. Liao, H. liar paradox Lieb, E.J. likelihood likelihood ratio likelihood ratio test Lin, S. Lind, D. Linde, Y. Linder, T. Lindley, D. linear algebra linear code linear inequalities linear predictive coding list decoding Liversidge, A. Lloyd, S.P. Lloyd aglorithm local realism logarithm base of lognormal distribution log likelihood log-optimal portfolio competitive optimality log sum inequality Longo, G. Lotto Louchard, G. Lovasz, L. low density parity check (LDPC) codes Lucky, R.W. Lugosi, G. LZ77 LZ78 MacKay, D.J.C. macrostate MacWilliams, F.J. Madhow, U. magnetic recording Malone, D. Mandelbrot set Marcus, B. margin marginal distribution Markov approximation Markov chain aperiodic functions of irreducible stationary distribution time invariant time-reversible Markov fields Markov lemma Markov process, see also Gauss-Markov process Markov’s inequality Markowitz, H. Marks, R.J. Marshall, A. Martian Martin-Löf, P. martingale martingale convergence theorem Marton, K. Marzetta, T.L. Massey, J.L. mathematics Mathis, C. Mathys, P. matrix channel transition doubly stochastic parity check permutation probability transition trace transition matrix inequalities max-flow min-cut maximal probability of error maximum a posteriori maximum entropy conditional limit theorem prediction error spectral density maximum entropy distribution maximum entropy graph maximum entropy process maximum likelihood maximum likelihood decoding maximum likelihood estimation Maxwell-Boltzmann distribution Maxwell’s demon maze Mazo, J. McDonald, R.A. McEliece, R.J. McLaughlin, S.W. McMillan, B., see also Shannon-McMillan-Breiman theorem McMillan’s inequality MDL (minimum description length) mean value theorem mean-variance theory measure theory median medical testing Melsa, J.L. memoryless, see also channel, discrete memoryless merges Merhav, N. Merton, R.C. Messerschmitt, D.G. method of types metric microprocessor microstate MIMO (multiple-input multiple-output) minimal sufficient statistic minimax redundancy minimum description length minimum distance between convex sets relative entropy minimum variance minimum weight Minkowski, H. Mirsky, L. Mitchell, J.L. mixed strategy mobile telephone models of computation modem modulation modulo 2 arithmetic molecules moments Mona Lisa money, see also wealth monkey Moore, E.F. Morgenstern, O. Morrell, M. Morse code Moy, S.C. multipath multiple access channel achievability binary erasure channel binary erasure multiple access channel binary multiplier channel capacity region convexity converse cooperative capacity correlated source duality with Slepian-Wolf coding erasure channel feedback Gaussian independent BSC’s multiplexing multi-user information theory, see network information theory multivariate distributions multivariate normal music mutual fund mutual information chain rule conditional continuous random variables non-negativity properties Myers, D.L. Nagaoka, H. Nahamoo, D. Narayan, P. nats Nayak, P.P. Neal, R.M. nearest neighbor nearest neighbor decoding neighborhood Nelson, R. network network information theory feedback Neumann, J.von Newton, I. Newtonian physics Neyman, J. Neyman-Pearson lemma Nielsen, M. Nobel, A. noise colored noiseless channel noisy typewriter Noll, P. nonnegative definite matrix nonnegativity entropy mutual information relative entropy nonsense norm Euclidean normal distribution, see also Gaussian channel, Gaussian source generalized maximum entropy property null space Nyquist, H. Occam’s Razor odds even fair subfair superfair uniform uniform fair Olkin, I. Olshen, R.A. Ω Omura, J.K. onion-peeling Oppenheim, A. optical channel optimal code length optimal decoding optimal doubling rate optimal portfolio oracle Ordentlich, E. Orey, S. Orlitsky, A. Ornstein, D.S. Oslick, M. output alphabet Ozarow, L.H. Pagels, H. Papadias, C.B. Papadimitriou, C. paradox Berry’s Epimenides liar St. Petersburg parallel channels parallel Gaussian source Pareto distribution parity parity check code parity check matrix parsing partial recursive functions partition Pasco, R. past Patterson, G.W. Paulraj, A.J. Pearson, E.S. Peile, R.E. Pennebaker, W.B. Perez, A. perihelion of Mercury periodogram permutation permutation matrix perpendicular bisector perturbation Phamdo, N. philosopher’s stone philosophy of science photographic film phrase physically degraded physics π picture on cover Pierce, J.R. pigeon Pinkston, J.T. Pinsker, M.S. pitfalls pixels pkzip Plotnik, E. Poisson distribution Pollak, H.O. Pollard, D. Poltyrev, G.S. Polya’s urn model polynomial number of types Pombra, S. Poor, H.V. portfolio portfolio strategy portfolio theory positive definite matrix Posner, E. power power constraint power spectral density Pratt, F. prediction prediction error prefix prefix code principal minor prior Bayesian Proakis, J. probability density probability mass function probability of error Bayesian maximal probability simplex probability theory probability transition matrix process program length prolate spheroidal functions proportional betting proportional gambling punctuation Pursley, M.B. Pythagorean theorem quantization quantum channel capacity quantum data compression quantum information theory quantum mechanics queen Rabiner, L.R. race, see horse race radio radium random box size random coding random number generation random process Bernoulli random questions random variable Bernoulli generation random walk randomization rank Rao, C.R. Ratcliff, D. rate achievable, see achievable rate entropy, see entropy rate rate distortion achievability Bernoulli source computation converse erasure distortion Gaussian source infinite distortion multivariate Gaussian source operational definition parallel Gaussian source Shannon lower bound with side information squared error distortion rate distortion code optimal rate distortion function convexity information rate distortion region rate distortion theorem rate distortion theory rate region Rathie, P.N. Raviv, J. Ray-Chaudhuri, D.K. Rayleigh, G.G. Rayleigh distribution rebalanced portfolio receiver recurrence recurrence time recursion redistribution of wealth redundancy minimax Reed, I.S. Reed-Solomon codes Reiffen, B. reinvest relative entropy χ 2 bound asymmetry bounds chain rule convexity and Fisher information 1 bound non-negativity properties relative entropy distance relative entropy neighborhood relay channel achievability capacity converse degraded feedback Gaussian physically degraded reversely degraded Renyi entropy Renyi entropy power reproduction points reverse water-filling Reza, F.M. Rice, S.O. Riemann integrability Rimoldi, B. risk-free asset Rissanen, J. Roche, J. rook Roy, B. Rubin, D.B. run length coding Ryabko, B.Ya. saddlepoint Salehi, M. Salz, J. sample correlation sampling theorem Samuelson, P.A. sandwich argument Sanov, I.N. Sanov’s theorem Sardinas, A.A. Sardinas-Patterson test satellite Sato, H. Savari, S.A. Sayood, K. Schafer, R.W. Schalkwijk, J.P.M. Scheffé, H. Schnorr, C.P. Scholtz, R.A. Schrödinger’s wave equation Schultheiss, P.M. Schumacher, B. Schwalkwijk, J.P.M. Schwarz, G. score function second law of thermodynamics, see also statistical mechanics concavity self-information self-punctuating self-reference sequence length sequential projection set sum sgn function Shakespeare Shamai, S. Shannon code competitive optimality Shannon guessing game Shannon lower bound Shannon’s first theorem (source coding theorem) Shannon’s second theorem (channel coding theorem) Shannon’s third theorem (rate distortion theorem) Shannon, C.E., see also Shannon code Shannon-Fano-Elias code Shannon-McMiIlan-Breiman theorem Shannon-Fano code, see also Shannon code Shannon-Fano-Elias code Shannon-McMillan-Breiman theorem Shannon-Nyquist sampling theorem Sharpe, W.F. Sharpe-Markowitz theory Shields, P.C. Shimizu, M. Shor, P.W. Shore, J.E. short selling Shtarkov, Y.M. Shtarkov, Y.V. shuffle Shwartz, A. side information and source coding side information and doubling rate Siegel, P.H. σ algebra signal Sigurjonsson, S. Silicon Dreams silver iodide crystals simplex sinc function Sleator, D. Slepian, D. Slepian-Wolf coding achievability converse duality with multiple access channels slice code slice questions sliding window Lempel-Ziv Sloane, N.J.A. smallest probable set Smolin, J. SNR (Signal to Noise Ratio) Solomon, G. Solomonoff, R.J. source binary Gaussian source channel coding theorem source channel separation source code source coding and channel capacity with side information source coding theorem space-time coding Spanish spectral representation theorem spectrum spectrum estimation speech sphere sphere covering sphere packing squared error squared error distortion St. Petersburg paradox Stam, A. state diagram state transition stationary stationary distribution stationary ergodic processes stationary ergodic source stationary market stationary process, 71 statistic Kolmogorov sufficient minimal sufficient sufficient statistical mechanics statistics Steane, A. Stein’s lemma stereo Stirling’s approximation stochastic process ergodic, see ergodic process function of Gaussian without entropy rate stock stock market Stone, C.J. stopping time Storer, J.A. strategy investment strong converse strongly jointly typical strongly typical strongly typical set Stuart, A. Student’s t distribution subfair odds submatrix subset subset inequalities subsets entropy rate subspace sufficient statistic minimal suffix code superfair odds supermartingale superposition coding support set surface area Sutivong, A. Sweetkind-Singer, J. symbol symmetric channel synchronization Szasz’s inequality Szegö, G. Szpankowski, W. Szymanski, T.G. Tanabe, M. Tang, D.L. Tarjan, R. TDMA (Time Division Multiple Access) Telatar, I.E. telegraph telephone channel capacity Teletar, E. temperature ternary ternary alphabet ternary channel ternary code text thermodynamics, see also second law of thermodynamics Thitimajshima, P. Thomas, J.A. Thomasian, A.J. Tibshirani, R. time symmetry timesharing Tjalkens, T.J. Toeplitz matrix Tornay, S.C. trace transition matrix doubly stochastic transmitter Treasury bonds tree code Huffman random tree structured Lempel-Ziv triangle inequality triangular distribution trigram model Trofimov, V.K. Trott, M. Tseng, C.W. Tsoucas, P. Tsybakov, B.S. Tunstall, B.P. Tunstall coding turbo codes Turing, A. Turing machine Tusnády, G. Tuttle, D.L. TV twin two envelope problem two level signalling two stage description two-way channel type type class typewriter typical sequence typical set conditionally typical data compression distortion typical properties strongly typical volume Ullman, J.D. uncertainty Ungerboeck, G. uniform distribution uniform fair odds uniquely decodable code, see code, uniquely decodable universal computer universal data compression universal gambling universal portfolios finite horizon horizon free universal probability universal probability mass function universal source universal source code universal source coding error exponent universal Turing machine Unix Urbanke, R. V.90 V’yugin, V.V. Vajda, I. Valiant, L.G. Van Campenhout, J.M. Van der Meulen, E. Van Trees, H.L. Vapnik, V.N. variable-to-fixed length coding variance, see also covariance matrix variational distance vector quantization Venkata, R. Venkatesh, S.S. Venn diagram Verdu, S. Verdugo Lazo, A.C.G. video video compression Vidyasagar, M. Visweswariah, K. vitamins Vitanyi, P. Viterbi, A.J. Vitter, J.S. vocabulary volume Von Neumann, J. Voronoi partition waiting time Wald, A. Wallace, M.S. Wallmeier, H.M. Washington Watanabe, Y. water-filling waveform weak weakly typical, see typical wealth wealth relative weather Weaver, W.W. web search Wei, V.K.W. Weibull distribution Weinberger, M.J. Weiner, N. Weiss, A. Weiss, B. Welch, T.A. Wheeler, D.J. white noise, see also Gaussian channel Whiting, P.A. Wiener, N. Wiesner, S.J. Wilcox, H.J. Willems, F.M.J. window wine wireless Witsenhausen, H.S. Witten, I.H. Wolf, J.K. Wolfowitz, J. Woodward, P.M. Wootters, W.K. World Series Wozencraft, J.M. Wright, E.V. wrong distribution Wyner, A.D. Wyner, A.J. Yaglom, A.M. Yamamoto, H. Yang, E.-H. Yao, A.C. Yard, J. Yeung, R.W. Yockey, H.P. Young’s inequality Yu, Bin Yule-Walker equations Zeevi, A. Zeger, K. Zeitouni, O. zero-error zero-error capacity zero-sum game Zhang, Z. Ziv, J., see also Lempel-Ziv coding Ziv’s inequality Zurek, W.H. Zvonkin, A.K.
